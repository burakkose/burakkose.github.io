{"pages":[{"tags":"pages","text":"Big Data Apache Spark Apache Spark - Part 1 : Tanıtım Apache Spark - Part 2 : Resilient Distributed Datasets Algoritma Problemleri Arama ve Sıralama (Searching and Sorting) Bubble Sort Insertion Sort Quick Sort Radix Sort Selection Sort Sıralama algoritmalarında kararlılık nedir? Quick sort için en kötü durum nedir? Hangi sıralama algoritması belleğe en az sayıda yazma yapar? Sıralı iki dizi içerisinde seçilen ikili toplamının hedef sayıya en yakın olması Sıralı olarak verilmiş üç diziden ortak elemanları bulma Sıralı dizi içerisinde hedef sayıya en yakın k sayı K. küçük veya büyük sayısı bulmak Neredeyse sıralı dizi içerisinde arama Parçala Fethet Problemleri (Divide and Conquer Algorithms) Üs alma işlemi (a&#94;x) Dinamik Programlama (Dynamic Programming Algorithms) N. basamağa kaç adımda ulaşılabilir? Hedef puana kaç farklı şekilde ulaşılır? En uzun ortak altdizi(LCS) En uzun artan altdizi(LIS) Açgözlü Problemleri (Greedy Algorithms) Etkinlik paylaşım problemi İş planlama problemi Kruskal Algoritması Bozuk para problemi Prim Algoritması Matematiksel Problemler (Mathematical Algorithms) Veri akışının aritmetik ortalaması Sayı fibonacci sayısı mı? Fibonacci sayısı oluşturma Girilen sayıdan bir sonraki büyük sayıyı bulma Bit işlemleri yardımıyla 7 ile çarpma işlemi Çarpma ve bölme işlemi kullanmadan üs alma Çarpma ve bölme işlemi kullanmadan üs alma Sieve of Eratosthenes Sayının faktoriyelinde sonda bulunan 0'ların sayısı Hileli parayı hilesiz yapmak Desen Arama (Pattern Searching) KMP Algoritmasi En basit hali ile text arama işlemi Suffix Tree Suffix Array Randomize (Randomized Algorithms) Rastgele Sayı Üretmek Linux Arch Linux Nasıl Kurulur İşletim Sistemleri İlk gelen işi kapar (First Come First Serve) İlk iş kısa süreliler (Shortest Job First)","title":"Yazılar","loc":"http://koseburak.net/yazilar/"},{"tags":"Big Data","text":"Bir önceki yazımda Apache Spark kurlumunu ve basit bir kaç örneği incelemiştik. Bu yazıda RDD(\"resilient distributed dataset) yani esnek dağıtık veri kümelerini inceliyor olacağız. RDD'ler basitçe değişmez(immutable) dağıtık obje koleksiyonlarıdır ve her biri farklı düğümlerde hesaplanmak üzere çeşitli parçalara bölünmüş şekildedir. Python, Scala veya Java'nın sahip olduğu tüm obje türlerini içerebilmekle beraber sizin de tanımladığınız sınıfları içerebilir. Önceki yazımda ; örneğimizde lines = sc.textFile(\"README.md\") gibi bir kod kullandık. Bu kullanım ile aslında Python'da bir string RDD'si yaratmış olduk. Oluşturulan bir RDD yaratıldıktan sonra iki çeşit operasyonla kullanılabilir(bkz:transformations veya actions). Transformation işlemleri ile bir önceki RDD'den yeni bir RDD yaratılmasını sağlar.Örneğin bir önceki yazıda kullandığımız örneğe bakalım. pythonLines = lines.filter(lambda line: \"Python\" in line) Burada bir önceki RDD'yi( 'lines' ) kullanarak yeni bir RDD( 'pythonLines' ) oluşturuyoruz. Action ise sahip olduğumuz RDD üzerinde hesaplama türü işlemler yapmaktır. Örneğin; pythonLines.first() Cache veya Persist Eğer elinizdeki bir RDD'yi birçok kez kullanacaksak ve performansdan kazanmak istiyorsak, Spark'a bunu RDD.persist() şeklinde bildirerek, memory'i kullanarak daha fazla performans elde edebilirsiniz(cache(), persist() ile aynı işlevi görür).Yazının devamında bu konuyu işliyor olacağız fakat kullanımı aşağıdaki gibidir. pythonLines.persist Özetlemek gerekirse her Spark uygulaması aşağıdaki gibi bir yol izler. Elindeki verilerden RDD'ler oluştur. Yeni RDD'ler elde et.(Transformation aşaması) Eğer birden fazla işlem yapacaksan Spark'a persist işlemini bildir. Elindeki veriyi işle.(Action aşaması) RDD oluşturmak 1.Var olan bir koleksiyondan lines = sc.parallelize([\"burak\", \"kose\", \"arch\" , \"linux\"]) Protatip ve test işlemleri yaparken uygun olan bir yöntemdir fakat gerçek zamanlı uyglamalarda çok da kullanışlı değildir, çünkü tek bir makinenin hafızasında büyük bir veri olması gerekmektedir ve dolayısı ile çoğu zaman böyle bir kaynak mümkün değildir. 2.Harici depolamadan data = sc.textFile(\"file-path\") şeklinde kullanımdır. Dönüşümler(Transformations) Yürütülen her bir transformation işlemi gerçekten bir action ile karşılaşana kadar gerçekleştirilmez.Buna \"Lazy Evaluation\" denir. \"Lazy Evaluation\" terimine daha önce foksiyonel bir programlama dili uğraşanlar aşinadır fakat terimi kısaca açıklamak gerekirse bir işlemin mecbur kalınana kadar yürütülmediği bir yaklaşımdır. Bir örnek gösterelim, elimizde bir log dosyası olsun ve biz içerisinde \"error\" geçen logları elde etmek isteyelim.Yapmamız gereken Örnek : filter() input = sc.textFile(\"log.txt\") error = input.filter(lambda x: \"error\" in x) şeklinde olacaktır. error 'un yeni bir RDD olduğuna dikkat edin. Örnek : union() errorsRDD = inputRDD.filter(lambda x: \"error\" in x) warningsRDD = inputRDD.filter(lambda x: \"warning\" in x) badLinesRDD = errorsRDD.union(warningsRDD) Yapılan işleri aşağıdaki gibi bir görsel ile özetleyebiliriz. İki çok genel transformation işlemi vardır, map ve filter . Bunların işlevleri aşağıdaki görseldeki gibi açıklanabilir. Örnek : map() >>> nums = sc.parallelize([1, 2, 3, 4]) >>> squared = nums.map(lambda x: x * x).collect() >>> squared [1, 4, 9, 16] gibi verilen parametredeki sayıların karesini alan bir örnek yazabiliriz. Bazen map işleminin tersine her bir giriş ifadesine karşın birden fazla çıktı üretmek isteriz.Bu tip durumlarda kullanılan operasyon flatMap() 'dir. Aşağıdaki örnek girdi olarak verilen metni basitçe kelimelerine ayırır. Örnek : flatMap() >>> lines = sc.parallelize([\"hello world\", \"hi\"]) >>> words = lines.flatMap(lambda line: line.split(\" \")) >>> words.first() 'hello' Aşağıdaki görselde aynı işlemin map ve flatMap arasındaki farkı özetlenmektedir. Transformation işlemlerini incelemeye devam edelim. Yukarıdaki görseli açıklamak istersek kısaca, - distinct işlemi ile tekrar eden kayıtları atarak geriye eşsiz kayıtlardan oluşan bir RDD elde edebiliriz. - union işlemine daha önce değinmiştik.İki RDD'yi birleştirme işlevini görür fakat elemanların tekrarı ile ilgilenmediğine dikkat edin. - intersection işlemi iki RDD arasındaki ortak elemanları elde etmemizi sağlar. - subtract ile fonksiyona parametre olarak verilen RDD'deki elemamanlar dışındaki verileri elde ederiz. Bunların dışında iki RDD arasında kartezyen çarpım da elde edebiliriz. Bunun için RDD1.cartesian(RDD2) uygulamamız yeterlidir. Eylemler(Actions) RDD oluşturmayı, var olan bir RDD'den yeni bir RDD yaratmayı transformation bölümünde gördük.Şimdi sıra veriler ile oynamada. Yapacağımız şey yukarıdaki örnekte elde ettiğimiz badLinesRDD içerisindeki '5' log satırını görüntülemek olsun. Örnek : take() print(badLinesRDD.count(),\" lines\") print(\"İşte beş örnek\") for line in badLinesRDD.take(5): print(line) take() gibi birde collect() vardır fakat collect() kullanacaksanız veri boyutunun çok küçük olması gerektiği ve tek bir makinede çalışmanız gerektiğini unutmayın. Dolayısı ile collect() büyük veri kümelerinde çalışmak için uygun değildir. Sanırım en çok kullanılan action reduce 'dur. Kullanımı aşağıdaki gibidir. sum = rdd.reduce(lambda x, y: x + y) veya Python'da operator modülünü kullanabiliriz. from operator import add sum = rdd . reduce ( add ) Dikkat ettiyseniz reduce fonksiyonu geriye içinde işlem yaptığımız RDD'nin sahip olduğu tipte bir değer döndürmektedir.Bu yukarıdaki gibi toplama işlemi gibi operasyonlar da başarılı fakat geriye tek bir değer değil bir ikili döndürmek isteyebiliriz. Diğer basit action işlemlerini inceleyelim. İleride daha ayrıntılı bir biçimde tüm action işlemlerini inceleyeceğiz. Fonksiyon Açıklaması Kullanım Sonuç collect() RDD'deki tüm elemanları döndürür rdd.collect() [1, 2, 3, 3] count() RDD'deki eleman sayılarını döndürür rdd.count() 4 countByValue() RDD içerisindeki her bir elemanın kaç defa geçtiğini bilgisini verir rdd.countByValue() [(1, 1),(2, 1),(3, 2)] take(num) RDD'den num sayısı kadar eleman döndürür rdd.take(2) [1, 2] top(num, key=None) RDD'den en büyük num sayısı kadar sayı döndürür rdd.top(2) [3, 3] takeOrdered(num, key=None) Parametlere olarak verilen sıralama şartına göre num adet sıralanmış örnek döndürür rdd.takeOrdered(2) [3, 3] takeSample(withReplacement, num, [seed]) Rastgele n eleman döndürür rdd.takeSample(True, 1, 1) Kestirilemez reduce(func) Paralel olarak elemanları birleştirir rdd.reduce(lambda x,y:x+y) 9 foreach(func) Parametre olarak verilen fonksiyon tün elemanlar üzerinde uygulanır rdd.foreach(func) Önbellekleme(Caching) Spark RDD'lerinin \"lazily evaluated\" olduğundan bahsetmiştik. Bazen uygulamalarımızda bir RDD'yi birden fazla kez kullanmamız gerekebilir. Eğer bunu doğrudan yapıyor olsaydık, bizim her action isteğimizde, Spark bu RDD'yi ve bağımlılıklarını tekrar tekrar hesaplamak zorunda kalacaktı. Dolayısıyla iteratif algoritmaları kullanmamız gerektiğinde çok masraflı olacaktır. Bu konunun önemi çok fazladır, yazdığınız bir uygulama sorunsuz çalışıyor gibi gözükebilir fakat anlam veremediğiniz bir şekilde yavaş çalışıyorsa ilk olarak önbellekme konusunu incelemenizi tavsiye ederim. Bir örnek yapalım ve ne demek istediğimize bakalım. Örnek : Çift hesaplamalı from operator import add from pyspark import SparkContext if __name__ == '__main__' : sc = SparkContext ( appName = 'myname' ) data = sc . parallelize ( range ( 10 )) \\ . map ( lambda x : x ** 2 ) print ( data . count ()) print ( ',' . join ( str ( s ) for s in data . collect ())) Bu tip bir performans kaybı yerine, Spark'a bu datayı 'persist' edebilir misin diye sorarız. Birden fazla seviye vardır.Genel olarak aşağıdaki gibi açıklanabilir. Seviye Yer kullanımı CPU kullanımı Bellekte mi? Diskte mi? Açıklama MEMORY_ONLY Yüksek Düşük Evet Hayır MEMORY_ONLY_SER Düşük Yüksek Evet Hayır MEMORY_AND_DISK Yüksek Orta Birazı Birazı Veri bellek için fazla büyükse veri parçalarını diske koymaya başlar MEMORY_AND_DISK_SER Düşük Yüksek Birazı Birazı Veri bellek için fazla büyükse veri parçalarını diske koymaya başlar. Serilize edilerek saklanır DISK_ONLY Düşük Yüksek Hayır Evet Örnek : Persist kullanımı from operator import add from pyspark import SparkContext if __name__ == '__main__' : sc = SparkContext ( appName = 'myname' ) data = sc . parallelize ( range ( 10 )) \\ . map ( lambda x : x ** 2 ) data . persist ( StorageLevel . DISK_ONLY ) print ( data . count ()) print ( ',' . join ( str ( s ) for s in data . collect ())) Not :persist() fonksiyonunun RDD henüz action ile karşılaşmadan önce çağrıldığına dikkat edin. Eğer belleğe sığamayacak kadar veriyi önbelleklemeye çalışırsanız Spark otomatik olarak kendini Least Recently Used (LRU) politikasına göre düzenleyecektir. Burada bahsedilenden çok daha fazla sayıda transformation ve action işlemi vardır. Çok daha ayrıntılı biçimde ileriki yazılarımda bahsedeceğim. BURAK KÖSE","title":"Apache Spark - Part 2 : Resilient Distributed Datasets","loc":"http://koseburak.net/blog/apache-spark-part2/"},{"tags":"Algoritma","text":"Bir dizi içerisinde en uzun artan altdiziyi bulmayı amaçlayan bir problemdir. Örneğin Input: {10, 22, 9, 33, 21, 50, 41, 60, 80} Output: 6{10, 22, 33, 50, 60, 80} LCS algoritmasına benzer bir yol izleyeceğiz. Kod anlaşılır durumda, çözüm aşağıdadır. def lis(arr): lis = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) if __name__ == '__main__': arr = [10, 22, 9, 33, 21, 50, 41, 60] print(lis(arr)) Yukarıdaki algoritmanın zaman karmaşıklığı O(n&#94;2) 'dir. Algoritma farklı bir yaklaşım ile O(nlogn) karmaşıklık ile çözülebilir. İncelemek için : link","title":"En uzun artan altdizi(LIS) - Dinamik Programlama","loc":"http://koseburak.net/blog/lis/"},{"tags":"Algoritma","text":"Bilgisayar bilimlerinde önemli bir yere sahip olan bu problemde, verilen iki dizgide de ortak olarak bulunan ve aynı yönde sıralanmış dizgiler bütünü elde edilmeye çalışılmaktadır. Örneğin; \"ABCDGH\" ve \"AEDFHR\" için \"ADH\" \"AGGTAB\" ve \"GXTXAYB\" için \"GTAB\" Dosyalar arasındaki farkları, değişiklikleri elde etmede ve özellikle bioinformatik alanında sıkça karşılaşılan bir çözümdür. Çözüm aşağıdaki gibidir. def lcs(s1, s2): len_s1, len_s2 = len(s1) + 1, len(s2) + 1 S = [[0] * len_s1 for _ in range(len_s2)] for i in range(1, len_s2): for j in range(1, len_s1): if s1[j - 1] == s2[i - 1]: S[i][j] = S[i - 1][j - 1] + 1 else: S[i][j] = max(S[i - 1][j], S[i][j - 1]) return S[len_s2 - 1][len_s1 - 1] if __name__ == '__main__': X = \"AGGTAB\" Y = \"GXTXAYB\" print(lcs(X, Y)) Bu algoritmanın zaman karmaşıklığı O(nm) 'dir. Peki hangi dizginin LCS olduğunu bulmak için ne yapmamız gerekiyor? Bunun için şu şekilde bir düzenleme ile sonuca ulaşabiliriz. def lcs ( s1 , s2 ) : len_s1 , len_s2 = len ( s1 ) + 1 , len ( s2 ) + 1 S = [[ 0 ] * len_s1 for _ in range ( len_s2 )] for i in range ( 1 , len_s2 ) : for j in range ( 1 , len_s1 ) : if s1 [ j - 1 ] == s2 [ i - 1 ] : S [ i ][ j ] = S [ i - 1 ][ j - 1 ] + 1 else : S [ i ][ j ] = max ( S [ i - 1 ][ j ], S [ i ][ j - 1 ]) i , j = len_s2 - 1 , len_s1 - 1 result = \"\" while i > 0 and j > 0 : if s1 [ j - 1 ] == s2 [ i - 1 ] : result += s1 [ j - 1 ] i , j = i - 1 , j - 1 elif S [ i - 1 ][ j ] > S [ i ][ j - 1 ] : i -= 1 else : j -= 1 return S [ len_s2 - 1 ][ len_s1 - 1 ], result [ ::- 1 ] if __ name__ == '__main__': X = \"AGGTAB\" Y = \"GXTXAYB\" print ( lcs ( X , Y )) Çok daha ayrıntılı bir inceleme için Wiki sayfasından yardım alabilirsiniz.","title":"En uzun ortak altdizi(LCS) - Dinamik Programlama","loc":"http://koseburak.net/blog/lcs/"},{"tags":"Algoritma","text":"Verilen bir n sayısı var ve bu sayıya kadar olan tüm asal sayıların elde edilmesi için sunulmuş en efektif çözümdür (ref: Wiki) . Algoritma şu şekilde çalışır. 2'den n'e kadar bir liste yaratılır. (2,3,4,5,6...n) p = 2 yapılarak ilk asal sayı 2 ilan edilir. 2p,3p,4p,5p ... gibi katlar alınarak bu sayılar işaretlenir ve asal sayılardan dışlanmış olunur iaşretlenmemiş ilk sayı bulunarak p'ye atanır ve işlemler tekrar edilir. Çözüm aşağıdaki gibi olur. def mark(arr, n): i = 2 num = i * n while num <= len(arr): arr[num - 1] = 1 i += 1 num = i * n def sieve_of_eratosthenes(n): if n >= 2: arr = [0] * n for i in range(1, n): if arr[i] == 0: print(i + 1) mark(arr, i + 1) if __name__ == '__main__': n = 10 sieve_of_eratosthenes(n) Agoritmanın anlaşılırlığı için kod uzun tutulmuştur. Çok daha fazla kısaltılması mümkündür.","title":"Sieve of Eratosthenes - Matematik Problemi","loc":"http://koseburak.net/blog/sieve-of-eratosthenes/"},{"tags":"Algoritma","text":"Verilen sayının faktoriyelinde sonda bulunan sıfırların sayısını bulmamız gerekiyor. Örneğin; Input : n = 5 Output : 1 5 ! = 20 Input : n = 20 Output : 4 20 ! = 2432902008176640000 Input : n = 100 Output : 24 En basit hali ile çözüm, sayının faktoriyelini hesaplamak ve sondaki sıfıların sayısını saymak. Masraflı ve büyük sayılar için çalışmayacak bir yöntem. Matematikten faydalanarak şu şekilde çözebiliriz. Sayının sonunda 0 oluşabilmesi için en az bir adet 2 ve bir adet 5 gerekmektedir. Dolayısı ile sayı içerisindeki 2lerin ve 5lerin sayısını sayarsak çözüme ulaşabiliriz. n = 5: Bir adet 5 ve üç adet 2 bulunmaktadır (2 * 2 * 2 * 3 * 5). Dolayısıyla 0ların sayısı 1'dir. n = 11: İki adet 5 ve üç adet 2 bulunmaktadır. (2&#94;8 * 3&#94;4 * 5&#94;2 * 7). Dolayısıyla 0ların sayısı 2'dir. Sayı içerisindeki 2lerin sayısı es geçebiliriz zaten her seferinde elimizde fazladan 2 olacak. Sadece 5lerin sayısını saymak yeterlidir. Dikkat etmemiz gereken başka bir durum bulunmaktadır. Örneğin 28! sayısı için 25 sayısından gelen fazladan bir 5 durumu vardır. Aynı durum 125 yani 5'in üsleri içinde geçerlidir. n! için sondaki sıfır sayısı = floor(n/5) + floor(n/25) + floor(n/125) + .... def count_zeros(n): result = 0 i = 5 while n // i >= 1: result += n // i i *= 5 return result if __name__ == '__main__': n = 100 print(count_zeros(n))","title":"Sayının faktoriyelinde sonda bulunan 0'ların sayısı - Matematik Problemi","loc":"http://koseburak.net/blog/faktoriyel-0s-count/"},{"tags":"Algoritma","text":"Verilen bir fonksiyon yazı tura işlemini %60 yazı %40 tura gelecek şekilde gerçekleştiriyor. Bu verilen fonksiyonu kullanarak bu işlemi nasıl hilesiz yapabiliriz? Paranın %60 olasılıkla 0, %40 olasılık ile 1 döndürdüğünü biliyoruz. Çözüm olarak bu fonksiyonu iki kere çağıracağız. Eğer sonuçlar (1,0) veya (0,1) ise problem yok, direk cevabı vereceğiz fakat cevaplar (1,1) veya (0,0) ise işlemi tekrarlayacağız. (0, 1): 0 sonrası 1 gelme olasılığı = 0.6 * 0.4 = 0.24 (1, 0): 1 sonrası 0 gelme olasılığı = 0.4 * 0.6 = 0.24 def foo(): 'Bu method hileli olarak 1 veya 0 döndürür' pass def my_foo(): val1 = foo() val2 = foo() if val1 == 0 and val2 == 1: return 0 # 0.24 olasılık if val1 == 1 and val2 == 0: return 1 # 0.24 olasılık return my_foo() # 1 - 0.24 - 0.24 olasılık","title":"Hileli parayı hilesiz yapmak - Matematik Problemi","loc":"http://koseburak.net/blog/0-1-50/"},{"tags":"Algoritma","text":"3, 5 ve 10 puan almanın mümkün olduğu ve hedef puana bu puan gruplarını kullanarak kaç farklı şekilde ulaşılabileceğini bulacağız. Örnek; Input : n = 20 Output : 4 ( 10 , 10 ) ( 5 , 5 , 10 ) ( 5 , 5 , 5 , 5 ) ( 3 , 3 , 3 , 3 , 3 , 5 ) Input : n = 13 Output : 2 ( 3 , 5 , 5 ) ( 3 , 10 ) Çözüm mantığı gayet basittir. n+1 boyutunda bir dizi yaratılır ve her puanlama için döngüler ile tüm çözüm sayıları tutulur. Zaman ve yer karmaşıklığı 0(n) olacaktır. def adjust(l, score, n): for i in range(score, n + 1): l[i] += l[i - score] def count(n): result = [0] * (n + 1) result[0] = 1 # 0 puan için adjust(result, 3, n) adjust(result, 5, n) adjust(result, 10, n) return result[n] if __name__ == '__main__': score = 20 print(count(score)) Cevabı doğru bulduk fakat (10, 5, 5), (5, 5, 10) ve (5, 10, 5) durumları tek bir durum olarak sayılmıştır. Peki bu durumlarıda farklı birer yol olarak saymak istersek yukarıdaki kodu biraz değiştirmek gerekecek. def count_new(n): result = [0] * (n + 1) result[0] = 1 # 0 puan için for i in range(3, n + 1): if i >= 3: result[i] += result[i - 3] if i >= 5: result[i] += result[i - 5] if i >= 10: result[i] += result[i - 10] return result[n] if __name__ == '__main__': score = 20 print(count_new(score))","title":"Hedef puana kaç farklı şekilde ulaşılır? - Dinamik Programlama","loc":"http://koseburak.net/blog/nth-score/"},{"tags":"Algoritma","text":"N adet basamağa sahip bir merdivende, en alt noktadan üst noktaya her seferinde en fazla bir veya iki adım atarak kaç farklı şekilde ulaşabileceğimizi bulacağız. Örneğin yadaki resim için 3 adet çözüm vardır. Daha fazla örnek; Input : n = 1 Output : 1 Sadece 1 adımda ulaşılır Input : n = 2 Output : 2 İ ki farklı adımda ulaşılır : ( 1 , 1 ) ve ( 2 ) Input : n = 4 Output : 5 ( 1 , 1 , 1 , 1 ), ( 1 , 1 , 2 ), ( 2 , 1 , 1 ), ( 1 , 2 , 1 ), ( 2 , 2 ) Basit olarak rekürsif olarak çözebilir. yol(n) = yol(n-1) + yol(n-2) . Aslında yandaki formulun fibonacci formulu olduğu çok belli. def recursion(n): if n <= 1: return n return recursion(n - 1) + recursion(n - 2) def solve(n): return recursion(n + 1) if __name__ == '__main__': n = 4 print(solve(n)) Yukarıdaki çözüm O(2&#94;n) zaman karmaşasına sahiptir. Tabi çok daha efektif çözmenin yollarını şurada daha önce belirttim. Problemin genelleştirilmiş hali Örneğin kişinin m adıma kadar hakkı olsun. m=4 için kişi her bir anda 1, 2, 3 veya 4 adım atabilir. yol(n, m) = yol(n-1, m) + yol(n-2, m) + ... yol(n-m, m) def calculate(n, m): if n <= 1: return n res = 0 i = 1 while i <= m and i <= n: res += calculate(n - i, m) i += 1 return res def solve_gen(n, m): return calculate(n + 1, m) if __name__ == '__main__': basamak = 4 adim = 2 print(solve_gen(basamak, adim))","title":"N. basamağa kaç adımda ulaşılabilir? - Dinamik Programlama","loc":"http://koseburak.net/blog/nth-stair/"},{"tags":"Algoritma","text":"Fibonacci sayılarını oluşturmanın birden fazla yöntemi vardır. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 141, …….. Fn = Fn-1 + Fn-2 F0 = 0 and F1 = 1. Metot 1 ( recursion ) Yukarıda verilmiş olan matematik ifadesinin direkt olarak uygulanmış halidir. İşe yarar ama çok fazla maliyetlidir. T(n) = T(n-1) + T(n-2) karmaşıklık analizi çözüldüğünde karşımıza O(2&#94;n) çıkar. Gerçekten maliyetli bir çözüm! def recursion(n): if n <= 1: return n return recursion(n - 1) + recursion(n - 2) if __name__ == '__main__': n = 9 print(recursion(n)) Metot 2 (Dynamic Programming) Metot 1'deki öz yinelemeli çözümde aynı değerleri defalarca hesapladıımızı görmüşsünüzdür. Bu işlemi önlemek amaçlı dinamik programlama yaklaşımına bakacağız. def dynamic(n): fib_list = [0, 1] for i in range(2, n + 1): fib_list.append(fib_list[i - 1] + fib_list[i - 2]) return fib_list[n] if __name__ == '__main__': n = 9 print(dynamic(n)) Bu çözümün zaman karmaşıklığı O(n) ve yer karmaşıklığı O(n) olmaktadır. Metot 3 (Metot 2 için yer düzenlemesi) Metot 2'de yapılan çözüm yer karmaşıklığına sahiptir. Yani ekstra bellek kullanımı gerektiren bir çözümdür. Bu çözümü aynı proramlama paradigması ile yerden ödün vermeyerek şu şekilde çözebiliriz. def space_dynamic(n): a, b = 0, 1 if n == 0: return a for i in range(2, n + 1): a, b = b, a + b return b if __name__ == '__main__': n = 9 print(space_dynamic(n)) Metot 4 Bir başka O(n) çözüme sahip bir çözüm olan bu çözümde elimizde bir matris var. M = [[1,1],[1,0]] n. fibonacci sayısını istiyorsak bu matrisi kendisi ile n kere çarpmamız ve (0,0) elemanını almamız gerekmektedir. Kısacası pow(M,n) işlemi yapmamız gerekmektedir. def matrix(n): F = [[1, 1], [1, 0]] if not n: return 0 power(F, n - 1) return F[0][0] def power(F, n): M = [[1, 1], [1, 0]] for i in range(2, n + 1): multiply(F, M) def multiply(F, M): x = F[0][0] * M[0][0] + F[0][1] * M[1][0] y = F[0][0] * M[0][1] + F[0][1] * M[1][1] z = F[1][0] * M[0][0] + F[1][1] * M[1][0] w = F[1][0] * M[0][1] + F[1][1] * M[1][1] F[0][0] = x F[0][1] = y F[1][0] = z F[1][1] = w if __name__ == '__main__': n = 9 print(matrix(n)) Zaman karmaşıklığı O(n) ve yer karmaşıklığı O(1) olur. Metot 5 (Metot 4 iyileştirmesi) Bu adım ile artık n. fibonacci sayısını bulma işlemini O(logn) karmaşıklıkta çözebileceğiz. def matrix_opt(n): F = [[1, 1], [1, 0]] if not n: return 0 power(F, n - 1) return F[0][0] def power_opt(F, n): if n == 0 and n == 1: return M = [[1, 1], [1, 0]] power_opt(F, n / 2) multiply(F, F) if n % 2 != 0: multiply(F, M) def multiply(F, M): x = F[0][0] * M[0][0] + F[0][1] * M[1][0] y = F[0][0] * M[0][1] + F[0][1] * M[1][1] z = F[1][0] * M[0][0] + F[1][1] * M[1][0] w = F[1][0] * M[0][1] + F[1][1] * M[1][1] F[0][0] = x F[0][1] = y F[1][0] = z F[1][1] = w if __name__ == '__main__': n = 9 print(matrix_opt(n))","title":"Fibonacci sayısı oluşturma - Matematik Problemi","loc":"http://koseburak.net/blog/fibonacci/"},{"tags":"Algoritma","text":"Artan sırada verilmiş üç dizi içerisinde bulunan ortak elemanı bulmamıza yarayan algoritmaya bakacağız. Örneğin ar1[] = {1, 5, 10, 20, 40, 80} ar2[] = {6, 7, 20, 80, 100} ar3[] = {3, 4, 15, 20, 30, 70, 80, 120} Output: 20, 80 ar1[] = {1, 5, 5} ar2[] = {3, 4, 5, 5, 10} ar3[] = {5, 5, 10, 20} Output: 5, 5 Basit olarak ilk çözüm link! algoritmasını uygulamak ve elde edilen değerleri yedek bir dizi içerisinde tutmaktır. Bu çözüm ile karmaşıklık O(n1+n2+n3) olacaktır. Yukarıda ki çözüm ekstra olarak hafıza ve iki adet döngü içermektedir. Oysa bu soruyu tek bir döngüde ve ektra hafıza gerektirmeden çözebiliriz. Çözüm aşağıdaki gibidir. def find_common(ar1, ar2, ar3): i, j, k = 0, 0, 0 n1, n2, n3 = len(ar1), len(ar2), len(ar3) while i < n1 and j < n2 and k < n3: if ar1[i] == ar2[j] and ar2[j] == ar3[k]: print(ar1[i]) i, j, k = i + 1, j + 1, k + 1 elif ar1[i] < ar2[j]: i += 1 elif ar2[j] < ar3[k]: j += 1 else: k += 1 if __name__ == '__main__': ar1 = [1, 5, 10, 20, 40, 80] ar2 = [6, 7, 20, 80, 100] ar3 = [3, 4, 15, 20, 30, 70, 80, 120] find_common(ar1, ar2, ar3) Karmaşıklık O(n1+n2+n3) olacaktır.","title":"Sıralı olarak verilmiş üç diziden ortak elemanları bulma - Arama Algoritması","loc":"http://koseburak.net/blog/search-common-element-three/"},{"tags":"Algoritma","text":"Suffix dizisi, verilmiş olarak verilen stringe ait tüm suffixlerin alfabetik olarak sıralanmış halidir. Suffix array eğer elinizde bir suffix tree varsa, bu ağaç üzerinde DFS algoritmasını işletilmesi ile elde edilebilir. Suffix array veri yapısının, suffix tree'den avantajları, geliştirilmiş bellek performansı ve keşleme özelliğidir. Önreğin; \"banana\" için. 0 banana 5 a 1 anana Suffixes sırala 3 ana 2 nana ----------------> 1 anana 3 ana alfabetik olarak 0 banana 4 na 4 na 5 a 2 nana \"banana\" için suffix dizisi {5, 3, 1, 0, 4, 2} olur. Suffix Array oluşturmak için temel metot Açıkçası yukarıdaki örnek yeterince açık, basit bir kaç core fonksiyon sayesinde oluşturulabilecek bir algoritma. Ben biraz işin kolayına kaçarak Python'da basit şekilde oluşturacağım. def build_suffix_array(text): return sorted(range(len(text)), key=lambda x: text[x:]) Yukarıdaki algoritma O(n&#94;2logn) zaman karmaşıklığında çalışmaktadır. Suffix array oluşturmak içi çok daha verimli algoritmalar bulunmaktadır! Arama işlemi Elimizde aslında sıralanmış bir string dizisi var gibi düşünebiliriz ve sıralanmış bir dizi içerisinde arama yapma işleminde herkesin muhtemelen aklına gelen algoritma Binary Search algoritmasıdır. Bu işlemdede bu algoritmayı kullanacağız. Çözüm aşağıdaki gibi olacaktır. def search(text, pattern, suffs, l, r): if r < l: return -1 mid = l + (r - l) // 2 t = text[suffs[mid]:][:len(pattern)] if pattern == t: return suffs[mid] elif pattern > t: return search(text, pattern, suffs, mid + 1, r) else: return search(text, pattern, suffs, l, mid - 1) if __name__ == '__main__': text = \"banana\" pattern = \"anan\" suffix_array = build_suffix_array(text) print(search(text, pattern, suffix_array, 0, len(text) - 1)) Yukarıdaki arama algoritması O(mlogn) 'dir. Gerçek şu ki suffix array veri yapısı için çok daha verimli tanımlamalar vardır. Bu gerçekten çok basit bir giriştir ve olayın genel mantığı için","title":"Suffix Array - String Algoritmaları","loc":"http://koseburak.net/blog/suffix-array/"},{"tags":"Algoritma","text":"Hoşuma giden problem türlerinden olan yakın ikili sorularından biri. Bu problemde girdi olarak verilen iki tane sıralanmış dizi ve bir hedef numarası bulunuyor ve dizilerden seçilen hangi iki elemanın toplamının hedef elemana en yakın sayı olacağını bulmamız gerekiyor. Örnek olarak; Input : ar1 [] = { 1 , 4 , 5 , 7 }; ar2 [] = { 10 , 20 , 30 , 40 }; x = 32 Output : 1 and 30 Input : ar1 [] = { 1 , 4 , 5 , 7 }; ar2 [] = { 10 , 20 , 30 , 40 }; x = 50 Output : 7 and 40 gibi. Eğer dizilerin birinin n elemanlı diğerinin m elemanlı (n=m olabilir) olduğunu varsayarsak en ilkkel çözüm şu şekilde olacaktır. İki tane döngü kurarak karşılıklı olarak tüm ihtimalleri deneyerek cevaba ulaşmaya çalışırız. Tabi bu çözümde verilen dizilerin sıralı olup olmamasının bir değeri kalmamakla birlikte zaman karmaşıklığımız O(n&#94;2) olacaktır. Şimdi başka bir taraftan probleme bakalım.Verilen dizileri aynı merge sort işleminde olduğu gibi birleştirelim ve tek bir dizi üzerinden hedef elemana ulaşmaya çalışabiliriz(buda özel bir problem). Bunun sayesinde karmaşıklık O(n) dolaylarına inecektir ve ekstra memory kullanmış olacağız. Peki çok daha iyi bir çözüm yok mu? Karşılaştırma için diff adında sonsuz değere sahip bir değişken ata Sıralı olarak verilen diziler üzerinde gezinmek için l ve r adında ki index değişkeni tutun l = 0 ve r = -1 Döngü şartı l < m ve r >= 0 olmak üzere Eğer abs(ar1[l] + ar2[r] - sum) < diff ise diff ve result değişkenlerini güncelle Eğer ar1[l] + ar2[r] < sum ise l++ r-- Çözüm aşağıdaki gibi olacaktır. from math import inf def print_closest ( ar1 , ar2 , x ): diff = inf res_l , res_r = - 1 , - 1 l , r = 0 , len ( ar2 ) - 1 while l < len ( ar1 ) and r >= 0 : if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff : resl_l , res_r , diff = l , r , abs ( ar1 [ l ] + ar2 [ r ] - x ) if ar1 [ l ] + ar2 [ r ] > x : r -= 1 else : l += 1 print ( \"({} - {})\" . format ( ar1 [ res_l ], ar2 [ res_r ])) if __name__ == '__main__' : ar1 = [ 1 , 4 , 5 , 7 ] ar2 = [ 10 , 20 , 30 , 40 ] x = 38 print_closest ( ar1 , ar2 , x )","title":"Sıralı iki dizi içerisinde seçilen ikili toplamının hedef sayıya en yakın olması - Arama Algoritması","loc":"http://koseburak.net/blog/find-closest-pair-sorted/"},{"tags":"Algoritma","text":"Bir sayıyı yedi ile çarpmanın bitwise karşılığı. if __name__ == '__main__': num = 3 print((num << 3) - num) Not: Sadece pozitif sayılar için.","title":"Bit işlemleri yardımıyla 7 ile çarpma işlemi - Matematik Problemi","loc":"http://koseburak.net/blog/carp-yedi/"},{"tags":"Algoritma","text":"Tıpkı Kruskal algoritmasında olduğu gibi Prim algoritmasında da amaç en kısa yol ağacını bulmaktır ve greedy yaklaşımı ile çözülür. Algoritma aşağıdaki şekilde çalışır. Ağaca eklenmiş tüm düğümleri tutacak bir küme oluştur( mst_set ). Başlangıçta tüm düğümlere sonsuz değeri verin sadece içlerinden bir tanesini seçmek için 0 değeri verin. Eğer 1. adımda oluşturduğunuz küme tüm düğümleri kapsamıyorsa mst_set 'in içermediği ve minimum değere sahip düğümü seçin( u ) u 'yu mst_set içerisine atın u 'ya komşu olan tüm düğümlerin değerini güncelleyin.Tüm komşu düğümler( v ) üzerinde güncelleme amacıyla gezinirken eğer u-v önceki değerden küçükse değeri u-v şeklinde güncelleyin. Şimdi algoritmayı uygulamaya geçelim. from math import inf def min_key ( key , mst_set ): '''Geriye minimum değere sahip komşunun indeksini döndürür''' mini , min_index = inf , inf for index , vertex in enumerate ( mst_set ): if not vertex and key [ index ] < mini : mini , min_index = key [ index ], index return min_index def print_prim ( graph ): # Düğüm sayısı vertices_len = len ( graph ) # Oluşturulmuş ağac listesi parent = [ None ] * vertices_len # Minimum ağırlıklı komşuyu seçmek için kullanılan liste key = [ inf ] * vertices_len # Ağaca eklenmemiş düğümleri içeren liste mst_set = [ False ] * vertices_len key [ 0 ] = 0 # İlk düğüm seçiliyor parent [ 0 ] = - 1 # İlk düğüm her zaman root'dur for count in range ( vertices_len - 1 ): # Minimum değere sahip komşu u = min_key ( key , mst_set ) # Ağaca eklenmiş olduğu işaretleniyor mst_set [ u ] = True # Güncelleme işlemi for v in range ( vertices_len ): if graph [ u ][ v ] and not mst_set [ v ] and graph [ u ][ v ] < key [ v ]: parent [ v ], key [ v ] = u , graph [ u ][ v ] print ( \"Edge Weight\" ) for i in range ( 1 , vertices_len ): print ( parent [ i ], \" - \" , i , \" \" , graph [ i ][ parent [ i ]]) if __name__ == '__main__' : \"\"\" 2 3 (0)--(1)--(2) | / \\ | 6| 8/ \\5 |7 | / \\ | (3)-------(4) 9 \"\"\" graph = [[ 0 , 2 , 0 , 6 , 0 ], [ 2 , 0 , 3 , 8 , 5 ], [ 0 , 3 , 0 , 0 , 7 ], [ 6 , 8 , 0 , 0 , 9 ], [ 0 , 5 , 7 , 9 , 0 ], ] print_prim ( graph ) Algoritmanın zaman karmaşıklığı O(n&#94;2) 'dir. Eğer girdi olarak alınan graf komşuluk matrisi yerine binary heap hardımıyla liste şeklinde kullanılmış olsaydı karmaşıklık O(ElogV) olacaktı.","title":"Prim Algoritması - Greedy Yaklaşımı","loc":"http://koseburak.net/blog/prim-mst/"},{"tags":"Algoritma","text":"Bu problemde elimize, bir kaynaktan gelen sürekli veriler var yani hep bir sayı akışı var. Bizden her gelen yeni sayı için o anki aritmetik ortalama istenmektedir. Örneğin; Akış ... 10, 20, 30, 40, 50, 60, … 10 geldiğinde ortalama 10.00 20 geldiğinde ortalama 15.00 30 geldiğinde ortalama 20.00 40 geldiğinde ortalama 25.00 50 geldiğinde ortalama 30.00 60 geldiğinde ortalama 35.00 .................. Çözüm şu şekilde olacaktır. def get_avg(prev, num, count): return (prev * count + num) / (count + 1) def calculate_stream(arr): avg = 0 for i, num in enumerate(arr): avg = get_avg(avg, num, i) print(num, \" geldiğinde ortalama = \", avg, sep=\"\") if __name__ == '__main__': arr = [10, 20, 30, 40, 50, 60] calculate_stream(arr)","title":"Veri akışının aritmetik ortalaması - Matematik Problemi","loc":"http://koseburak.net/blog/stream-ortalama/"},{"tags":"Algoritma","text":"Bize verilen bir miktar para var ve bu miktarı en az sayıda banknot ile karşılamak istiyoruz. Gerçek hayattada sıkça karşılaşılan bir problemi aslında greedy yaklaşımı ile çözüyoruz. Örneğin Input : V = 70 TL Output : 2 50 TL + 20 TL = 70 TL Input : V = 121 TL Output : 3 100 TL + 20 TL + 1 TL = 121 TL Mantık çok basit değil mi? Şimdi çözüme geçelim MONEY = (1, 2, 5, 10, 20, 50, 100, 200) def find_min(target): result = [] for m in sorted(MONEY, reverse=True): while target >= m: target -= m result.append(m) print(*result, sep=\" Tl + \", end=\" = {} TL\".format(sum(result))) if __name__ == '__main__': target = 1994 find_min(target)","title":"Bozuk para problemi - Greedy Yaklaşımı","loc":"http://koseburak.net/blog/bozuk-para/"},{"tags":"Algoritma","text":"Verilen sayının fibonacci sayısı olup olmadığını anlamanın basit bir yolu var. İsterseniz sırayla kendi sayınıza kadar fibonacci sayılarını oluşturup kontrol ederek gidebilirsiniz. Tabi aşırı maliyetli bir çözüm olur, ya da matematikten faydalanırsınız. Bu çözüme tam kare çözümü denmektedir. Kontrol için aşağıdaki eşitliği kullancağız. (5*n&#94;2 + 4) veya (5*n&#94;2 – 4) def is_perfect_square(x): s = x ** 0.5 return s * s == x def is_fibo(n): return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4) if __name__ == '__main__': number = 34 print(is_fibo(number))","title":"Sayı fibonacci sayısı mı? - Matematik Problemi","loc":"http://koseburak.net/blog/fibo-kontrol/"},{"tags":"Algoritma","text":"Üs alma işlemi problemlerine farklı bir yaklaşım sunan bu problemde, çarpma( * ) ve bölme( / ) işlemi kullanmadan üs alma işlemine bakacağız. Örneğin; 5&#94;6 işlemi için; result = 0 1.) 5 kere 5 ekle (5&#94;2) = 25 2.) 5 kere 25 ekle (5&#94;3) = 125 3.) 5 kere 125 ekle (5&#94;4) = 625 4.) 5 kere 625 ekle (5&#94;5) = 3125 5.) 5 kere 3125 ekle (5&#94;6) = 15625 İç içe döngü kullanarak def nested_pow(a, b): if b == 0: return 1 result, increment = a, a for i in range(1, b): for j in range(1, a): result += increment increment = result return result Recursive çözüm def recursion_pow(a, b): if b != 0: return multiply(a, recursion_pow(a, b - 1)) else: return 1 def multiply(x, y): if y != 0: return x + multiply(x, y - 1) else: return 0 if __name__ == '__main__': print(nested_pow(5, 6)) print(recursion_pow(5, 3))","title":"Çarpma ve bölme işlemi kullanmadan üs alma - Matematik Problemi","loc":"http://koseburak.net/blog/pow-without/"},{"tags":"Algoritma","text":"En küçük yol ağacı problemine(minimum spanning tree) üretilmiş bir çözümdür. En basit graf algoritmalarından biridir. Greedy yaklaşımı ile çözüme ulaşılır. Amaç bir graf içerisinde tüm düğümleri kapsayan minimum maliyete sahip ağacı elde etmektir. Aşağıda kabaca algoritmanın çalışmasını anlayabilirsiniz. Tüm kenarları maliyetlerine göre küçükten büyüğe doğru sıralay En düşük maliyetli kenarı seçin ve oluşturduğunuz ağaçta çevrim oluşturup oluşturmadığını kontrol edin.Eğer içermiyorsa kenarı ağaca ekleyin. adımı işlem tamamlanana kadar devam ettirin. Minimum spanning tree (V-1) adet kenar içerecektir. Çevrim oluşturmak ne demektir? Eğer başladığınız bir noktadan dönüp dolaşıp ağaç üzerinde tekrar aynı noktaya gelebiliyorsanız çevrim oluşmuş demektir. Çevrim olup olmadığının anlanması özel bir konudur. Bununla ilgili yazılarımı ilerleyen zamanlarda yazacağım. Union-Find algoritması kullanılır.Mantık olarak çok basittir. Çözüm aşağıdaki gibi olur parent = dict() rank = dict() def make_set(vertice): parent[vertice] = vertice rank[vertice] = 0 def find(vertice): if parent[vertice] != vertice: parent[vertice] = find(parent[vertice]) return parent[vertice] def union(vertice1, vertice2): root1 = find(vertice1) root2 = find(vertice2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 else: parent[root1] = root2 if rank[root1] == rank[root2]: rank[root2] += 1 def get_sorted_edges(graph): 'Kenarları elde edelim' edges = [] for src in graph: for dest in graph[src]: edges.append(tuple(src) + dest) return sorted(edges, key=lambda x: x[2]) def print_kruskal(graph): for vertex in graph: make_set(vertex) sorted_edges = get_sorted_edges(graph) for edge in sorted_edges: v1, v2, w = edge if find(v1) != find(v2): union(v1, v2) print(edge) # sonuc if __name__ == '__main__': \"\"\" 10 0--------1 | \\ | 6| 5\\ |15 | \\ | 2--------3 4 Vertices = 0,1,2,3 \"\"\" graph = {\"0\": [(\"1\", 10), (\"2\", 6), (\"3\", 5)], \"1\": [(\"3\", 15)], \"2\": [(\"3\", 4)], \"3\": []} print_kruskal(graph) Bu algoritmanın zaman karmaşası O(ElogE) veya O(ElogV) olur.","title":"Kruskal Algoritması - Greedy Yaklaşımı","loc":"http://koseburak.net/blog/kuruskal-mst/"},{"tags":"Algoritma","text":"Text işlemlerinde, bir dizgi içerisinde dizgi aramadaki en basit çözümü inceleyeceğiz. txt[] = \"THIS IS A TEST TEXT\" pat[] = \"TEST\" Output: 10 txt[] = \"AABAACAADAABAAABAA\" pat[] = \"AABA\" Output: 0,9,13 Çözüm aşağıdaki gibi olacaktır. def search(text, pattern): m, n = len(pattern), len(text) for i in range(n - m + 1): for j in range(m): if text[i + j] != pattern[j]: break if j + 1 == m: print(i) if __name__ == '__main__': txt = \"AABAACAADAABAAABAA\" pat = \"AABA\" search(txt, pat) En iyi durum nedir? txt[] = \"AABCCAADDEE\" pat[] = \"FAA\" Desenin ilk karakteri arana text içerisinde bulunmadığı zamandır ve karmaşıklık O(n) olur. En kötü durum nedir? txt[] = \"AAAAAAAAAAAAAAAAAA\" pat[] = \"AAAAA\" Yani tüm karakterler aynı olduğunda ve txt[] = \"AAAAAAAAAAAAAAAAAB\" pat[] = \"AAAAB\" son karakterler aynı olursa. Bu durumda da karmaşıklık O(m*(n-m+1)) olur. String arama işlemlerinin önemli olduğunu söylemiştim. Bu gördüğünüz algoritma adı üstünde en kaba,basit çözümdür. Çok daha efektif algoritmalar bulunmaktadır.","title":"En basit hali ile text arama işlemi - String Algoritmaları","loc":"http://koseburak.net/blog/naive-search-string/"},{"tags":"Algoritma","text":"İş planlanması ile ilgili olan bir problem. Girdi olarak son teslim tarihine ve kazanç bilgilerine sahip olan işler veriliyor. En büyük kazancı nasıl elde edebileceğimizi bulmamız gerekiyor. Örnek olarak ; Input : JobID Son Tarih Kazanç a 4 20 b 1 10 c 1 40 d 1 30 Output : c , a Input : JobID Son Tarih Kazanç a 2 100 b 1 19 c 2 27 d 1 25 e 3 15 Output : c , a , e Greedy yaklaşımı ile şu şekilde çözebiliriz. Tüm işleri azalan kazanç oranlarına göre sırala İlk iş başlangıcın olsun Geriye kalan n-1 iş için Eğer şuanki iş zaman aşımına uğramadan sonuç listesine sığabiliyorsa elindeki işi sonuç dizisine ekle, aksi halde şuanki işi es geç. Çözüm aşağıdaki gibi olacaktır. def print_job_scheduling(jobs): jobs.sort(key=lambda x: x[2], reverse=True) result, slot = [None] * len(jobs), [False] * len(jobs) for job in jobs: j = min(len(jobs), job[1]) - 1 while j >= 0: if not slot[j]: result[j] = job[0] slot[j] = True break j -= 1 print(result, sep='\\n') if __name__ == '__main__': # (id,zaman aşımı,kazanç) jobs = [('a', 2, 100), ('b', 1, 19), ('c', 2, 27), ('d', 1, 25), ('e', 3, 15)] print_job_scheduling(jobs) Bu algoritmanın zaman karmaşıklığı O(n&#94;2) olacaktır.Union-find veri yapısı kullanılarak O(n) gibi bir karmaşıklıkta çözülebilir.","title":"İş planlama problemi - Greedy Yaklaşımı","loc":"http://koseburak.net/blog/is-planlama/"},{"tags":"Algoritma","text":"Etkinlik paylaşım problemi klasik bir açgözlü(greedy) yaklaşımı ile çözülen bir problemdir.Greedy kısaca parça parça çözüme ulaşılan ve her bir aşamada o anki en optimum seçeneği seçemedir. Eğer bir problemi Greedy yaklaşımı ile çözebiliyorsak muhtemelen o problemin çözümü diğer çözüm yöntemlerine göre en optimum çözüm olacaktır fakat her durumda uygulanamaz. Şimdi probleme gelelim, size n adet aktivite ve her aktivitenin başlangıç ve bitiş süreleri veriliyor.Sizden tek bir kişinin yapabileceği en fazla sayıda aktivite gerçekleştirmesi isteniyor. Örneğin; etkinlikler = 0 1 2 3 4 5 - - - - - - - - - - - - başlangıç[] = {1, 3, 0, 5, 8, 5}; bitiş[] = {2, 4, 6, 7, 9, 9}; Cevap = {0,1,3,4} İlk bitecek aktiviteleri aradan çıkarırsak sonuca ulaşabiliriz.Bunun için yapılması gerekenler; Aktiviteleri bitiş zamanlarına göre sıralamalıyız Sıralanmış aktivitelerden ilkini almalıyız. Geriye kalan aktivitelerin başlangıç zamanı ile seçilen aktivitenin bitiş zamanı karşılaştırılmalı Çözüme ait kod aşağıdaki gibi olur. def print_max_activities(activities): choise,activities = activities[0],activities[1:] print(choise) for i in activities: if i[0] >= choise[1]: choise = i print(choise) if __name__ == '__main__': #[(start,finish)] activities = [(1,2),(3,4),(0,6),(5,7),(8,9),(5,9)] activities.sort(key=lambda x : x[1]) #Bitişe göre sıralama print_max_activities(activities)","title":"Etkinlik paylaşım problemi - Greedy Yaklaşımı","loc":"http://koseburak.net/blog/etkinlik-secim-problemi/"},{"tags":"Algoritma","text":"Üs alma işlemi kullanılan programlama dilinin standart olarak verdiği işlemler ile gayet kolay olarak yapılabilen bir işlemdir.En basit hali ile çözüm şu şekildedir. def brute(num, x): result = 1 for i in range(x): result *= num return result Bu çözüm iteratif olarak yazılmış ve O(n) karmaşıklığına sahip hoş olmayan bir çözümdür. Şimdi bu çözümü Divide and Conquer mantığına uygun bir çözüm ile yazalım. def div_conq(num, x): if x == 0: return 1 elif x % 2 == 0: return div_conq(num, x / 2) * div_conq(num, x / 2) else return num * div_conq(num, x / 2) * div_conq(num, x / 2) Çözümü divide and conquer mantığına göre çözsekte karmaşıklıkta hala değişiklik olmadı ve zaman karmaşıklığımız O(n) . Biraz dikkat ederseniz gereksiz tekrarlar olduğunu fark edebilirsiniz. Bunları önlemek için aşağıdaki gibi bir yol izleyebiliriz. def div_conq(num, x): if x == 0: return 1 temp = div_conq(num, x / 2) if x % 2 == 0: return temp * temp else: return num * temp * temp Artık karmaşıklığımız O(logn) olmuştur. Fakat yazdığımız kod negatif sayısal için çalışmayacaktır. Ufak bir ekleme ile şu hale getirebilriz. def div_conq(num, x): if x == 0: return 1 temp = div_conq(num, x / 2) if x % 2 == 0: return temp * temp else: if(x > 0): return num*temp*temp; else: return (temp*temp)/num;","title":"Üs alma işlemi (a&#94;x) - Divide and Conquer","loc":"http://koseburak.net/blog/pow-daq/"},{"tags":"Algoritma","text":"Ufak bir işlem sonrası sıralanmış dizinin bazı elemanlarının yerleri karıştırılıyor. Örneğin i. pozisyonda olması gereken eleman i-1 ya da i+1 pozisyonunda bulunuyor. Hedef olarak verilen sayının dizi içerisindeki pozisyonunun bulunması amaçlanıyor. Örneğin; Input : arr [] = { 10 , 3 , 40 , 20 , 50 , 80 , 70 }, key = 40 Output : 2 Input : arr [] = { 10 , 3 , 40 , 20 , 50 , 80 , 70 }, key = 90 Output : - 1 Klasik olarak en ilkel çözüm, tüm diziyi boydan boya aramaktır. O(n) karmaşıklığa sahiptir. Bu çözümde ise sıralı diziler üzerinde uygulanan algoritmalardan olan binary search algoritmasının biraz daha modifiye edilmiş halini kullanacağız. Fikir olarak şuna dayanmaktadır; elimizdeki değeri ortandaki üç eleman ile karşılaştıracağız. Geri mantık binary search algoritması gibidir. Çözüm aşağıdadır. def mod_binary_search(arr, l, r, x): '''Modifiye edilmiş binary search''' if r >= l: mid = l + (r - l) // 2 # orta 3 eleman ile karşılaştırma if arr[mid] == x: return mid if mid > l and arr[mid - 1] == x: return mid - 1 if mid < r and arr[mid + 1]: return mid + 1 # Eğer eleman ortancadan küçükse, sola doğru kaydır if arr[mid] > x: return mod_binary_search(arr, l, mid - 2, x) # Aksi halde sağa doğru kaydır return mod_binary_search(arr, mid + 2, r, x) # Bulunamadı return -1 if __name__ == '__main__': arr = [3, 2, 10, 4, 40] target = 4 result = mod_binary_search(arr, 0, len(arr) - 1, target) if result != -1: print(result) else: print(\"bulunamadi\") Algoritmanın karmaşıklığı O(logn) olur.","title":"Neredeyse sıralı dizi içerisinde arama - Arama Algoritması","loc":"http://koseburak.net/blog/almost-sorted-search/"},{"tags":"Algoritma","text":"String olarak verilen sayının bir sonraki büyük saıyı ekrana bastıran, eğer şartlar uygun değilse imkansız yazan problemi inceleyeceğiz. Input : n = \"218765\" Output : \"251678\" Input : n = \"1234\" Output : \"1243\" Input : n = \"4321\" Output : \"Imkansız\" Input : n = \"534976\" Output : \"536479\" Çözüm için; Eğer tüm sayılar azalan sırada ise 'Imkansız' basılır. Eğer tüm sayılar artan sırada ise son iki sayı ver değiştirecektir. Diğer sayılar için Sayının birler basamağından başlanarak diğer haneleri incelenir. Birber basamağından daha değerli basamaklara doğru artışı bozacak hane aranır. Örneğin \"534976\" sayısı için 4 olan basamak bu durumu sağlar.(6<7<9) Sayı 53,4,976 şeklinde bölünür ve 4'ün sağ tarafında kalan sayılardan 4'den büyük olan en küçük sayı bulunur(6'dır). 4 ve 6 yer değişir(\"53,6,974\" olur). \"974\" olan kısım sıralanır ve son olarak cevap \"536479\" olur. Çözüm aşağıdaki gibi olacaktır. def find_next(num): for i in range(len(num) - 1, 0, -1): if num[i] > num[i - 1]: break if i - 1 == 0: print(\"Imkansiz\") return x, smallest = num[i - 1], i for j in range(i + 1, len(num)): if num[j] > x and num[j] < num[smallest]: smallest = j num = list(num) num[smallest], num[i - 1] = num[i - 1], num[smallest] num[i:] = sorted(num[i:]) print(''.join(num)) if __name__ == '__main__': find_next(\"534976\") find_next(\"4321\")","title":"Girilen sayıdan bir sonraki büyük sayıyı bulma - Matematik Problemi","loc":"http://koseburak.net/blog/next-num/"},{"tags":"Algoritma","text":"Bir diğer string arama algoritmalarından olan KMP algoritmasına bakacağız. Örnek olarak; txt = \"THIS IS A TEST TEXT\" pat = \"TEST\" Output : 10 ve txt = \"AABAACAADAABAAABAA\" pat = \"AABA\" Output : 0, 9, 13 Bir önceki yazıda en kaba hali ile bir text içerisinde nasıl başka bir text aramasının yapılacağını incelemiştik. O algoritma O(m*(n-m+1)) karmaşıklığa sahipti. Bu algoritmanın en kötü durumda karmaşıklığı O(n) 'dir. KMP (Knuth Morris Pratt) Kısaca yapılan iş şu şekilde yürümektedir. Ne zaman bir eşleşmeme duruöu olursa, elimizde daha önce elde ettiğimiz bilgileri kullanarak, deseni kaydırma ve benzetme işlemi yaparız. Dolayısı ile gereksiz karşılaştırmadan kaçtığımız için zaman karmaşıklığından kazanmış oluruz. LPS için aşağıdaki örnelere bakın. \"AABAACAABAA\", lps = [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5] \"ABCDE\", lps = [0, 0, 0, 0, 0] \"AAAAA\", lps = [0, 1, 2, 3, 4] \"AAABAAA\", lps = [0, 1, 2, 0, 1, 2, 3] \"AAACAAAAAC\", lps = [0, 1, 2, 0, 1, 2, 3, 3, 3, 4] İşleyiş aşağıdaki kod ile daha iyi anlaşılacaktır. def KMP_search(text, pattern): lps = compute_lps_array(pattern) m, n, j = len(pattern), len(text), 0 i = 0 # text indeksi while i < n: if pattern[j] == text[i]: i, j = i + 1, j + 1 if j == m: print(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: # j eşleşme sonrası eşleşmeme if j != 0: j = lps[j - 1] else: i += 1 def compute_lps_array(pattern): lps = [0] * len(pattern) # len_sp = son en uzun prefix suffix uzunluğu len_sp, i, len_pattern = 0, 1, len(pattern) while i < len_pattern: if pattern[i] == pattern[len_sp]: len_sp += 1 lps[i] = len_sp i += 1 elif len_sp != 0: len_sp = lps[len_sp - 1] else: # len_sp == 0 lps[i] = 0 i += 1 return lps if __name__ == '__main__': text = \"ABABDABACDABABCABAB\" pattern = \"ABABCABAB\" KMP_search(text, pattern)","title":"KMP Algoritmasi - String Algoritmaları","loc":"http://koseburak.net/blog/kmp/"},{"tags":"Algoritma","text":"Sıralı olarak verilen bir dizi içerisinde, hedef olarak belirtilen sayıya en yakın(eşit değil) k tane elemanı elde etmeye yarayan problemdir. Problemin basit olarak çözümü, k tane elemanın bulunması için diziyi lineer olarak aramaktan geçer. İlk elemandan başlayarak geçit alanına kadar gel(Geçit alanı: Sonraki elemanın büyük, üzerinde bulunan elemanın küçük veya eşit olduğu nokta). Karmaşıklık O(n)'dir. adımda bulunan noktanın her iki tarafını karşılaştırarak ekrana k tane eleman ver. Bu adım da O(k) zaman alır. Genel olarak bu çözüm O(n) zaman alır. Şimdi daha optimize ve O(logn + k) zaman alan bir çözümü inceleyelim. Bu çözüm aslında yukarıdaki çözüme benziyor fakat geçit bölgesini binary search algoritması ile buluyoruz(Dizi sıralı çünkü). Çözüm aşağıdaki gibidir. def find_cross_point(arr, low, high, x): # x tüm elemanlardan büyükse if arr[high] <= x: return high # x tüm elemanlardan küçükse if arr[low] > x: return low # Orta noktayı bulma mid = (low + high) // 2 # X ortanca elemansa if arr[mid] <= x and arr[mid + 1] > x: return mid # x < arr[mid] ve x < arr[mid+1] ise if arr[mid] < x: return find_cross_point(arr, mid + 1, high, x) return find_cross_point(arr, low, mid - 1, x) def print_closest(arr, x, k): l = find_cross_point(arr, 0, len(arr) - 1, x) r, count = l + 1, 0 # Eşit elemanları dikkate alma if arr[l] == x: l -= 1 # Geçiş noktasından itibare sağ ve sol kontrolu while l >= 0 and r < len(arr) and count < k: if x - arr[l] < arr[r] - x: print(arr[l]) l -= 1 else: print(arr[r]) r += 1 count += 1 # Sağ tarafta hiç eleman yoksa sol tarafı yazdır while count < k and l >= 0: print(arr[l]) l, count = l - 1, count + 1 # Sol tarafta hiç eleman yoksa sağ tarafı yazdır while count < k and r < len(arr): print(arr[r]) r, count = r + 1, count + 1 if __name__ == '__main__': arr = [12, 16, 22, 30, 35, 39, 42, 45, 48, 50, 53, 55, 56] target, k = 35, 4 print_closest(arr, target, k)","title":"Sıralı dizi içerisinde hedef sayıya en yakın k sayı - Arama Algoritması","loc":"http://koseburak.net/blog/search-k-closest/"},{"tags":"Algoritma","text":"Hafızaya yazma işlemini azaltmak, büyük veri kümeeleri üzerinde uğraşmanın maliyetli olduğu EEPROMs ve ya flash gibi platformlar için kazançlıdır. Sıralama algoritmaları arasında Selection Sort agoritmasının en az sayıda yazma işlemi yaptığını( O(n) ) biliyoruz. Fakat Cycle Sort neredeyse her zaman Selection Sort algoritmasına göre daha az sayıda yazma işlemi yapar. Eğer değer doğru noktada ise, o değer için hiç yazma işlemi yapılmaz ve eğer değer doğru noktada değilse bir kez yazma işlemi yapılarak doğru noktaya getirilir.","title":"Hangi sıralama algoritması belleğe en az sayıda yazma yapar?","loc":"http://koseburak.net/blog/which-sorting-min-memory/"},{"tags":"Algoritma","text":"Bir dizi ve k sayısı veriliyor(k < len(dizi)). Cevap olarak dizi içerisinde ki k. küçük veya büyük elemanın bulunması hedefleniyor. Örneğin; Input : arr [] = { 7 , 10 , 4 , 3 , 20 , 15 } k = 3 Output : 7 Input : arr [] = { 7 , 10 , 4 , 3 , 20 , 15 } k = 4 Output : 10 Çözüm 1 (Basit Çözüm) Akla gelen en basit çözm elimizdeki veri kümesini ihtiyaca göre sıralamak ve k. indeksi çağırmak. Sıralama için kullanılacak en verimli algoritma ortalama O(nlogn) zaman alacağı için karmaşıklık O(nlogn) olacaktır. Çözüm 2 (Min Heap – HeapSelect) Bu problemi O(nlogn) zaman karma1şıklığından daha iyi bir şekilde çözebiliriz. Kullanacağımız algoritma, heap veri yapısı yardımı ile sonuca ulaşacaktır. Çözüm aşağıdaki gibidir. class MinHeap: def __init__ ( self , arr ): self . harr = arr self . heap_size = len ( arr ) i = ( self . heap_size - 1 ) // 2 while i >= 0 : self . min_heapify ( i ) i -= 1 def min_heapify ( self , i ): l , r , smallest = self . left ( i ), self . right ( i ), i if l < self . heap_size and self . harr [ l ] < self . harr [ i ]: smallest = l if r < self . heap_size and self . harr [ r ] < self . harr [ smallest ]: smallest = r if smallest != i: self . harr [ i ], self . harr [ smallest ] = self . harr [ smallest ], self . harr [ i ] self . min_heapify ( smallest ) def extract_min ( self ): if not self . heap_size: return - 1 root = self . harr [ 0 ] if self . heap_size > 1 : self . harr [ 0 ] = self . harr [ self . heap_size - 1 ] self . min_heapify ( 0 ) self . heap_size -= 1 return root def left ( self , i ): return 2 * i + 1 def right ( self , i ): return 2 * i + 2 def paremt ( self , i ): return ( i - 1 ) // 2 def kth_smallest ( arr , k ): heap = MinHeap ( arr ) for i in range ( k - 1 ): heap . extract_min () return heap . harr [ 0 ] if __name__ == '__main__' : arr = [ 12 , 3 , 5 , 7 , 19 ] print ( kth_smallest ( arr , 2 )) Bu algoritmanın karmaşıklığı O(n+klogn) olacakır. Çözüm 3 (Max-Heap) Çözüm 2'deki gibi, bu sefer max-heap ile problemi çözebiliriz.Karmaşıklık O(k + (n-k)*logk) olacaktır. class MaxHeap: def __init__ ( self , arr ): self . harr = arr self . heap_size = len ( arr ) i = ( self . heap_size - 1 ) // 2 while i >= 0 : self . max_heapify ( i ) i -= 1 def max_heapify ( self , i ): l , r , largest = self . left ( i ), self . right ( i ), i if l < self . heap_size and self . harr [ l ] > self . harr [ i ]: largest = l if r < self . heap_size and self . harr [ r ] > self . harr [ largest ]: largest = r if largest != i: self . harr [ i ], self . harr [ largest ] = self . harr [ largest ], self . harr [ i ] self . max_heapify ( largest ) def extract_max ( self ): if not self . heap_size: return - 1 root = self . harr [ 0 ] if self . heap_size > 1 : self . harr [ 0 ] = self . harr [ self . heap_size - 1 ] self . max_heapify ( 0 ) self . heap_size -= 1 return root def left ( self , i ): return 2 * i + 1 def right ( self , i ): return 2 * i + 2 def paremt ( self , i ): return ( i - 1 ) // 2 def kth_smallest ( arr , k ): heap = MaxHeap ( arr ) for i in range ( len ( arr ) - k ): heap . extract_max () return heap . harr [ 0 ] if __name__ == '__main__' : arr = [ 12 , 3 , 5 , 7 , 19 ] print ( kth_smallest ( arr , 2 )) Çözüm 4 (QuickSelect) Bu çözüm, çözüm 1 de bahsedilen yöntemin optimize edilmiş halini yansıtmaktadır.Quick sort algoritmasının modifiye edilmesi ile elde edilmiştir. Pivot eleman seçeceğiz, bunu doğru pozisyona yerleştireceğiz ve etrafını parçalayacaız. En kötü durumda karmaşıklık O(n&#94;2) , fakat ortalama durumda O(n) olacaktır. from math import inf def kth_smallest ( arr , l , r , k ): if k > 0 and k <= r - l + 1 : pos = partition ( arr , l , r ) if pos - l == k - 1 : return arr [ pos ] if pos - l > k - 1 : return kth_smallest ( arr , l , pos - 1 , k ) return kth_smallest ( arr , pos + 1 , r , k - pos + l - 1 ) return inf def partition ( arr , l , r ): x , i = arr [ r ], l for j in range ( l , r ): if arr [ i ] <= x : arr [ i ], arr [ j ] = arr [ j ], arr [ i ] i += 1 arr [ i ], arr [ r ] = arr [ r ], arr [ i ] return i if __name__ == '__main__' : arr = [ 12 , 3 , 5 , 7 , 4 , 19 , 26 ] print ( kth_smallest ( arr , 0 , len ( arr ) - 1 , 3 ))","title":"K. küçük veya büyük sayısı bulmak - Part 1 - Arama Algoritması","loc":"http://koseburak.net/blog/search-k-largest-or-smalest/"},{"tags":"Algoritma","text":"Sıralama algoritmalarında bazen kararlılık ile ilgili bir takım bilgiler görürüz.Kısaca açıklamak gerekirse, sırarısz bir dizide aynı değerlere sahip elemanların dizilişi, dizi sıralandığında da korunuyorsa algoritma kararlıdır. Kararlı özelliğine sahip algoritmalar; Insertion sort, Merge sort, Bubble sort. Kararsız olanlar; Heap sort, Quick sort. Ancak verilen kararlı olmayan aloritmalar kolayca kararlı hale getirelebilirler.","title":"Sıralama algoritmalarında kararlılık nedir?","loc":"http://koseburak.net/blog/stability-sorting/"},{"tags":"Algoritma","text":"Quick sort ortalama zamanda çalıştığında en verimli çalışan ve en çok kullanılan algoritmalardan biridir. Pivot seçiminin ne kadar önemli olduğunu algoritmayı incelediğinizde göreceksiniz. En kötü duruma sebebiyet veren şartlar aşağıdadır. Dizi zaten aynı yönde sıralıysa. Dizi ters yönde sıralıysa. Tüm elemanlar aynıysa","title":"Quick sort için en kötü durum nedir?","loc":"http://koseburak.net/blog/worstcase-quicksort/"},{"tags":"Big Data","text":"Apache Spark,büyük veri işleme amacı ile oluşturulmuş bir Apache projesidir.Scala dili ile yazılmış JVM üzerinde çalışan ve Python, Java, Scala kullanımına olanak sağlayan, \"in-memory\" yani veriyi bellek içerisinde işleme özelliği ile ön plana çıkan bir projedir. Eğer isterseniz kaynak kodları görüntülemek için aşağıdaki adrese göz atabilirsiniz. https://github.com/apache/spark Kurulum http://spark.apache.org/downloads.html adresinden \"Pre-built for Hadoop 2.6 and later\" seçeneği seçilerek son sürümünü indirebilirsiniz.İndirme tamamlandıktan sonra indirilen yere geçirelerek, tar -xzvf spark-1.4.0-bin-hadoop2.6.tgz cd spark-1.4.0-bin-hadoop2.6 ls komutları yürütülür.Son komuttan sonra sergilenen dosyaları kısaca şu şekilde açıklayabiliriz. README.md Spark ile ilgili kısa açıklamalar ve hızlı başlangıç bin Çalıştırılabilir dosyalar(shell gibi) core,streaming,Python.. Spark projesinin kaynak kodları examples Örnekler Tanıtım Yazının devamında Spark'ı yerel modda çalıştırarak kısa bir kaç örnek yapalım.Ben Python kullanıyor olacağım eğer siz tercih ederseniz Scala veya Java kullanabilirsiniz fakat Java hakkında bahsetmek istediğim bir nokta var eğer Java 8 ile birlikte gelen özellikleri kullanmazsanız nispeten biraz okuması zor bir kod çıkabilir ortaya fakat performanstan bir kaybınız olmaz. İnteraktif Python Shell ./bin/pyspark İnteraktif Scala Shell ./bin/spark-shell Python shell için yukarıdaki komutu çalıştırdıktan sonra şu şekilde bir görüntü elde ediyorum. Eğer konsola düşen \"INFO\" loglarını gizlemek isterseniz.Şunu yapabilirsiniz. \"conf/log4j.properties.template\" dosyasının bir kopyasını alın ve \"conf/log4j.properties\" ismini verin.Daha sonra bu kopya dosya içerisindeki \"log4j.rootCategory=INFO, console\" satırını \"log4j.rootCategory=WARN, console\" ile değiştirin.Artık INFO loglarını görmeyeceksiniz. Devam edelim,interaktif Python Shell açtıktan sonra >>> lines = sc.textFile(\"README.md\") >>> type(lines) <class 'pyspark.rdd.RDD'> >>> lines.count() 98 >>> lines.first() '# Apache Spark' gibi bir örnek ile test edelim.Yukarıdada göreceğiniz gibi lines adı ile kullandığımız değişkten bir RDD objesidir ve yerel makinemizde bulunan bir text dosyasından oluşturulmuştur.RDD hakkında ileriki yazılarımda daha fazla detay vereceğim. Yukarıdaki örnekte birde sc objesi kullandık.Bu obje sayesinde Spark ile iletişim kurulur. >>> sc <pyspark.context.SparkContext object at 0x7f9b3e856e48> Spark aşağıdaki görseldeki gibi çalışır. Şimdi de bu uygulamamızda filter kullanarak içerisinde \"Python\" geçen satırları veren bir örnek yapalım. >>> lines = sc.textFile(\"README.md\") >>> pythonLines = lines.filter(lambda line : 'Python' in line) >>> type(pythonLines) <class 'pyspark.rdd.PipelinedRDD'> >>> pythonLines.count() 3 >>> pythonLines.first() 'high-level APIs in Scala, Java, and Python, and an optimized engine that' Gibi bir çıktı alırız.Eğer Python'da lambda fonksiyonlara alışık değilseniz ya da kullanmak istemezseniz yukarıda kullandığımız filter() methoduna kendi oluşturduğunuz methodu da aktarabilirsiniz.Örnek; >>> def hasPython(line): ... return 'Python' in line ... >>> pythonLines = lines.filter(hasPython) gibi bir kullanım geçerleyebilirsiniz. İnteraktif shell kullanışlı olsa da her zaman kullanamayız.Bazen bağımsız uygulamalar yazmamız gerekmektedir.Yazılan kodları yürütmek için indirdiğimiz Spark klasöründeyken ./bin/pyspark benim_script.py komutunu yürütmek zorundayız.Bunun yerine aşağıdaki yolları izleyerek işimizi biraz daha kolaylaştıralım. cd ~ nano .bashrc ve aşağıdaki satırları düzenleyip dosyamıza ekleyelim. export SPARK_HOME= 'Spark dosyası uzantısı' export PYTHONPATH=$SPARK_HOME/python/:$PYTHONPATH . .bashrc PySpark'ın py4j adlı pakete bağımlılığı vardır.Bu paket Python yorumlayıcısının dinamik bir şekilde Spark ile haberleşmesini sağlar. pip install py4j Yazdığımız kodları artık ./bin/spark-submit <python_file.py> yerine direk olarak python <python_file.py> şeklinde çalıştırabileceğiz. Bundan sonra kod yazarken yapmamız gereken tek şey SparkContext objemizi oluşturmaktır,geri kalan kısımlar aynıdır. Yazımın başında Python kullandığımı söylemiştim fakat siz Scala veya Java kullanıyorsanuz bağımsız uygulamalar yazarken Maven kullanmanızı öneririm.Maven kullanımı ile ilgili resmi dökümanlara bakarak yardım alabilirsiniz. Yazılan uygulamanın Spark ile iletişim kurabilmesi için Spark paketlerini dahil etmeli ve SparkContext nesnesini yaratmalıyız. from pyspark import SparkConf , SparkContext conf = SparkConf () . setMaster ( \"local\" ) . setAppName ( \"My App\" ) sc = SparkContext ( conf = conf ) Yazdığımız script'i python benim_script.py şeklinde çalıştırabilirsiniz. Bu örnek ile basit olarak SparkContext oluşturmayı gördük.Aktarılan iki parametre sırası ile; Cluster URL , bu örnekte \"local\" olmasının sebebi Spark'ı tek bir makinede ve tek bir thread üzerinde çalıştırdığımız içindir. Uygulama ismi Bu parametreler dışında parametreler bulunmaktadır,ileride daha ayrıntılı inceliyor olacağız. Eğer uygulamayı sonlandırmak isterseniz SparkContext objesi üzerinden stop() methodunu çağırabilir veya alışık olduğumuz sys.exit() kullanabilirsiniz. Bu kadar kargaşadan sonra sıra \"Hello World\" uygulamamıza geldi.Bu alanın \"Hello World\" uygulaması \"Word Count\" olarak geçer.Basit bir word count uygulaması yazalım. from operator import add from pyspark import SparkContext if __name__ == \"__main__\" : sc = SparkContext ( appName = \"WordCount\" ) lines = sc . textFile ( 'README.md' ) counts = lines . flatMap ( lambda x : x . split ( ' ' )) \\ . map ( lambda x : ( x , 1 )) \\ . reduceByKey ( add ) output = counts . collect () for ( word , count ) in output : print ( \" %s : %i \" % ( word , count )) sc . stop () Kod içerisinde yabancı gelen terimleri bir sonraki yazılarda daha ayrıntılı bir biçimde inceliyor olacağız. BURAK KÖSE","title":"Apache Spark - Part 1 : Tanıtım","loc":"http://koseburak.net/blog/apache-spark-part1/"},{"tags":"Algoritma","text":"Rastgele yani tesadüfen , tesadüfi olarak , ayırmadan , seçmeden anlamındadır.Çoğumuz yazdığımız kodu test ederken , oyun programlarken ve çişitli hesaplamarda kullanırız rastgele sayıları.Günlük hayatta rastgele kavramı insalar için keyfi olarak kullanılır.Aklınızdan bir sayı tutup söylersiniz bu bir rastgele işlemidir.Peki gerçekten böylemidir,bilgisayarlar için de durum bu mudur? Hep verilen bir örnek vardır , zar.Zar atma olayı rastgele midir ? Bize göre evet fakat matematikte durum böyle değildir.Zarın hangi sayı gelmesi bir çok etkene bağlıdır.Bunlar sürtünme,ağırlık,yerçekimi,hız vs gibi.Dolayısı ile gelecek sayının ne olduğu kestirilemediği için rastgele denilir. Biraz daha zorlayalım , mesela aklınzdan bir sayı tutup söyleme gerçekten de rastgele midir ? Değildir. Çok hızlı karar verdiğimiz için nasıl seçtiğimizi pek anlayamayız.Aslında bizim söyleyeceğimiz sayınında etkenleri vardır.Örneğin favori sayımız , söylenecek sayının sınırlandırılması gibi. Uygulamamızda rastgele sayı elde etmek için çeşitli kütüphaneler , metodlar bulunur.Peki bunlar nasıl rastgele sayı üretiyorlar.Şimdi bir kaç rastgele sayı üretme algoritmasına bakalım. 1# Orta kare yöntemi ( 4r ) Bu algoritma John von Neumann ve ekip arkadaşları tarafından ortaya atılmıştır.Kabaca şu şekilde gerçekleşir. 1- 4r basamaklı bir sayı seçilir.'r' bir tamsayıdır. 2- Sayının sağdan ve soldan 'r' adet basamağı silinir. 3- Geriye kalan '2r' basamaklı sayının karesi bulunur fakat 'r' sayısının tamsayı olması gerektiğini unutmayın.Kare alma işleminden sonra elimizde tekrar 4r basamaklı bir sayı bulunur. 4- Tekrar yeni bir sayı üretilmek istenirse 2. adıma geri dönülür. Bir örnek verelim.Sayımız 81.599.441 olsun.Tamamen salladığım bir sayı.8 basamaklıdır dolayısı ile r = 2 olur.Soldan ve sağdan r = 2 adet sayı silelim.Yeni sayı 5994 olacaktır.Peki devam edelim 5994\\&#94;2 = 35.928.036 olur ve takrar r adet sayı soldan ve sağdan silelim.Yeni sayı 9280 olur.Devam etmek istersek bu böyle devam edecektir.Sayılar soldan parçalanarak 2 basamaklı rastgele sayılar elde edilir.Örneğin 2 basamaklı rastgele sayılar için kümemiz {81,35} olurken üç basamaklı sayılar için {815,359} olur. Görüldüğü gibi çok pratik olmayan bir yöntemdim ve bazı soruları vardır.Örneğin başlangıçta alınan 2500 sayısı için 50\\&#94;2 = 2500 elde edilir ve bir çıkmaza girilir . 2 # Lineer Benzerlik Algoritması Daha önce C kullanmış olanlar bu algoritma onlara tanıdık gelecektir ve ilk kez rastgele sayı oluşturan kişilerin genelde bunlar aynı sayılar şeklinde devam ediyor , bu problem nedir dedikleri olmuştur(En azından ben bu soruyu sormuştum). D.H Lehmer tarafından geliştirilmiş rastgele sayı üretme algoritmasıdır.İlk olarak s,c,b değişkenleri belirlenir. 's' başlangıç noktası 'c' çarpım için 'b' artış için 'm' ise mod işlemi için belirlenen bir değerdir Algoritma şu şekilde işler.İlk olarak başlangıç noktası(s) çarpım için belirlenmiş olan(c) ile çarpılır ve 'b' ile toplanır ve sonuç mod işlemine alınır(m),ilk rastgele sayı üretilir.Bu işlem üretilen rastgele sayının tekrar 'c' ile çarpılıp 'b' ile toplanıp 'm' ile modunu alınması şeklinde devam eder.Örnek; s = 10 c = 2 b = 1 m = 5 (Dikkat maksimum sayı 4 olabilir anlamına gelir) 1.Adım: (s*c + b ) % m yani (10 * 2 + 1) % 5 = 1 olacaktır ve yeni s = 1 2.Adım: (1 * 2 + 1) % 5 = 3 olacaktır ve yeni s = 3 3.Adım: (3 * 2 + 1) % 5 = 2 olacaktır ve yeni s = 2 gibi işlemler devam edecektir.3 adımda 3 adet sayı ürettik bunlar {1,3,2}'dir.Gerçek sayı üretme işlemlerinde bu değerler bu kadar küçük seçilmezler. D.E Knuth ve H.W. Lewis tarafından önerilen değerler ise; c = 1664525 b = 1013904226 m = 2 \\&#94; 32 Detaylı bilgi için bakın. Şimdi gelelim şu C'de yaşanılan probleme.Bilindiği gibi rand() fonksiyonu geriye bir rastgele sayı döndürür fakat geri döndürdüğü sayılar belli bir süre sonra tekrar ettiği görülür , hatırlarsınız orta karaler yönteminde de benzer bir çıkmaza giriliyordu.Yani başlangıç için belirlenen değer zamanla değiştirilmez.Bunun için srand() fonksiyonu kullanılır.Bu ise başlangıç değerini değiştirir. 3# 147 Algoritması İsimden anlaşılacağı gibi 147 sayısı kullanılarak sayı üretilir. 1.Adım : 0 \\< n \\< 1 aralığında bir '0,abcdefg' sayısı seçilir.Burada g = {1,3,7,9} olmak zorundadır. 2.Adım : s = n * 147 elde edilir. 3.Adım : s sayısından tam sayı kısmı çıkartılır. 4.Adım : 2. adıma geri dönülür. Bir örnek verelim.Örneğin n = 0,1234567 olsun. s = 0,1234567 * 147 = 18,1481349 olarak bulunur ve 3. adıma göre s = 18,1481349 - 18 = 0,1481349 olarak güncellendikten sonra işlemler tekrar edilir. 4# Engel Algoritması Bazen yeni bir formul ile karşılaştığımda genelde ilk tepkim bu insanlar bu hesaplamarı bulurken bu absurd sabitler nereden geliyor diye kendime soruyorum.Mesela 147 algoritmasında görüldüğü gibi neden 147 ? Bu algoritmada da bir basit kullanılıyor.Bu seferki sabitimiz 'π'(pi) ama işin ilginç yanı bu sabiti kullanmak zorunda değiliz.Sadece 1'e yakın bir sayı olmasın yeter. Rastgele sayı üretiminde tahmin edilebilirliğin çok düşük olması gerektiğinden bahsetmiştik.Bu algoritmada sayılarda ki değişiklikler belirsizdir. Algoritma için tanımlama 1.Adım : 0 \\<= n \\<= 1 koşulunu sağlayan bir sayı seçilir. 2.Adım : u = (n + π ) \\&#94; 8 elde edilir ve u'nun tam sayı kısmı atılır ve n = geriye kalan sayı olur. 3.Adım : 2.Adıma geri dönülür. Bir örnek verelim. n = 0 alalım. 1.Sayı için : u = (0 + π)\\&#94;8 = 9450,116981 elde edilir ve n = 9450,116981 - 9450 = 0,116981 olur. 2.Sayı için : u = (0,116981 + π)\\&#94;8 = 12662,5682884 elde edilir ve n = 0,5682884 olur. BURAK KÖSE","title":"Rastgele Sayı Üretmek","loc":"http://koseburak.net/blog/rastgele-sayi/"},{"tags":"Algoritma","text":"Biyoinformatik'de adı sıkça geçen algoritmalardan olan suffix tree veri yapısı bir dizgi model(pattern) eşleştirme algoritmasıdır.Örneğin elinizde uzun bir dizgi olsun ve siz bu dizgi içinde alt dizgiler aramak ve hatta bu dizgilerden kaç adet bulunduğunu öğrenmek istiyorsunuz.İşte bu veri yapısı bu işlemleri kolaylaştırmak ile birlikte gayet hızlı işlem yapmamıza olanak sağlıyor. Bu tip bir yöntem kullanmadan ilkel olarak çözüm olarak şunu yapabilirdik.Ana dizgi içerisinde lineer olarak sırayla karşılaştırma yapa yapa devam ederek sonuca ulaşabilirdik.Bu bir yöntemdir fakat dizgi boyutları arttıkça bu işlem çok maliyetli olmaktadır. Suffix tree incelemesi yapmadan önce suffix nedir bundan bahsedelim.Suffix Türkçe'de son ek olarak geçer ve bir dizginin son ekleri şu şekilde bulunur.Örnek: String = burak sonekler burak,urak,rak,ak,k olacaktır.Görüldüğü gibi n uzunluğunda bir dizgi n adet suffix sahibidir. Suffix tree oluşturmak için önce ihtiyacımız olan suffixleri bulmamız gerekmektedir.Yukarıdaki örnekteki gibi suffixler elde edildikten sonra bunlar uzunluklarına göre sıralanmalıdır.Örneğin String = xabxac için sonekler xabxac,abxac,bxac,xac,ac,c olarak elde edilikten sonra sırası ile 1,2,3,4,5,6 numaraları verilir.Ağaç şu şekilde oluşturulur.Bir başlangıç noktası vardır ve buradan dallanmalar yapılmaktadır.Önce 1 numara dallanır daha sonra gelen 2 numaraya ait dizgi ile ortak başlangıç noktaları varsa bu noktadan itibaren dallanma yapılır eğer yoksa yeni bir dallanma yapılır.Şimdi adım adım ağacımızı oluşturalım. #1.Adım İlk dallanmamızı 1 numaralı suffix ile yapıyoruz. #2.Adım 2 numaralı suffix olan \"abxac\"' için inceleme yapıldığında şuana kadar başlangıç noktasından itibaren \"a\" ile başlayan bir dallanma olmadığından yeni bir dallanma yapılır. #3.Adım 3 numaralı suffix \"bxac\"' için inceleme yapıldığında \"b\" ile başlayan bir dallanma olmadığından tekrar başlangıç noktamızdan yeni bir dallanma yapılır. #4.Adım 4 numaralı suffix \"xac\"' için inceleme yapıldığında bu noktada işin şekli değişmektedir.Ağaca baktığımızda başlangıç noktasından itibaren bir \"x\" ile başlangıç vardır.Hatta bir adım daha arama yaptığımızda sadece \"x\" ile değil devam edildiğinde \"xa\" ile bir başlangıç olan dallanma vardır(1 numaralı suffix).Dolayısı ile kesişme noktasından bir dallanma yapılır. #5.Adım 5 numaralı suffix \"ac\" için inceleme yapabilmek için tekrar root noktasından taramaya başlıyoruz ve ilk olarak \"a\" başlangıcı arıyoruz.Görüldüğü gibi en iyi kesişim 2 numaralı suffixtedir.Dolayısı ile bir kesişim noktası yapıp yeni bir dallanma yaratıyoruz. #6.Adım Ve son olarak sırada 6 numaralı suffix olan \"c\" için incelemede.Tek başına bir dallanma yapması gerektiği görülüyor. Ağaç oluşturulmuştur.Şimdi bir arama yapalım,örneğin \"xa\" , bu dizgi içinde geçiyor mu ve geçiyorsa kaç kere geçiyor sorusuna cevap arayalım. Ağaca bakmaya root noktasından başlayalım ve \"xa\" arayalım.Hemen root noktasının altında \"xa\" başlangıcı ile karşılaşıldı.Dolayısı ile \"xa\" eşlemesi sağlandı ama kaç tane \"xa\" olduğunu nereden anlayacağız?Kaç tane \"xa\" olduğunu bulunan noktanın altında kaç tane dallanma varsa o kadar \"xa\" vardır diyeceğiz.Baktığımızda iki adet dallanma olduğu görülmektedir. Peki \"bxa\" var mıdır ? Ağaçta aramaya tekrar root noktasından başlanır ve sırayla \"bxa\" aranır. evet \"bxa\" vardır ve 1 kere bulunur. Peki \"xb\" var mı? Hayır \"xb\" yoktur.Sebebi ise root noktasından aramaya başlandığında \"xb\" eşlemesi ile başlayan bir dallanma bulunamamıştır. Her dizgi bir suffix tree sahibi midir? Her dizgi bir suffix tree sahibi değildir.Eğer bir dizginin suffixleri prefixlerine eşitse bir suffix ağacı yoktur.Mesela \"cdbcd\" için inceleme yapalım. Suffixlerin : cdbcd,dbcd,bcd, cd ,d olduğunu biliyoruz. ve Prefixleri : c, cd ,cdb,cdbc,cdbcd şeklindedir. Dizginin kendisi dikkate alınmadan incelendiğinde \"cd\" değerlerinin ortak olduğu görülmektedir.Dolayısı ile \"cdbcd\" için bir suffix tree çizilemez.Peki bu sorunu nasıl çözebiliriz ? Çok basit sadece \"cdbcd\" stringinin sonuda bir \"\\$\" ekleyerek.Eğer \"cdbcd\\$\" için inceleme yaparsanız bir sorun olmadığını göreceksiniz. BURAK KÖSE","title":"Suffix Tree - String Algoritmaları","loc":"http://koseburak.net/blog/suffix-tree/"},{"tags":"Algoritma","text":"Türkçe'de taban sıralaması , basamaklı sıralama , kök sıralaması veya hane sıralaması olarak geçen bu algoritmada sıralanacak olan veriler hanelerine göre sıralanır.En değersiz olan haneden en değerli haneye doğru sıralama işlemi yapılır. Sıralanacak verilerin tamsayı olduğu durumlarda kullanılan bu algoritma işlenirken ilk olarak sıralanacak olan veri kümesindeki elemanların en büyük elemanının kaç basamaklı olduğu tespit edildikten sonra sayıların en değersiz olan basamağından itibaren incelenmeye başlanır ve yeni bir diziye yerleştirilir.Bu işlem dizinin en büyük elemanının basamak sayısı kadar tekrar edilir. Bu algoritmanın çalışma zamanı O(nk) ve yer karmaşıklığı O(n+k) olacaktır.Gayet iyi bir çalışma zamanına sahip olmasının nedeni bu algoritmanın karşılaştırmalı bir sıralama algoritması olmamasıdır.En büyük dezavantajı ise her basamak işlemi için yeni bir bellek alanı gerektirmesidir. Direkt Basamaklı SIralama ( Straight Radix Sort) algoritmasına bir örnek verelim. Sayılarımız : 32 , 224 , 16 , 15 , 31 , 169 , 123 , 252 olsun ve çözümümüz için aşağıdaki gibi bir tablo ile daha rahat işlemlerimiz anlaşılır. İlk olarak sayılar aşağıdaki gibi tabloya yerleştirildi. Hane3,Hane2,Hane1 0,3,2 2,2,4 0,1,6 0,1,5 0,3,1 1,6,9 1,2,3 2,5,2 Hane1'e göre sıralama gerçekleştirildi. Hane3,Hane2,Hane1 0,3,1 0,3,2 2,5,2 1,2,3 2,2,4 0,1,5 0,1,6 1,6,9 Hane1 sıralaması bittikten sonra Hane2 sıralaması gerçekleştirildi. Hane3,Hane2,Hane1 0,1,5 0,1,6 1,2,3 2,2,4 0,3,1 0,3,2 2,5,2 1,6,9 ve son olarak maksimum sayımızın hane sayısına ulaşıldı ve Hane3'e göre sıralama gerçekleştirildi. Hane3,Hane2,Hane1 0,1,5 0,1,6 0,3,1 0,3,2 1,2,3 1,6,9 2,2,4 2,5,2 Her şey güzel peki sayının kaç basamaklı olduğunu nereden anlayacağız diyorsanız. basamak sayısı = int(log(taban,max) + 1) Örneğin üstteki örneğimizde en büyük eleman 252 sayısı ve bu sayılar 10 tabanındadır.Dolayısı ile log(10,252) + 1 = 3,401 olur ve bunu int çevirirsek = 3 çıkar.Şimdi bu algoritmamızın örnek kodlarına gelelim. from math import log def getEmptyList(size): # Boş bir liste döndürür return [ [] for i in range(size) ] def getDigit(num, base, digit_num): # Hanelere göre değeri seçer # Örnek 123 sayısının ilk hanesi = 3 return (num // base ** digit_num) % base def maxWithAbs(p_list): # Maksimum sayıyı işaret farkı olmadan döndürür return max(abs(dig) for dig in p_list) def mergeList(p_list): # Parametre olarak aldığı listeyi birlştirir new_list = [] for sub in p_list: new_list.extend(sub) return new_list def split(s_list , base , digitNum): temp_list = getEmptyList(base) for number in s_list: temp_list[getDigit(number, base, digitNum)].append(number) return temp_list def splitBySign(p_list): # işaretli sayıları gruplar buffer = [[], []] for num in p_list: if num < 0: buffer[0].append(num) else: buffer[1].append(num) return buffer def radixSort(_list,base): digitNum = int(log(maxWithAbs(_list),base) + 1) for dig in range(digitNum):#İşaretlere bakmaksızın sıralıyor _list = mergeList(split(_list, base, dig)) return mergeList(splitBySign(_list))#işaretleri dikkate alıyor ve düzenliyor liste = [123,113,55,11,56,7,1,-1,2] print(radixSort(liste, 10)) Basamaklı Yer Değiştirme Sıralaması(Radix Exchange Sort) Şimdi direkt yerleştirmeli sıralamanın düzenlemiş hali olan Basamaklı Yer Değiştirme Sıralaması'nı inceleyelim.Kısaca farkları şudur.Direkt basamaklı sıralama algoritmasında sağdan-sola doğru yol alınırken bu yaklaşımda soldan-sağa doğru yol alınır ve en önemli avantajı bu algoritmada her basamak için özel bir bellek alanına ihtiyaç duyulmayacaktır.Bu algoritma içerisinde Quick Sort(Hızlı Sıralama) algoritması kullanılmıştır. Sayılar ikili(binary) olarak tutulduğundan taban değişimi için ek bir işlem yapılmasına gerek yoktur.Algoritmanın kodunu verirken biraz modifiye ettiğimden söz etmeliyim.Ufak değişiklikler ile negatif sayılar içinde işleyebilmesi için düzenledim. from math import log def swap(n1,n2): return n2 , n1 def getDigit(num, digit_num): return (num >> digit_num) & 0x01 def splitBySign(p_list): # işaretli sayıları gruplar buffer = [[], []] for num in p_list: if num < 0: buffer[0].append(num) else: buffer[1].append(num) return buffer def exchange(liste,down,up,digit): if up > down and digit >= 0: _down , _up = down , up while(_up > _down): while(getDigit(liste[_down], digit) == 0 and _down < _up): _down += 1 while(getDigit(liste[_up], digit) == 1 and _down < _up): _up -= 1 liste[_down] , liste[_up] = swap(liste[_down], liste[_up]) if(getDigit(liste[up], digit) == 0): _up += 1 exchange(liste,down,_up -1,digit -1) exchange(liste,_down,up,digit-1) def RadixExchangeSort(p_list): temp_buffer = splitBySign(p_list) #sayıları işaretine göre gruplandırdık negative_list , possitive_list = temp_buffer[0] , temp_buffer[1] if len(negative_list) > 0:#Eğer negatif sayı varsa exchange(negative_list,0,len(negative_list)-1,int(log(abs(min(negative_list)),2) + 1)) if len(possitive_list) > 0:#Eğer pozitif sayı varsa exchange(possitive_list,0,len(possitive_list)-1,int(log(max(possitive_list),2) + 1)) return negative_list + possitive_list #Deneme liste = [31,30,29,-10,3,1,6,8,-123,-1233,-999] print(RadixExchangeSort(liste)) BURAK KÖSE","title":"Radix Sort - Sıralama Algoritmaları","loc":"http://koseburak.net/blog/radix-sort/"},{"tags":"Algoritma","text":"Quick sort, Türkçe hızlı arama olan bu algoritma günümüzde en çok tercih edilen sıralama algoritmasıdır.1960 yılında C. A. R. Hoare tarafından ortaya atılmıştır.Bu algoritma yaklaşım bakımından \"parçala ve çözümle\" ilkesine göre çalışmaktadır. Bu yaklaşım şu şekilde açıklanabilir.Eldeki problem çok daha ufak problemciklere ayrılır ve bütün bu problemcikler tek tek çözülerek birleştirilir ve sonuç elde edilir.Örneğin çarpılacak iki matrisin daha küçük matrislere ayrılarak işlem yapılıp sonucun birleştirilerek elde edilmesi. Şimdi gelelim algoritmanın çalışma şekline.İlk olarak sıralanacak veri kümesini parçalayacak bir pivot seçilir.Geriye kalan elemanlar pivotun sağına ve soluna yerleştirilir.Bu yerleştirme seçilen pivotun solunda kalan elemanlar pivottan küçükler , sağında kalanlar ise pivottan büyük elemanlar olacaktır , eşit olanların ise ne tarafa yerleştiklerinin bir önemi yoktur.Bu işlem ardından yukarıdaki işlemler tüm parçalanmış diziler içinde tekrarlanır ve sonuç olarak sıralanmış dizi elde edilir. Bu algoritmanın ortalama çalışma zamanının karmaşıklığı O(nlogn) 'dir.Sebebi veri kümesi her seferinde ikiye bölünerek devam eder(logn) ve n adet eleman için sıralama yapılır.Algoritma en kötü durumda O(n\\&#94;2) ile çalışır.En kötü durum oluşması için seçilen pivot , veri kümesinin en küçük ya da en büyük büyük elemanı olması ile oluşur. Aşağıdaki animasyon (Alıntı : wikipedia) ve video sonrası anlamak daha kolay olacaktır. public static void quickSort(int[] arr, int left, int right) { int pivot = arr[(left + right) / 2]; int _left = left; int _right = right; do { while (pivot < arr[_right]) { _right--; } while (pivot > arr[_left]) { _left++; } if (_left <= _right) { if (_left != _right) { int temp = arr[_left]; arr[_left] = arr[_right]; arr[_right] = temp; } _right--; _left++; } } while (_right >= _left); if (left < _right){ quickSort(arr, left, _right); } if (right > _left){ quickSort(arr, _left, right); } } #Geliştirilmiş Hızlı Sıralama(Enhanced Quick Sort) Quick sort algoritmasında en kötü durum sonucunun ürettiği performans düşüklüğünü göz önüne alınarak algoritmada değişikliğe gidilmiştir.Bununla birlikte veri kümesinin 10'dan az elemana sahip olduğu zamanlarda hızlı sıralama algoritmasının yerine direkt yerleştirme sıralama sının uygulanması daha efektif olacaktır. En kötü durumun oluşmasının nedeni pivot seçimidir.Pivot seçimi normal şartlar altında dizinin orta noktası seçilerek gerçekleşiyordu.Bunun yerine bu yaklaşımda pivot elemanı dizinin ortasındaki,başındaki ve sonundaki elemanlar karşılaştırılarak seçilmesi şeklinde düzenlenmiştir(bknz : median of three).Bu değişiklik hızlı sıralama algoritmasının karmaşıklığını değiştirmeyecek fakat gerçekleştirilen karşılaştırma sayısında azalma olacaktır. public static void quickSort(int[] arr, int left, int right) { if (right - left < 10) { insertionSort(arr,left,right); } int pivot; if (arr[right] > arr[left]) { if (arr[(left + right) / 2] > arr[right]) { pivot = arr[right]; } else if (arr[(left + right) / 2] > arr[left]) { pivot = arr[(left + right) / 2]; } else { pivot = arr[left]; } } else { if (arr[(left + right) / 2] > arr[left]) { pivot = arr[left]; } else if (arr[(left + right) / 2] > arr[right]) { pivot = arr[(left + right) / 2]; } else { pivot = arr[right]; } } int _left = left; int _right = right; do { while (pivot < arr[_right]) { _right--; } while (pivot > arr[_left]) { _left++; } if (_left <= _right) { if (_left != _right) { int temp = arr[_left]; arr[_left] = arr[_right]; arr[_right] = temp; } _right--; _left++; } } while (_right >= _left); if (left < _right) { quickSort(arr, left, _right); } if (right > _left) { quickSort(arr, _left, right); } } **#Yinelemeli Olmayan Hızlı Sıralama(Non-Recursive Quick Sort) ** {style=\"text-align: justify;\"} Özyinelemeli(recursion) yaklaşımdan zorunda kalmadığım müddetçe uzak kalmaya çalışıyorum.Bazı zamanlar oldukça yorucu olabiliyor.Bu algoritmayıda olumsuz yönde etkileyen bir etken özyinelemeli yaklaşım. Stack kullanarak bu soruna bir alternatif yaklaşım üretebiliriz.Hızlı sıralama algoritmasında fark edildiği gibi aslında çok önemli iki parametre alıyor.Bunlar alt veri kümenin başlangıç ve bitiş indisleri.Bunları ayrı bir veri yapısında tutarak şöyle bir çözüm üretebiliriz. public static void quickSort(int[] arr) { int subArray = 0; Stack stack = new Stack (); stack.push(0); // left stack.push(arr.length - 1); // right do { int right = stack.pop(); int left = stack.pop(); --subArray; do { int _left = left; int _right = right; int pivot = arr[(left + right) / 2]; do { while (pivot < arr[_right]) { _right--; } while (pivot > arr[_left]) { _left++; } if (_left <= _right) { if (_left != _right) { int temp = arr[_left]; arr[_left] = arr[_right]; arr[_right] = temp; } _right--; _left++; } } while (_right >= _left); if (_left < right) { ++subArray; stack.push(_left); stack.push(right); } right = _right; } while (left < right); } while (subArray > -1); } Yapılan değişiklikler algoritmanın karmaşıklığını etkilemediği için çalışma zamanı karmaşıklığı değişmemektedir. BURAK KÖSE","title":"Quick Sort - Sıralama Algoritmaları","loc":"http://koseburak.net/blog/quick-sort/"},{"tags":"Algoritma","text":"Bir önceki yazımda cpu zamanlama algoritmalarından olan fcfs algoritmasından bahsetmiştim.Asıl ismi \"shortest next CPU burst algorithm\" olarak geçen ve yine bir cpu zamanlama algoritması olan Shortest Job First(SJF) yani en kısa iş ilk algoritmasını inceleyelim. Bu algoritmada belli bir sırada bekleyen işlerden önce kısa olanların işlenmesi amaçlanmıştır.Eğer iki işten aynı çalışma süresi içeren işler varsa geliş sıralarına göre işlem görürler.Bu algoritmanın duruma göre hem nonpreemptive(kesintisiz) hemde preemptive(kesintili) olarak düzenlenebilir. Temel olarak eldeki işlerin en kısasını yaparak zamandan kazanmaya çalışan bir algoritma olsada en büyük dezavantajı bir çıkmaz yaratmasıdır.Bu çıkmazı şöyle bir örnek ile açıklayabiliriz. Bir berbere gidiyorsunuz ve berberde sıra var.Dolayısı ile sıra almanız gerekiyor ve sıraya giriyorsunuz .Bu berberde işi kısa sürecek olan kişilere hep öncelik tanınıyor.Dolayısı ile siz,işi sizden uzun süreceklerin önüne geçiyorsunuz ve sıra size geliyor .İşiniz hallediliyor tam siz berberden çıkarken yine işi kısa sürecek biri geliyor ve sizin önünüze geçtiğiniz kişinin sırasını tekrar alıyor ve bunun çalışma saatleri bitene kadar böyle devam ettiğini düşünün.Dolayısı ile işi uzun ama çok önce gelmiş kişiler gün sonunda işini halledememiş bir şekilde beklemeye devam ediyorlar. Böyle bir kısır döngüye girme ihtimali bulunmaktadır.Şimdi algoritmamızı nonpreemptive bir durum için şu örnek ile açıklamaya devam edelim. Process Çalışma Zamanı A 8 B 10 C 9 D 5 ve sonuç olarak aşağıdaki gibi bir çalışma zamanı tablosu göreceğiz. Başlangıç Zamanı Process Çalışma Zamanı Kalan Zaman 0 D 5 0 5 A 8 0 13 C 9 0 22 B 10 0 Bu işlemler sonunda işlemlerin bekleme süreleri Process Çalışma Zamanı A 5 B 22 C 13 D 0 Yukarıdaki örnekde giren işlem kesintisiz bir şekilde gerçekleşmiştir.Şimdi bu örneğimizde ise algoritmamızı preemptive bir durum için inceleyelim. Process Geliş Zamanı Çalışma Zamanı A 0 10 B 1 6 C 2 11 D 3 7 ve sonuç olarak aşağıdaki gibi bir çalışma zamanı tablosu göreceğiz. Başlangıç Zamanı Process Çalışma Zamanı Kalan Zaman 0 A 1 9 1 B 6 0 7 D 7 0 14 A 9 0 23 C 11 0 BURAK KÖSE","title":"İlk iş kısa süreliler (Shortest Job First)","loc":"http://koseburak.net/blog/sjf/"},{"tags":"Algoritma","text":"Veri kümesinin sıralı olarak tutulması için geliştirilmiş en basit sıralama algoritmalarındandır.Türkçe'de seçmeli sıralama , seçerek sıralama şeklinde kullanılır.Geliştirilen uygulamalarda seçmeli sıralama kullanmak için düzgün bir analiz yapılması gerekir.Yer değiştirme sayısındaki sabitlik dolayısı ile büyük sayıda verinin bulunduğu uzun dosyalarda lineer zamanda sıralama yapılabilir. Temel olarak işleyiş şu şekilde gerçekleşir.İlk olarak veri kümesinin ilk elemanı seçilir ve geri kalan veriler ile karşılaştırılarak en küçük eleman bulunur ve kümenin başına yazılır.Daha sonra bir sonraki elemanlar içinde aynı işlem yapılarak dizi sıralanana kadar n. adımda tamamlanır.Aşağıdaki animasyon ile daha iyi anlayabiliriz. (Alıntı : wikipedia) Karmaşıklık analizi : O(n \\&#94; 2) Karşılaştırma sayısı : n\\&#94;2 / 2 Yer değiştirme sayısı : n (sabit) public void selectionSort(int[] arr){ for(int i = 0 ; i < arr.length - 1 ; i++){ int minPos = i; for(int j = i+1 ; j < arr.length ; j++){ if(arr[j] < arr[minPos]){ min = j; } } int temp = arr[i]; arr[i] = arr[minPos]; arr[minPos] = temp; } } BURAK KÖSE","title":"Selection Sort - Sıralama Algoritmaları","loc":"http://koseburak.net/blog/selection-sort/"},{"tags":"Algoritma","text":"Uygulaması kolay olan bu algoritmayı büyük diziler yerine daha küçük dizilerde kullanıldığında ve özellikle gelen veri kümesinin zaten sıralanmış veya sıralanmış haline çok yakın olduğunda kullanılır. Kararlı bir algoritma olmasıyla birlikle çalışma anında ek bir bellek ihtiyacı duymayan bu algoritma Türkçe'da yerleştirmeli sıralama , eklemeli sıralama ve sokma sıralaması olarak adlandırılabilir. Algoritma sıralanacak olam veri kümesinin ikinci elemanından itibaren verileri sırayla kontrol eder ve bir önceki kayıt o anki kayıttan büyükse(veya küçükse sıralama tipine bağlı olarak) bu iki elemanın yerleri değiştirilir ve geriye doğru kontrollere devam edilir.Dizi elemanı doğru yere yerleştirilene kadar bu işlemler tekrar edilir. Günlük hayatta aslında iskambil kağıtlarını sıralarken bu algoritmayı kullanırız.Şimdi bu algoritmayı analiz edelim. En iyi durumda (best case) : O(n) Dizi zaten sıralanmıştır Karşılaştırma sayısı : n(n-1)/2 En kötü durumda(worst case) : O(n\\&#94;2) Dizi tersten sıralı Karşılaştırma sayısı : n(n-1)/2 ve bu algoritmayı aşağıdaki şekilde tanımlayabiliriz. public void insertionSort(int[] arr){ fo(int i = 1 ; i < arr.length ; i++){ for(int j = i ; j > 0 ; j--){ if(arr[j] < arr[j-1]){ int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; }else{ break; } } } } #Direkt Yerleştirmeli Sıralama (Straight Insertion Sort) Yukarıda bu algoritmanın günlük hayatta iskambil kağıtlarını sıralamak için kullanıldığını söylemiştik.Aslında bu çok da doğru değildir.Bir araya ekleme işlemi vardır fakat bu ekleme işlemi hiç bir zaman tek tek kontrol yaparak ve yer değiştirerek olmayacaktır.Bir örnek verelim. 2,4,1,5 ve algoritmayı ilk adım için işletelim ve 4'ü seçelim bir işlem yapılamayacaktır çünkü bu aşamada sıralıdır.Bir sonraki adım olarak 1'i seçelim ve geriye doğru kotrollere devam edelim. 1 \\< 4 mü ? evet o halde 1'i araya al.Yeni durum \"2,1,4,5\" 1 \\< 2 mi? evet o halde tekrar araya al.Yeni durum \"1,2,4,5\" şeklinde algoritma işleyecektir.Oysa biz gerçekte 2 ve 4 sıralı olduğu için direk olarak 1'i en başa ekleyeceğiz.Yani her seferinde yer değiştirme yapmayacağız sadece kaydırma işlemi yapacağız ve direkt olarak yerleştirme yapacağız. Şimdi bu yaklaşım ile insertion sort'un yeniden düzenlenmiş bir algoritması olan Direkt Yerleştirmeli Sıralama ( Straight Insertion Sort) algoritmasının inceleyelim. En kötü durumda(worst case) : O(n\\&#94;2) Dizi tersten sıralı Karşılaştırma sayısı : n\\&#94;2 / 2 Yer değiştirme sayısı : n\\&#94;2 / 4 [gist:id=b9ee29a595a80d486622] Algoritmayı aşağıdaki animasyon ile daha iyi anlayabiliriz. (Alıntı : wikipedia) #İkili Yerleştirmeli Sıralama(Binary Insertion Sort) Şimdi biraz daha derine inerek bu algoritmanın daha optimize bir hale getirilmiş hali olan ve daha büyük veri kümelerinde diğer yerleştirmeli sıralama algoritmalarına göre daha başarılı olan bir algoritma olan İkili Yerleştirmeli Sıralama algoritmasını inceleyelim. Bu algoritmada seçilen dizi verisinin kendinden önce gelen veriler arasında nereye yerleştirileceğine karar verilirken geriye doğru ardaşık olarak kontrol etmek yerine , elimizdeki veri kümesine bir bütün olarak bakılarak ikili arama yapılması amaçlanmıştır.Hedef yer belirlendikten sonra tekrar kaydırma işlemi yapılarak işlem tamamlanır. Karmaşıklık için. En kötü durumda(worst case) : O(nlogn) Dizi tersten sıralı Karşılaştırma sayısı : n(logn - nloge) (yaklaşık olarak) public void insertionSort(int[] arr){ for(int i = 1 ; i < arr.length ; i++){ int control = arr[i]; int down = 0; int up = i; while(down < up){ int mid = (down + up) / 2; if(control < arr[mid]){ up = mid; }else{ down = mid + 1 ; } } for(int j = i ; j > down ; --j){ int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; } } } BURAK KÖSE","title":"Insertion Sort - Sıralama Algoritmaları","loc":"http://koseburak.net/blog/insertion-sort/"},{"tags":"Algoritma","text":"Kısaca FCFS algoritması.İsim benzerliği ve aslında çalışma mantığı bakımında kuyruk(queue) veri yapısına çok benzer(FIFO).Bilgisayar alanında özellikle işletim sistemlerinde bir çok alanda kullanılan bir algoritmadır.Bu algoritmik yaklaşımda bir sıraya ilk girenin işi ilk halledilmektedir. Bu şu şekilde açıklanabilir.Mahallenizde bir berber bulunmaktadır fakat ne yazık ki berber doludur ve herkes sırasını beklemektedir.Sizde bir sıra alırsınız ve aldığınız sırayı beklemek zorundasınızdır.Sizi önemli kılan hiç bir (para,pul,şöhret,tanıdık...) sıranızı beklemekten alıkoyamaz ve size sıra gelebilmesi için berberin sizden önce gelen tüm müşteriler ile ilgilenmiş olması gerekmektedir .İşte bu algoritmada buna benzer şekilde çalışır. Şimdi bu algoritmayı CPU Scheduling yani işlemci zamanlama tarafından örnekleyerek açıklayalım.Bu yaklaşımda işlemciye gelen işlerin işlenmesi, işlemlerin geliş sırasına göre belirlenmektedir. Process Çalışma Zamanı A 23 B 6 C 2 ve sonuç olarak aşağıdaki gibi bir tablo göreceğiz. Başlangıç Zamanı Process Çalışma Zamanı Kalan Zaman 0 A 23 0 23 B 6 0 29 C 2 0 Bu algoritma sonunda işlemlerin bekleme süreleri Process Bekleme Süresi A 0 B 23 C 29 Dolayısı ile ortalama bekleme süresi = (0+23+29) / 3 = 17.3 First come first serve (FCFS) algoritması nonpreemptive(kesintisiz) bir zamanlama algoritmasıdır.Yani sıraya giren işlemlerden biri bitirilmeden diğer işleme geçilmemektedir. Not : Eğer yukarıdaki processleri geliş sürelerine göre değilde çalışma zamanlarına göre sıralayarak işleme alsaydık ortalama bekleme süresinin daha az olduğunu görürdük.(bknz :SJF algoritması) BURAK KÖSE","title":"İlk gelen işi kapar (First Come First Serve)","loc":"http://koseburak.net/blog/first-come-first-serve/"},{"tags":"Algoritma","text":"Algoritma yazılarıma sıralama algoritmaları ile başlamak istedim.İlk olarak bubble sort ile başlamayı düşünürken bundan bir süre önce izlediğim bir video aklıma geldi. Bu videoda Barack Obama'nın başkan seçilmeden önce Google'da yaptığı bir konuşma geçiyor. Google CEO'su Eric Schmidt ile yaptığı sohbette Obama'ya bir milyon adet 32-bit integer sayıyı sıralamak için en efektif yolun hangisi olduğu soruluyor.Obama biraz bocalayıp düşündükten sonra Schmidt sorduğu soru için tam özür dileyerek yanıtlamayabilirsiniz diyecekken Obama'dan kabarcık sıralamasının doğru olduğunu düşünmüyorum cevabı gelince Schmidt şaşırarak Obama'nın bilgisayar bilimleriyle ilgili bir geçmişinin olmadığını söylerek cevabı ona kimin söylediğini soruyor.Tam bunun üzerine Obama \"Bizim oradada casuslarımız var\" diyerekten ince esipirisini yapıyor.Şimdi gelelim algoritmamıza. Kabarcık sıralaması olarak geçen bu algoritma ilk olarak yer değiştirme algoritması olarak adlandırılmıştır.Şimdilerde kabarcık sıralaması olarak adlandırılmasının nedeni ise dizi içerisindeki elemanların algoritmanın her anında dizi sonuna doğru ilerlemesidir(sıralama türüne bağlı olarak). Algoritmanın analizi : En iyi durum : O(n) -Dizi zaten sıralanmış -Yer değiştirme sayısı: 0 -Karşılaştırma sayısı: n-1 En kötü durum : O(n\\&#94;2) -Dizi tersten sıralı -Yer değiştirme sayısı: O(n\\&#94;2) -Karşılaştırma sayısı: O(n\\&#94;2 /2) Ortalama durum : 0(n\\&#94;2) -Bütün olasılıklar kontrol edilir Dolayısı ile bu algoritmanın en kötü durumdaki çalışma zamanı O(n\\&#94;2)'dir,algoritmanın en kötü durumda yapacağı karşılaştırma sayısı O(n\\&#94;2 / 2)'dir ve yer karmaşıklığı O(n)'dir. Örneğin küçükten büyüğe doğru sıralanacak bir işlem için algoritma şu adımlarda gerçekleşir.Dizinin başından başlanılarak dizi elemanları sırayle gezilir , gezilen dizi elemanları kendinden sonra gelecek eleman ile sıralama türüne bağlı olarak(küçüten büyüğe gibi) kontrol edilir ve yer değiştirilir.Bu işlem dizi sonuna kadar devam eder. Bir örnek verelim 7 , 9 , 4 , 11 , 8 , 3 , 5 Bu algoritmanın adımları şu şekilde olacaktır. 1. adım: 7 , 4 , 9 , 8 , 3 , 5 , 11 2. adım: 4 , 7 , 8 , 5 , 7 , 9 , 11 3. adım: 4 , 7 , 3 , 5 , 8 , 9 , 11 4. adım: 4 , 3 , 5 , 7 , 8 , 9 , 11 5. adım: 3 , 4 , 5 , 7 , 8 , 9 , 11 6. adım: 3 , 4 , 5 , 7 , 8 , 9 , 11 gibi bir sonuç elde edilir.Yani kısaca şöyle bir işlem yapılıyor , iki sayı alıyor bu iki sayıyı küçükten büyüğe sıralanacak şekilde yer değitiriliyor ve bu işlem dizi bitene kadar tekrarlanıyor.Alttaki animasyon anlamaya yardımcı olacaktır. (Alıntı : wikipedia) Kabarcık sıralaması çok da verimli olmayan bir sıralama algoritmasıdır fakat bazı basit müdahaleler ile biraz daha efektif hale getirilebilir.Bu konuda yazılarımı sıralama algoritmalarını temel olarak inceledikten sonra yayınlayacağım bir yazıdan ulaşabilirsiniz. public void bubbleSort(int[] arr) { int temp; for(int i=1; i arr[j+1]) { temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } } Obama ve Eric Schdimit konuşması için : Bubble sort için eğlenceli bir anlatım: BURAK KÖSE","title":"Bubble Sort - Sıralama Algoritmaları","loc":"http://koseburak.net/blog/bubble-sort/"},{"tags":"Linux","text":"Bu yazı Arch Linux 2014 Ağustos kalıbı dikkate alınarak hazırlanmıştır. Neden Arch , Nedir Bu ? Arch Linux \"sürekli güncel\"(bkz: \"rolling release\") paket mantığı üzerine kurulu, belirli bir düzeyde GNU/Linux bilgisi olan kullanıcıları hedef alan(tamamen göreceli kimileri yeni başlayanlar için ideal olduğu görüşünde) bağımsız bir dağıtımdır.Arch hızlı, hafif, esnek ve basittir. Arch Linux temel sistemi olabildiğince ufaktır.Çeşitli işlemlerin yapılması kullanıcıya bırakılmıştır.Kullanıcı istediği doğrultuda zengin depo yardımıyla istediği şekilde kendine uygun şekle getirebilir.Kısacası kendi evinizi istediğiniz şekilde biçimlendiriyorsunuz. Kurulum Kurulum aşaması metin tabanlı gerçekleşmektedir.Dolayısı ile komutlar ile kurulum yapılmaktadır.Arch Linux'un dökümantasyonu çok gelişmiştir.Sadece kurulum aşamasında değil çoğu zaman karşılaştığınız sorunların çok büyük bir bölümüne buradan çözüm bulabilirsiniz. https://wiki.archlinux.org/ http://archtr.org/wiki/index.php/Ana_Sayfa Donanımım CPU: 64 bit Intel Hard Drive: 500GB HDD RAM: 8GB Intel Graphic Card Nvidia GTX 660M BIOS Kuruluma Hazırlık Aşaması Arch Linux'un elde edilmesi için bu adres üzerinden kalıba ulaşabilirsiniz. https://www.archlinux.org/download/ CD veya USB üzerinden kurulumu gerçekleştirebilirsiniz.İndirdiğiniz kalıbı bu ortamlara yazarak bir sonraki aşamaya geçelim ve kurulum yapacağınız birimi boot ettiğimizde karşılaşacağımız ekran aşağıdaki gibi olacaktır. ] Aşama#1 Arch Kurulumu Kurulum aşamsında internet bağlantımız olması gerekmektedir.Dolayısı ile benim önerim ethernet bağlantısı sağlamanız yönünde.Eğer kurulum sırasında kablosuz bağlantı kullanacaksanız tebrikler ilk kez arch wiki'yi kullanacaksınız demektir. İlk olarak türkçe klavye kullanmak için # loadkeys trq komutunu veriniz.Bağlantı kontrolunuz için # ping -c 3 www.google.com Komutunun ekran çıksını size yol gösterecektir.Eğer her şey yolunda ise bir sonraki adıma geçebilirsiniz. Aşama#2 Disk Bölümleme Bu aşamada çok dikkatli olmasılısınz.Yanlış bir adım sizi veri kaybına ve belkide delirmenize yol açabilir.Bu aşamayı elle gerçekleyeceğiniz için önceden kendinize göre plan yaparak bölümleme işlemine geçiniz. Bölümlendirme aşamasında temel olarak genellikle dört bölüm yaratılır.Bunlar boot , / ( Kök dizini) , home ve swap alanlarıdır.Ben şahsen tek bölüm yaratıp o şekilde kullanmayı tercih ediyorum sizde yedekleme için kullandığınız ayrı bir disk bölümü varsa home dizini oluşturmanıza gerek yoktur.Swap alanı ise RAM'e bağlıdır.Eğer 4GB ve üstü RAM kullanıyorsanız bu alanada ihtiyacınız yoktur. /boot için = 100 MB Swap ( Takas alanı) için = 2 GB / kök için = 20-25 GB home için ise kişisel olarak oluşturmak istediğiniz miktarı verebilirsiniz İlk olarak lsblk komutunu çalıştırarak daha önceden olan bölümlemelerinizi kontrol edin ve bu aşamadan sonra tek bir disk kullandığınızı varsayarak # cfdisk dev/sda komutu sonrası görüntünüz şu şekilde olacaktır. Temel olarak bölüm ayırırken boş alan seçiliyken \"New - > Alan boyutu - > Tamam\" şeklinde bir yol izleyeceğiz.Şimdi alanları ayırmaya başlayalım ve ilk olarak boot alanı ayıralım. /boot için 100 MB bölüm oluşturmak için New seçin ve alan oluştuktan sonra alt tarafdaki özelliklerden Bootable özelliği verdikten sonra Type kısmına 83 yazarak bir sonraki alana geçin. Swap (takas) alanı için bölüm oluşturulmalıdır. Ben 2GB ayırdım. Sizde kendinize göre ayırabilirsiniz. Type kısmına 82 yazdıktan sonra bir sonraki alana geçin. Kök ( / ) için bölüm oluşturulacaktır.Kök dizini için 20-25 GB kadar alan ayırın. Type kısmına 83 yazın. Aynı yol ile isteğiniz doğrultusunda home için dilediğiniz kadar alan ayırdıktan sonra alt tarafdan Write kullanarak oluşturduğunuz bölümleri yazın ve bir sonraki aşama için Quit ile çıkın. # lsblk komutu ile kontrol edelim. sda1 – BIOS Boot sda2 – root sda3 – swap sda4 – home tabiki sizde durum farklı olabilir.Bu aşamadan sonrada sizdeki duruma göre şekil veriniz. Aşama#3 Dosya Sistemlerini Oluşturma Şimdi sırada oluşturduğumuz parçalara şekil vermeye geldi.Linux dosya sistemi olarak ext4 kullanır.İlk olarak aşağıdaki komutları root ve home dizinleri için yürütün.Bendeki şekli ile şu şekilde olacaktır. # mkfs.ext4 /dev/sda2 # mkfs.ext4 /dev/sda4 Şimdi swap bölümümüz için bendeki şekli ile # mkswap /dev/sda3 # swapon /dev/sda3 ve bu aşamanın son kısmı olarak son kez kontrol edelim bir sorun yoksa diğer aşamaya geçebiliriz # lsblk /dev/sda Temel Sistem Kurulumu Her şey yerli yerinde ise sırada temel sistem kurulumumuz bulunmaktadır.Öncelikle kök dizinimizi bağlayalım. # mount /dev/sda2 /mnt ve \"home\" isimli bir klasör yaratalım.Evet home için oluşturduğumuz parçayıda buraya bağlayacağız. # mkdir /mnt/home # mount /dev/sda4 /mnt/home Aşama#4 Temel paketlerin Kurulumu Sırada sistemimizin temelini kurma aşamamız var.Bu aşamada iskelet oluşacaktır. # pacstrap -i /mnt base base-devel Aşama#5 fstab Güncelleme Tüm temel paketlerin kurulumu başarı ile gerçekleştiyse fstab'a tüm değişiklikleri bildirebiliriz. # genfstab -U -p /mnt >> /mnt/etc/fstab (Not:Kesinlikle bir problem ile karşılaşmamış olmamız gerekmektedir) Linux'da her zaman yap kontrol et mekanizması işlemektedir.Bizde yaptığımız değişikliği kontrol edelim. # nano /mnt/etc/fstab Bir problem gözükmüyorsa CTRL + X ile çıkış yapabiliriz. Bu aşamalarda bir problem ile karşılaşmadıysak root ve home dizinlerinin başarı ile bağlanmış olduğunu görebiliriz.Kök dizinimizi değiştirerek diskte kurduğumuz temel sisteme bürünelim. # arch-chroot /mnt ve bin/bash Aşama#6 Dil ve Bölge ayarları Ayarlarımız için sırası ile #nano /etc/locale.conf açılan dosyaya LANG=tr_TR.UTF-8 yazıp CTRL + O ile kayıt edip CTRL + X ile çıkalım. # nano /etc/vconsole.conf açılan dosyaya KEYMAP=trq FONT=iso09,16 yazarak aynı şekilde kaydedip çıkalım. # nano /etc/timezone Europe/Istabul yazıp aynı şekilde kayıt edip çıkalım ve yaptığımız dil değişikliğini yazmak için # locale-gen Hostname değiştirmek için # echo ... > /etc/hostname (Not : ... olan yere dilediğinizi yazınız) Aşama#7 Depo Ayarları Sırada depomuzu ayarlamaya geldik.\"pacman.conf\" dosyamızı açalım # nano /etc/pacman.conf Eğer 64 bit sistem kullanıyorsak [multilib] Include = /etc/pacman.d/mirrorlist bu kısmı aktif etmemiz gerkeiyor.Başındaki # işaretini kaldırmanız yeterlidir.Daha sonra CTRL + O ile kayıt edip CTRL+X ile çıkalım. # pacman -Sy ile depoyu güncelleyelim. Aşama#8 Kullanıcı işlemleri Kullanıcı işlemlerine geçmeden önce bir root şifresi atayalım.Bunu kesinlikle yapmalısınız.Linux kullanırken root ile işlem yapmamaya dikkat edin.Dolayısı ile root kullanıcısından başka bir sistemi kullanacağınız bir kullanıcı oluşturacağız fakat ilk olarak root şifresi... # passwd komutunu yürüttükten sonra root kullanıcısına şifre atayınız.Tamamdır şimdi sırada kullanıcı oluşturma var. # useradd -m -g users -G wheel,storage,power -s /bin/bash ... (Not: ... yerine kullanıcı adınızı giriniz) ve daha sonra # passwd ... (Not: ... yerinde yukarıda oluşturduğunuz kullanıcı adı olacak) ile bu kullanıcıya bir şifre atamalıyız.Sırada sudo kurulumu var.Bu bize root olmadan sistem üzerinde işlemler yapmamıza olanak sağlayacak # pacman -S sudo daha sonra kişisel önerim olarak # pacman -S bash-completion kurulumu yapınız.Adındanda anlaşılacağı gibi otomatik tamamlamalarda yardımcı olur. Aşama#9 Linux çekirdeğini derleme Bu aşamada kernel konfigirasyonunu tamamlamak ve yazmak için aşağıdaki komutu yürütün. #mkinitcpio -p linux Aşama#10 Boot yükleyicisi Bu aşamada grub kurulumu yapmalıyız. # pacman -S grub # grub-install --recheck /dev/sda grub kurulumumuz tamamdır eğer sistemde birden fazla işletim sistemi yüklüyse diğerlerinin algılanması için #pacman -S os-prober komutunu yürütelim.Şimdi grubu güncelleyelim. # grub-mkconfig -o /boot/grub/grub.cfg ve sistem açılışında bağlantı alabilmemiz için # systemctl enable dhcpcd.service # systemctl start dhcpcd.service sonrasında # exit # umount -R /mnt # reboot komutlarını yürüttükten sonra sistem yeniden başlayacaktır.(Not: Yükleme yaptığınız birimi(CD,USB...) çıkartınız. Aşama#11 Boot sonrası Bir sorun yoksa karşınızda Arch Linux sizi selamlamalıdır.Basit kurulum bitmiş olup kurulum sonrası yapılandırma aşamasına geçmiş bulunmaktayız.Bundan sonraki yapılandırmalar size kalmış olsada basit olarak temel bir yapılandırma olarak şunları yapabilirsiniz.Unutmayın archwiki en yakın dostunuz. X server Kurulumu # pacman -S xorg-server xorg-server-utils xorg-xinit Mesa Kurulumu # pacman -S mesa Şimdi sırada ekran kartı kurulumu bulunmaktadır.Bu aşama genelde kullanıcıların başına bela açan bir aşamadır(Bende dahil).Eğer sisteminizde optimus teklonojili bir ekran kartınız varsa yani çift ekran kartlıysanız sizi burada hiç oyalamadan Arch Linux Wiki sayfasına yönlendireceğim.Yapmanız gerekenler orada harika bir şekilde anlatılmış olup tüm adımları dikkatlice adım adım izlemelisiniz. http://archtr.org/wiki/index.php?title=Bumblebee https://wiki.archlinux.org/index.php/NVIDIA_Optimus https://wiki.archlinux.org/index.php/bumblebee Eğer normal ekran kartı kullanıcısıysanız bile bu aşamada Arch Wiki'den yardım alabilirsiniz.Kendinize uygun seçeneği kurun.Ben şu şekilde devam ediyorum. # pacman -S nvidia # pacman -S xf86-video-intel # pacman -S xf86-video-ati Eğer laptop kullanıcısıysanız # pacman -S xf86-input-synaptics daha sonrasında temel x server bileşenleri için # pacman -S xorg-twm xorg-xclock xterm ve test etmek için sistemi yeniden başlatıp #startx Her şey yolunda ise devam edebilirsiniz lakin değilse muhtemelen ekran kartı kısmında bir yanlışlık yaptınız demektir.Arch wiki'den destek alabilirsiniz. Ses sürücüsü için # pacman -S alsa-lib alsa-utils Dbus Kurulumu # pacman -S dbus Gamin Kurulumu # pacman -S gamin Aşama#12 Masaüstü Kurulumu Kde Masaüstü Kurulumu: Uçbirimden devam ediyoruz. # pacman -S kde kde-l10n-tr komutunu uygulayın Gnome Masaüstü Kurulumu: # pacman -S gnome Yükleme bittikten sonra tekrardan # pacman -S gnome-extra # pacman -S gnome-tweak-tool Cinnamon Kurulumu # pacman -S cinnamon komutunu uygulayıp soruları (Y) ile onaylayın.Eğer yukarıdaki örnekler dışında kurmak istediğiniz bir masaüstü varsa siz istediğinizi kurabilirisiniz. Açılışta aktif etmek için aşağıdakilerden hangisi size uygunsa onu yürütün. # systemctl enable gdm.service # systemctl enable kdm.service # systemctl enable lxdm.service # systemctl enable slim.service # systemctl enable xdm.service Firefox için #pacman -S firefox Aşama#13 Ağ # pacman -S networkmanager arayüz için # pacman -S kdeplasma-applets-plasma-nm ve # systemctl enable NetworkManager # systemctl start NetworkManager Ben kablosuz ağ kullanmak için yaptığımız aşamalarda nedenini bilmediğim bir sorun ile karşılaştım.Bu sorunun çözümü için # systemctl disable dhcpcd.service komutu ile çözdüm. ve son , artık gönül rahatlığı ile Arch Linux kullanabilirsiniz , unutmayın baş ucu kaynağı olarak Arch Wiki vazgeçilmeziniz olsun. Umarım işinize yarayan bir yazı olmuştur. BURAK KÖSE","title":"Arch Linux Nasıl Kurulur","loc":"http://koseburak.net/blog/arch-linux-kurulumu/"}]}