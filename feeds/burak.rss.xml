<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>burakkose:blog</title><link>http://localhost:8000/</link><description></description><lastBuildDate>Fri, 23 Oct 2015 23:00:00 +0300</lastBuildDate><item><title>Apache Spark - Part 2 : Resilient Distributed Datasets</title><link>http://localhost:8000/blog/apache-spark-part2/</link><description>&lt;p&gt;&lt;a href="http://localhost:8000/blog/apache-spark-part1/"&gt;Bir önceki yazımda&lt;/a&gt; Apache Spark kurlumunu ve basit bir kaç örneği incelemiştik. Bu yazıda RDD("resilient distributed dataset) yani esnek dağıtık veri kümelerini inceliyor olacağız.&lt;/p&gt;
&lt;p&gt;RDD'ler basitçe değişmez(immutable) dağıtık obje koleksiyonlarıdır ve her biri farklı düğümlerde hesaplanmak üzere çeşitli parçalara bölünmüş şekildedir. Python, Scala veya Java'nın sahip olduğu tüm obje türlerini içerebilmekle beraber sizin de tanımladığınız sınıfları içerebilir.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://localhost:8000/blog/apache-spark-part1/"&gt;Önceki yazımda&lt;/a&gt;; örneğimizde &lt;code&gt;lines = sc.textFile("README.md")&lt;/code&gt; gibi bir kod kullandık. Bu kullanım ile aslında Python'da bir string RDD'si yaratmış olduk.&lt;/p&gt;
&lt;p&gt;Oluşturulan bir RDD yaratıldıktan sonra iki çeşit operasyonla kullanılabilir(bkz:transformations veya actions). Transformation işlemleri ile bir önceki RDD'den yeni bir RDD yaratılmasını sağlar.Örneğin bir önceki yazıda kullandığımız örneğe bakalım.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pythonLines = lines.filter(lambda line: "Python" in line)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Burada bir önceki RDD'yi(&lt;strong&gt;'lines'&lt;/strong&gt;) kullanarak yeni bir RDD(&lt;strong&gt;'pythonLines'&lt;/strong&gt;) oluşturuyoruz.&lt;/p&gt;
&lt;p&gt;Action ise sahip olduğumuz RDD üzerinde hesaplama türü işlemler yapmaktır. Örneğin;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pythonLines.first()&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="cache-veya-persist"&gt;Cache veya Persist&lt;/h4&gt;
&lt;p&gt;Eğer elinizdeki bir RDD'yi birçok kez kullanacaksak ve performansdan kazanmak istiyorsak, Spark'a bunu &lt;code&gt;RDD.persist()&lt;/code&gt; şeklinde bildirerek, memory'i kullanarak daha fazla performans elde edebilirsiniz(cache(), persist() ile aynı işlevi görür).Yazının devamında bu konuyu işliyor olacağız fakat kullanımı aşağıdaki gibidir.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pythonLines.persist&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Özetlemek gerekirse her Spark uygulaması aşağıdaki gibi bir yol izler.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Elindeki verilerden RDD'ler oluştur.&lt;/li&gt;
&lt;li&gt;Yeni RDD'ler elde et.(Transformation aşaması)&lt;/li&gt;
&lt;li&gt;Eğer birden fazla işlem yapacaksan Spark'a persist işlemini bildir.&lt;/li&gt;
&lt;li&gt;Elindeki veriyi işle.(Action aşaması)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="rdd-olusturmak"&gt;RDD oluşturmak&lt;/h3&gt;
&lt;h4 id="1var-olan-bir-koleksiyondan"&gt;1.Var olan bir koleksiyondan&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;lines = sc.parallelize(["burak", "kose", "arch" , "linux"])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Protatip ve test işlemleri yaparken uygun olan bir yöntemdir fakat gerçek zamanlı uyglamalarda çok da kullanışlı değildir, çünkü tek bir makinenin hafızasında büyük bir veri olması gerekmektedir ve dolayısı ile çoğu zaman böyle bir kaynak mümkün değildir.&lt;/p&gt;
&lt;h4 id="2harici-depolamadan"&gt;2.Harici depolamadan&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;data = sc.textFile("file-path")&lt;/code&gt; şeklinde kullanımdır.&lt;/p&gt;
&lt;h3 id="donusumlertransformations"&gt;Dönüşümler(Transformations)&lt;/h3&gt;
&lt;p&gt;Yürütülen her bir transformation işlemi gerçekten bir action ile karşılaşana kadar gerçekleştirilmez.Buna &lt;code&gt;"Lazy Evaluation"&lt;/code&gt; denir. "Lazy Evaluation" terimine daha önce foksiyonel bir programlama dili uğraşanlar aşinadır fakat terimi kısaca açıklamak gerekirse bir işlemin mecbur kalınana kadar yürütülmediği bir yaklaşımdır.&lt;/p&gt;
&lt;p&gt;Bir örnek gösterelim, elimizde bir log dosyası olsun ve biz içerisinde "error" geçen logları elde etmek isteyelim.Yapmamız gereken&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Örnek : filter()&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;input = sc.textFile(&amp;quot;log.txt&amp;quot;)
error = input.filter(lambda x: &amp;quot;error&amp;quot; in x)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;şeklinde olacaktır.&lt;strong&gt;error&lt;/strong&gt;'un yeni bir RDD olduğuna dikkat edin.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Örnek : union()&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;errorsRDD = inputRDD.filter(lambda x: &amp;quot;error&amp;quot; in x)
warningsRDD = inputRDD.filter(lambda x: &amp;quot;warning&amp;quot; in x)
badLinesRDD = errorsRDD.union(warningsRDD)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yapılan işleri aşağıdaki gibi bir görsel ile özetleyebiliriz.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="1" src="/images/apache_spark/2/1.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;İki çok genel transformation işlemi vardır, &lt;strong&gt;map&lt;/strong&gt; ve &lt;strong&gt;filter&lt;/strong&gt;. Bunların işlevleri aşağıdaki görseldeki gibi açıklanabilir.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="2" src="/images/apache_spark/2/2.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Örnek : map()&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; nums = sc.parallelize([1, 2, 3, 4])
&amp;gt;&amp;gt;&amp;gt; squared = nums.map(lambda x: x * x).collect()
&amp;gt;&amp;gt;&amp;gt; squared
[1, 4, 9, 16]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;gibi verilen parametredeki sayıların karesini alan bir örnek yazabiliriz.&lt;/p&gt;
&lt;p&gt;Bazen &lt;strong&gt;map&lt;/strong&gt; işleminin tersine her bir giriş ifadesine karşın birden fazla çıktı üretmek isteriz.Bu tip durumlarda kullanılan operasyon &lt;strong&gt;flatMap()&lt;/strong&gt;'dir. Aşağıdaki örnek girdi olarak verilen metni basitçe kelimelerine ayırır.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Örnek : flatMap()&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; lines = sc.parallelize([&amp;quot;hello world&amp;quot;, &amp;quot;hi&amp;quot;])
&amp;gt;&amp;gt;&amp;gt; words = lines.flatMap(lambda line: line.split(&amp;quot; &amp;quot;))
&amp;gt;&amp;gt;&amp;gt; words.first()
&amp;#39;hello&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Aşağıdaki görselde aynı işlemin &lt;strong&gt;map&lt;/strong&gt; ve &lt;strong&gt;flatMap&lt;/strong&gt; arasındaki farkı özetlenmektedir.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="3" src="/images/apache_spark/2/3.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Transformation işlemlerini incelemeye devam edelim.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="4" src="/images/apache_spark/2/4.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Yukarıdaki görseli açıklamak istersek kısaca,
- &lt;strong&gt;distinct&lt;/strong&gt; işlemi ile tekrar eden kayıtları atarak geriye eşsiz kayıtlardan oluşan bir RDD elde edebiliriz.
- &lt;strong&gt;union&lt;/strong&gt; işlemine daha önce değinmiştik.İki RDD'yi birleştirme işlevini görür fakat elemanların tekrarı ile ilgilenmediğine dikkat edin.
- &lt;strong&gt;intersection&lt;/strong&gt; işlemi iki RDD arasındaki ortak elemanları elde etmemizi sağlar.
- &lt;strong&gt;subtract&lt;/strong&gt; ile fonksiyona parametre olarak verilen RDD'deki elemamanlar dışındaki verileri elde ederiz.&lt;/p&gt;
&lt;p&gt;Bunların dışında iki RDD arasında kartezyen çarpım da elde edebiliriz. Bunun için &lt;code&gt;RDD1.cartesian(RDD2)&lt;/code&gt; uygulamamız yeterlidir.&lt;/p&gt;
&lt;h3 id="eylemleractions"&gt;Eylemler(Actions)&lt;/h3&gt;
&lt;p&gt;RDD oluşturmayı, var olan bir RDD'den yeni bir RDD yaratmayı transformation bölümünde gördük.Şimdi sıra veriler ile oynamada. Yapacağımız şey yukarıdaki örnekte elde ettiğimiz &lt;strong&gt;badLinesRDD&lt;/strong&gt; içerisindeki '5' log satırını görüntülemek olsun.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Örnek : take()&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(badLinesRDD.count(),&amp;quot; lines&amp;quot;)
print(&amp;quot;İşte beş örnek&amp;quot;)
for line in badLinesRDD.take(5):
    print(line)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;take()&lt;/strong&gt; gibi birde &lt;strong&gt;collect()&lt;/strong&gt; vardır fakat &lt;strong&gt;collect()&lt;/strong&gt; kullanacaksanız veri boyutunun çok küçük olması gerektiği ve tek bir makinede çalışmanız gerektiğini unutmayın. Dolayısı ile &lt;strong&gt;collect()&lt;/strong&gt; büyük veri kümelerinde çalışmak için uygun değildir.&lt;/p&gt;
&lt;p&gt;Sanırım en çok kullanılan action &lt;strong&gt;reduce&lt;/strong&gt;'dur. Kullanımı aşağıdaki gibidir.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sum = rdd.reduce(lambda x, y: x + y)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;veya Python'da operator modülünü kullanabiliriz.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;operator&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;
&lt;span class="nb"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rdd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dikkat ettiyseniz &lt;em&gt;reduce&lt;/em&gt; fonksiyonu geriye içinde işlem yaptığımız RDD'nin sahip olduğu tipte bir değer döndürmektedir.Bu yukarıdaki gibi toplama işlemi gibi operasyonlar da başarılı fakat geriye tek bir değer değil bir ikili döndürmek isteyebiliriz.&lt;/p&gt;
&lt;p&gt;Diğer basit action işlemlerini inceleyelim. İleride daha ayrıntılı bir biçimde tüm action işlemlerini inceleyeceğiz.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Fonksiyon&lt;/th&gt;
&lt;th&gt;Açıklaması&lt;/th&gt;
&lt;th&gt;Kullanım&lt;/th&gt;
&lt;th&gt;Sonuç&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;collect()&lt;/td&gt;
&lt;td&gt;RDD'deki tüm elemanları döndürür&lt;/td&gt;
&lt;td&gt;rdd.collect()&lt;/td&gt;
&lt;td&gt;[1, 2, 3, 3]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;count()&lt;/td&gt;
&lt;td&gt;RDD'deki eleman sayılarını döndürür&lt;/td&gt;
&lt;td&gt;rdd.count()&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;countByValue()&lt;/td&gt;
&lt;td&gt;RDD içerisindeki her bir elemanın kaç defa geçtiğini bilgisini verir&lt;/td&gt;
&lt;td&gt;rdd.countByValue()&lt;/td&gt;
&lt;td&gt;[(1, 1),(2, 1),(3, 2)]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;take(num)&lt;/td&gt;
&lt;td&gt;RDD'den num sayısı kadar eleman döndürür&lt;/td&gt;
&lt;td&gt;rdd.take(2)&lt;/td&gt;
&lt;td&gt;[1, 2]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;top(num, key=None)&lt;/td&gt;
&lt;td&gt;RDD'den en büyük num sayısı kadar sayı döndürür&lt;/td&gt;
&lt;td&gt;rdd.top(2)&lt;/td&gt;
&lt;td&gt;[3, 3]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;takeOrdered(num, key=None)&lt;/td&gt;
&lt;td&gt;Parametlere olarak verilen sıralama şartına göre num adet sıralanmış örnek döndürür&lt;/td&gt;
&lt;td&gt;rdd.takeOrdered(2)&lt;/td&gt;
&lt;td&gt;[3, 3]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;takeSample(withReplacement, num, [seed])&lt;/td&gt;
&lt;td&gt;Rastgele n eleman döndürür&lt;/td&gt;
&lt;td&gt;rdd.takeSample(True, 1, 1)&lt;/td&gt;
&lt;td&gt;Kestirilemez&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reduce(func)&lt;/td&gt;
&lt;td&gt;Paralel olarak elemanları birleştirir&lt;/td&gt;
&lt;td&gt;rdd.reduce(lambda x,y:x+y)&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;foreach(func)&lt;/td&gt;
&lt;td&gt;Parametre olarak verilen fonksiyon tün elemanlar üzerinde uygulanır&lt;/td&gt;
&lt;td&gt;rdd.foreach(func)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="onbelleklemecaching"&gt;Önbellekleme(Caching)&lt;/h3&gt;
&lt;p&gt;Spark RDD'lerinin "lazily evaluated" olduğundan bahsetmiştik. Bazen uygulamalarımızda bir RDD'yi birden fazla kez kullanmamız gerekebilir. Eğer bunu doğrudan yapıyor olsaydık, bizim her action isteğimizde, Spark bu RDD'yi ve bağımlılıklarını tekrar tekrar hesaplamak zorunda kalacaktı. Dolayısıyla iteratif algoritmaları kullanmamız gerektiğinde çok masraflı olacaktır. Bu konunun önemi çok fazladır, yazdığınız bir uygulama sorunsuz çalışıyor gibi gözükebilir fakat anlam veremediğiniz bir şekilde yavaş çalışıyorsa ilk olarak önbellekme konusunu incelemenizi tavsiye ederim. Bir örnek yapalım ve ne demek istediğimize bakalım.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Örnek : Çift hesaplamalı&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;operator&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyspark&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;sc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;appName&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;myname&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parallelize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; \
        &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;collect&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Bu tip bir performans kaybı yerine, Spark'a bu datayı 'persist' edebilir misin diye sorarız.&lt;/p&gt;
&lt;p&gt;Birden fazla seviye vardır.Genel olarak aşağıdaki gibi açıklanabilir.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Seviye&lt;/th&gt;
&lt;th&gt;Yer kullanımı&lt;/th&gt;
&lt;th&gt;CPU kullanımı&lt;/th&gt;
&lt;th&gt;Bellekte mi?&lt;/th&gt;
&lt;th&gt;Diskte mi?&lt;/th&gt;
&lt;th&gt;Açıklama&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MEMORY_ONLY&lt;/td&gt;
&lt;td&gt;Yüksek&lt;/td&gt;
&lt;td&gt;Düşük&lt;/td&gt;
&lt;td&gt;Evet&lt;/td&gt;
&lt;td&gt;Hayır&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEMORY_ONLY_SER&lt;/td&gt;
&lt;td&gt;Düşük&lt;/td&gt;
&lt;td&gt;Yüksek&lt;/td&gt;
&lt;td&gt;Evet&lt;/td&gt;
&lt;td&gt;Hayır&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEMORY_AND_DISK&lt;/td&gt;
&lt;td&gt;Yüksek&lt;/td&gt;
&lt;td&gt;Orta&lt;/td&gt;
&lt;td&gt;Birazı&lt;/td&gt;
&lt;td&gt;Birazı&lt;/td&gt;
&lt;td&gt;Veri bellek için fazla büyükse veri parçalarını diske koymaya başlar&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEMORY_AND_DISK_SER&lt;/td&gt;
&lt;td&gt;Düşük&lt;/td&gt;
&lt;td&gt;Yüksek&lt;/td&gt;
&lt;td&gt;Birazı&lt;/td&gt;
&lt;td&gt;Birazı&lt;/td&gt;
&lt;td&gt;Veri bellek için fazla büyükse veri parçalarını diske koymaya başlar. Serilize edilerek saklanır&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DISK_ONLY&lt;/td&gt;
&lt;td&gt;Düşük&lt;/td&gt;
&lt;td&gt;Yüksek&lt;/td&gt;
&lt;td&gt;Hayır&lt;/td&gt;
&lt;td&gt;Evet&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;Örnek : Persist kullanımı&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;operator&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyspark&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;sc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;appName&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;myname&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parallelize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; \
        &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;persist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StorageLevel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DISK_ONLY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;collect&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Not&lt;/strong&gt;:persist() fonksiyonunun RDD henüz action ile karşılaşmadan önce çağrıldığına dikkat edin.&lt;/p&gt;
&lt;p&gt;Eğer belleğe sığamayacak kadar veriyi önbelleklemeye çalışırsanız Spark otomatik olarak kendini Least Recently Used (LRU) politikasına göre düzenleyecektir.&lt;/p&gt;
&lt;p&gt;Burada bahsedilenden çok daha fazla sayıda transformation ve action işlemi vardır. Çok daha ayrıntılı biçimde ileriki yazılarımda bahsedeceğim.&lt;/p&gt;
&lt;p&gt;BURAK KÖSE&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Fri, 23 Oct 2015 23:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-23:blog/apache-spark-part2/</guid><category>bigdata</category><category>datasciece</category><category>spark</category><category>python</category></item><item><title>En uzun artan altdizi(LIS) - Dinamik Programlama</title><link>http://localhost:8000/blog/lis/</link><description>&lt;p&gt;Bir dizi içerisinde en uzun artan altdiziyi bulmayı amaçlayan bir problemdir. Örneğin&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Input:
    {10, 22, 9, 33, 21, 50, 41, 60, 80}
Output:
    6{10, 22, 33, 50, 60, 80}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://localhost:8000/blog/lcs/"&gt;LCS&lt;/a&gt; algoritmasına benzer bir yol izleyeceğiz. Kod anlaşılır durumda, çözüm aşağıdadır.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def lis(arr):
    lis = [1] * len(arr)

    for i in range(1, len(arr)):
        for j in range(i):
            if arr[i] &amp;gt; arr[j] and lis[i] &amp;lt; lis[j] + 1:
                lis[i] = lis[j] + 1

    return max(lis)

if __name__ == &amp;#39;__main__&amp;#39;:
    arr = [10, 22, 9, 33, 21, 50, 41, 60]
    print(lis(arr))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yukarıdaki algoritmanın zaman karmaşıklığı &lt;code&gt;O(n^2)&lt;/code&gt;'dir. Algoritma farklı bir yaklaşım ile &lt;code&gt;O(nlogn)&lt;/code&gt; karmaşıklık ile çözülebilir. İncelemek için : &lt;a href="http://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms"&gt;link&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Fri, 23 Oct 2015 21:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-23:blog/lis/</guid><category>algorithm</category><category>dynamic programming</category></item><item><title>En uzun ortak altdizi(LCS) - Dinamik Programlama</title><link>http://localhost:8000/blog/lcs/</link><description>&lt;p&gt;Bilgisayar bilimlerinde önemli bir yere sahip olan bu problemde, verilen iki dizgide de ortak olarak bulunan ve aynı yönde sıralanmış dizgiler bütünü elde edilmeye çalışılmaktadır.&lt;/p&gt;
&lt;p&gt;Örneğin;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; “ABCDGH” ve “AEDFHR” için “ADH”
 “AGGTAB” ve “GXTXAYB” için “GTAB”
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dosyalar arasındaki farkları, değişiklikleri elde etmede ve özellikle bioinformatik alanında sıkça karşılaşılan bir çözümdür. Çözüm aşağıdaki gibidir.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def lcs(s1, s2):
    len_s1, len_s2 = len(s1) + 1, len(s2) + 1
    S = [[0] * len_s1 for _ in range(len_s2)]

    for i in range(1, len_s2):
        for j in range(1, len_s1):
            if s1[j - 1] == s2[i - 1]:
                S[i][j] = S[i - 1][j - 1] + 1
            else:
                S[i][j] = max(S[i - 1][j], S[i][j - 1])

    return S[len_s2 - 1][len_s1 - 1]

if __name__ == &amp;#39;__main__&amp;#39;:
    X = &amp;quot;AGGTAB&amp;quot;
    Y = &amp;quot;GXTXAYB&amp;quot;
    print(lcs(X, Y))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Bu algoritmanın zaman karmaşıklığı &lt;code&gt;O(nm)&lt;/code&gt;'dir. Peki hangi dizginin LCS olduğunu bulmak için ne yapmamız gerekiyor? Bunun için şu şekilde bir düzenleme ile sonuca ulaşabiliriz.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s s-Atom"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;lcs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;
    &lt;span class="s s-Atom"&gt;len_s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;len_s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="nv"&gt;S&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="s s-Atom"&gt;len_s1&lt;/span&gt; &lt;span class="s s-Atom"&gt;for&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="s s-Atom"&gt;in&lt;/span&gt; &lt;span class="nf"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;len_s2&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;

    &lt;span class="s s-Atom"&gt;for&lt;/span&gt; &lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="s s-Atom"&gt;in&lt;/span&gt; &lt;span class="nf"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;len_s2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;
        &lt;span class="s s-Atom"&gt;for&lt;/span&gt; &lt;span class="s s-Atom"&gt;j&lt;/span&gt; &lt;span class="s s-Atom"&gt;in&lt;/span&gt; &lt;span class="nf"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;len_s1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;
            &lt;span class="s s-Atom"&gt;if&lt;/span&gt; &lt;span class="s s-Atom"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s s-Atom"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;
                &lt;span class="nv"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s s-Atom"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s s-Atom"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="nn"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="nv"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s s-Atom"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s s-Atom"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nv"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s s-Atom"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

    &lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s s-Atom"&gt;len_s2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;len_s1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="s s-Atom"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="s s-Atom"&gt;while&lt;/span&gt; &lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="s s-Atom"&gt;and&lt;/span&gt; &lt;span class="s s-Atom"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;
        &lt;span class="s s-Atom"&gt;if&lt;/span&gt; &lt;span class="s s-Atom"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s s-Atom"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;
            &lt;span class="s s-Atom"&gt;result&lt;/span&gt; &lt;span class="s s-Atom"&gt;+=&lt;/span&gt; &lt;span class="s s-Atom"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="s s-Atom"&gt;elif&lt;/span&gt; &lt;span class="nv"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s s-Atom"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s s-Atom"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;
            &lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="s s-Atom"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="nn"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="s s-Atom"&gt;j&lt;/span&gt; &lt;span class="s s-Atom"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

    &lt;span class="s s-Atom"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;len_s2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s s-Atom"&gt;len_s1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="s s-Atom"&gt;result&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;::-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="s s-Atom"&gt;if&lt;/span&gt; &lt;span class="k"&gt;__&lt;/span&gt;&lt;span class="s s-Atom"&gt;name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s s-Atom"&gt;&amp;#39;__main__&amp;#39;:&lt;/span&gt;
    &lt;span class="nv"&gt;X&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;AGGTAB&amp;quot;&lt;/span&gt;
    &lt;span class="nv"&gt;Y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;GXTXAYB&amp;quot;&lt;/span&gt;
    &lt;span class="nf"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;lcs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Çok daha ayrıntılı bir inceleme için &lt;a href="https://en.wikipedia.org/wiki/Longest_common_subsequence_problem"&gt;Wiki&lt;/a&gt; sayfasından yardım alabilirsiniz.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Tue, 20 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-20:blog/lcs/</guid><category>algorithm</category><category>dynamic programming</category><category>bioinformatic</category></item><item><title>Sieve of Eratosthenes - Matematik Problemi</title><link>http://localhost:8000/blog/sieve-of-eratosthenes/</link><description>&lt;p&gt;Verilen bir &lt;code&gt;n&lt;/code&gt; sayısı var ve bu sayıya kadar olan tüm asal sayıların elde edilmesi için sunulmuş en efektif çözümdür &lt;a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"&gt;(ref: Wiki)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="gif" src="https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" /&gt;&lt;/p&gt;
&lt;p&gt;Algoritma şu şekilde çalışır.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;2'den n'e kadar bir liste yaratılır. (2,3,4,5,6...n)&lt;/li&gt;
&lt;li&gt;p = 2 yapılarak ilk asal sayı 2 ilan edilir.&lt;/li&gt;
&lt;li&gt;2p,3p,4p,5p ... gibi katlar alınarak bu sayılar işaretlenir ve asal sayılardan dışlanmış olunur&lt;/li&gt;
&lt;li&gt;iaşretlenmemiş ilk sayı bulunarak p'ye atanır ve işlemler tekrar edilir.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Çözüm aşağıdaki gibi olur.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def mark(arr, n):
    i = 2
    num = i * n
    while num &amp;lt;= len(arr):
        arr[num - 1] = 1
        i += 1
        num = i * n


def sieve_of_eratosthenes(n):
    if n &amp;gt;= 2:
        arr = [0] * n
        for i in range(1, n):
            if arr[i] == 0:
                print(i + 1)
                mark(arr, i + 1)

if __name__ == &amp;#39;__main__&amp;#39;:
    n = 10
    sieve_of_eratosthenes(n)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Agoritmanın anlaşılırlığı için kod uzun tutulmuştur. Çok daha fazla kısaltılması mümkündür.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Tue, 20 Oct 2015 16:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-20:blog/sieve-of-eratosthenes/</guid><category>algorithm</category><category>mathematical</category></item><item><title>Sayının faktoriyelinde sonda bulunan 0'ların sayısı - Matematik Problemi</title><link>http://localhost:8000/blog/faktoriyel-0s-count/</link><description>&lt;p&gt;Verilen sayının faktoriyelinde sonda bulunan sıfırların sayısını bulmamız gerekiyor.&lt;/p&gt;
&lt;p&gt;Örneğin;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;

&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2432902008176640000&lt;/span&gt;

&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En basit hali ile çözüm, sayının faktoriyelini hesaplamak ve sondaki sıfıların sayısını saymak. Masraflı ve büyük sayılar için çalışmayacak bir yöntem.&lt;/p&gt;
&lt;p&gt;Matematikten faydalanarak şu şekilde çözebiliriz. Sayının sonunda 0 oluşabilmesi için en az bir adet 2 ve bir adet 5 gerekmektedir. Dolayısı ile sayı içerisindeki 2lerin ve 5lerin sayısını sayarsak çözüme ulaşabiliriz.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;n = 5: Bir adet 5 ve üç adet 2 bulunmaktadır (2 * 2 * 2 * 3 * 5). Dolayısıyla 0ların sayısı 1&amp;#39;dir.

n = 11: İki adet 5 ve üç adet 2 bulunmaktadır. (2^8 * 3^4 * 5^2 * 7). Dolayısıyla 0ların sayısı 2&amp;#39;dir.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sayı içerisindeki 2lerin sayısı es geçebiliriz zaten her seferinde elimizde fazladan 2 olacak. Sadece 5lerin sayısını saymak yeterlidir. Dikkat etmemiz gereken başka bir durum bulunmaktadır. Örneğin 28! sayısı için 25 sayısından gelen fazladan bir 5 durumu vardır. Aynı durum 125 yani 5'in üsleri içinde geçerlidir.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n! için sondaki sıfır sayısı = floor(n/5) + floor(n/25) + floor(n/125) + ....&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def count_zeros(n):
    result = 0
    i = 5
    while n // i &amp;gt;= 1:
        result += n // i
        i *= 5
    return result

if __name__ == &amp;#39;__main__&amp;#39;:
    n = 100
    print(count_zeros(n))
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Tue, 20 Oct 2015 14:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-20:blog/faktoriyel-0s-count/</guid><category>algorithm</category><category>mathematical</category></item><item><title>Hileli parayı hilesiz yapmak - Matematik Problemi</title><link>http://localhost:8000/blog/0-1-50/</link><description>&lt;p&gt;Verilen bir fonksiyon yazı tura işlemini %60 yazı %40 tura gelecek şekilde gerçekleştiriyor. Bu verilen fonksiyonu kullanarak bu işlemi nasıl hilesiz yapabiliriz?&lt;/p&gt;
&lt;p&gt;Paranın %60 olasılıkla 0, %40 olasılık ile 1 döndürdüğünü biliyoruz. Çözüm olarak bu fonksiyonu iki kere çağıracağız. Eğer sonuçlar (1,0) veya (0,1) ise problem yok, direk cevabı vereceğiz fakat cevaplar (1,1) veya (0,0) ise işlemi tekrarlayacağız.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(0, 1): 0 sonrası 1 gelme olasılığı = 0.6 * 0.4 = 0.24
(1, 0): 1 sonrası 0 gelme olasılığı = 0.4 * 0.6 = 0.24
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def foo():
    &amp;#39;Bu method hileli olarak 1 veya 0 döndürür&amp;#39;
    pass


def my_foo():
    val1 = foo()
    val2 = foo()
    if val1 == 0 and val2 == 1:
        return 0  # 0.24 olasılık
    if val1 == 1 and val2 == 0:
        return 1  # 0.24 olasılık
    return my_foo()  # 1 - 0.24 - 0.24 olasılık
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Tue, 20 Oct 2015 12:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-20:blog/0-1-50/</guid><category>algorithm</category><category>mathematical</category></item><item><title>Hedef puana kaç farklı şekilde ulaşılır? - Dinamik Programlama</title><link>http://localhost:8000/blog/nth-score/</link><description>&lt;p&gt;3, 5 ve 10 puan almanın mümkün olduğu ve hedef puana bu puan gruplarını kullanarak kaç farklı şekilde ulaşılabileceğini bulacağız.&lt;/p&gt;
&lt;p&gt;Örnek;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Çözüm mantığı gayet basittir. n+1 boyutunda bir dizi yaratılır ve her puanlama için döngüler ile tüm çözüm sayıları tutulur. Zaman ve yer karmaşıklığı 0(n) olacaktır.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def adjust(l, score, n):
    for i in range(score, n + 1):
        l[i] += l[i - score]


def count(n):
    result = [0] * (n + 1)
    result[0] = 1  # 0 puan için

    adjust(result, 3, n)
    adjust(result, 5, n)
    adjust(result, 10, n)

    return result[n]

if __name__ == &amp;#39;__main__&amp;#39;:
    score = 20
    print(count(score))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Cevabı doğru bulduk fakat (10, 5, 5), (5, 5, 10) ve (5, 10, 5) durumları tek bir durum olarak sayılmıştır. Peki bu durumlarıda farklı birer yol olarak saymak istersek yukarıdaki kodu biraz değiştirmek gerekecek.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def count_new(n):
    result = [0] * (n + 1)
    result[0] = 1  # 0 puan için

    for i in range(3, n + 1):
        if i &amp;gt;= 3:
            result[i] += result[i - 3]
        if i &amp;gt;= 5:
            result[i] += result[i - 5]
        if i &amp;gt;= 10:
            result[i] += result[i - 10]

    return result[n]

if __name__ == &amp;#39;__main__&amp;#39;:
    score = 20
    print(count_new(score))
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Mon, 19 Oct 2015 23:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-19:blog/nth-score/</guid><category>algorithm</category><category>dynamic programming</category></item><item><title>N. basamağa kaç adımda ulaşılabilir? - Dinamik Programlama</title><link>http://localhost:8000/blog/nth-stair/</link><description>&lt;p&gt;N adet basamağa sahip bir merdivende, en alt noktadan üst noktaya her seferinde en fazla bir veya iki adım atarak kaç farklı şekilde ulaşabileceğimizi bulacağız.&lt;/p&gt;
&lt;p&gt;&lt;img alt="basamak" src="/images/DynamicProgramming/stairs.gif" /&gt; Örneğin yadaki resim için 3 adet çözüm vardır.&lt;/p&gt;
&lt;p&gt;Daha fazla örnek;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;Sadece&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;adımda&lt;/span&gt; &lt;span class="n"&gt;ulaşılır&lt;/span&gt;

&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="err"&gt;İ&lt;/span&gt;&lt;span class="n"&gt;ki&lt;/span&gt; &lt;span class="n"&gt;farklı&lt;/span&gt; &lt;span class="n"&gt;adımda&lt;/span&gt; &lt;span class="n"&gt;ulaşılır&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ve&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Basit olarak rekürsif olarak çözebilir. &lt;code&gt;yol(n) = yol(n-1) + yol(n-2)&lt;/code&gt; . Aslında yandaki formulun &lt;a href="http://localhost:8000/blog/fibonacci/"&gt;fibonacci&lt;/a&gt; formulu olduğu çok belli.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def recursion(n):
    if n &amp;lt;= 1:
        return n
    return recursion(n - 1) + recursion(n - 2)


def solve(n):
    return recursion(n + 1)

if __name__ == &amp;#39;__main__&amp;#39;:
    n = 4
    print(solve(n))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yukarıdaki çözüm O(2^n) zaman karmaşasına sahiptir. Tabi çok daha efektif çözmenin yollarını &lt;a href="http://localhost:8000/blog/fibonacci/"&gt;şurada&lt;/a&gt; daha önce belirttim.&lt;/p&gt;
&lt;h4 id="problemin-genellestirilmis-hali"&gt;Problemin genelleştirilmiş hali&lt;/h4&gt;
&lt;p&gt;Örneğin kişinin m adıma kadar hakkı olsun. m=4 için kişi her bir anda 1, 2, 3 veya 4 adım atabilir.
&lt;code&gt;yol(n, m) = yol(n-1, m) + yol(n-2, m) + ... yol(n-m, m)&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def calculate(n, m):
    if n &amp;lt;= 1:
        return n
    res = 0
    i = 1
    while i &amp;lt;= m and i &amp;lt;= n:
        res += calculate(n - i, m)
        i += 1
    return res


def solve_gen(n, m):
    return calculate(n + 1, m)

if __name__ == &amp;#39;__main__&amp;#39;:
    basamak = 4
    adim = 2
    print(solve_gen(basamak, adim))
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Mon, 19 Oct 2015 23:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-19:blog/nth-stair/</guid><category>algorithm</category><category>dynamic programming</category></item><item><title>Fibonacci sayısı oluşturma - Matematik Problemi</title><link>http://localhost:8000/blog/fibonacci/</link><description>&lt;p&gt;Fibonacci sayılarını oluşturmanın birden fazla yöntemi vardır.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 141, ……..&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Fn = Fn-1 + Fn-2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F0 = 0 and F1 = 1.&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="metot-1-recursion"&gt;Metot 1 ( recursion )&lt;/h3&gt;
&lt;p&gt;Yukarıda verilmiş olan matematik ifadesinin direkt olarak uygulanmış halidir. İşe yarar ama çok fazla maliyetlidir.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;T(n) = T(n-1) + T(n-2)&lt;/code&gt; karmaşıklık analizi çözüldüğünde karşımıza &lt;code&gt;O(2^n)&lt;/code&gt; çıkar. Gerçekten maliyetli bir çözüm!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def recursion(n):
    if n &amp;lt;= 1:
        return n
    return recursion(n - 1) + recursion(n - 2)

if __name__ == &amp;#39;__main__&amp;#39;:
    n = 9
    print(recursion(n))
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="metot-2-dynamic-programming"&gt;Metot 2 (Dynamic Programming)&lt;/h3&gt;
&lt;p&gt;Metot 1'deki öz yinelemeli çözümde aynı değerleri defalarca hesapladıımızı görmüşsünüzdür. Bu işlemi önlemek amaçlı dinamik programlama yaklaşımına bakacağız.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def dynamic(n):
    fib_list = [0, 1]
    for i in range(2, n + 1):
        fib_list.append(fib_list[i - 1] + fib_list[i - 2])
    return fib_list[n]

if __name__ == &amp;#39;__main__&amp;#39;:
    n = 9
    print(dynamic(n))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Bu çözümün zaman karmaşıklığı &lt;code&gt;O(n)&lt;/code&gt; ve yer karmaşıklığı &lt;code&gt;O(n)&lt;/code&gt; olmaktadır.&lt;/p&gt;
&lt;h3 id="metot-3-metot-2-icin-yer-duzenlemesi"&gt;Metot 3 (Metot 2 için yer düzenlemesi)&lt;/h3&gt;
&lt;p&gt;Metot 2'de yapılan çözüm yer karmaşıklığına sahiptir. Yani ekstra bellek kullanımı gerektiren bir çözümdür. Bu çözümü aynı proramlama paradigması ile yerden ödün vermeyerek şu şekilde çözebiliriz.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def space_dynamic(n):
    a, b = 0, 1
    if n == 0:
        return a
    for i in range(2, n + 1):
        a, b = b, a + b
    return b

if __name__ == &amp;#39;__main__&amp;#39;:
    n = 9
    print(space_dynamic(n))
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="metot-4"&gt;Metot 4&lt;/h3&gt;
&lt;p&gt;Bir başka &lt;code&gt;O(n)&lt;/code&gt; çözüme sahip bir çözüm olan bu çözümde elimizde bir matris var.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;M = [[1,1],[1,0]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;n. fibonacci sayısını istiyorsak bu matrisi kendisi ile n kere çarpmamız ve (0,0) elemanını almamız gerekmektedir. Kısacası pow(M,n) işlemi yapmamız gerekmektedir.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Matris" src="/images/MathematicalAlgorithm/fibonaccimatrix.png" /&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def matrix(n):
    F = [[1, 1], [1, 0]]
    if not n:
        return 0
    power(F, n - 1)
    return F[0][0]


def power(F, n):
    M = [[1, 1], [1, 0]]
    for i in range(2, n + 1):
        multiply(F, M)


def multiply(F, M):
    x = F[0][0] * M[0][0] + F[0][1] * M[1][0]
    y = F[0][0] * M[0][1] + F[0][1] * M[1][1]
    z = F[1][0] * M[0][0] + F[1][1] * M[1][0]
    w = F[1][0] * M[0][1] + F[1][1] * M[1][1]

    F[0][0] = x
    F[0][1] = y
    F[1][0] = z
    F[1][1] = w

if __name__ == &amp;#39;__main__&amp;#39;:
    n = 9
    print(matrix(n))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Zaman karmaşıklığı &lt;code&gt;O(n)&lt;/code&gt; ve yer karmaşıklığı &lt;code&gt;O(1)&lt;/code&gt; olur.&lt;/p&gt;
&lt;h3 id="metot-5-metot-4-iyilestirmesi"&gt;Metot 5 (Metot 4 iyileştirmesi)&lt;/h3&gt;
&lt;p&gt;Bu adım ile artık n. fibonacci sayısını bulma işlemini &lt;code&gt;O(logn)&lt;/code&gt; karmaşıklıkta çözebileceğiz.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def matrix_opt(n):
    F = [[1, 1], [1, 0]]
    if not n:
        return 0
    power(F, n - 1)
    return F[0][0]


def power_opt(F, n):
    if n == 0 and n == 1:
        return
    M = [[1, 1], [1, 0]]
    power_opt(F, n / 2)
    multiply(F, F)
    if n % 2 != 0:
        multiply(F, M)


def multiply(F, M):
    x = F[0][0] * M[0][0] + F[0][1] * M[1][0]
    y = F[0][0] * M[0][1] + F[0][1] * M[1][1]
    z = F[1][0] * M[0][0] + F[1][1] * M[1][0]
    w = F[1][0] * M[0][1] + F[1][1] * M[1][1]

    F[0][0] = x
    F[0][1] = y
    F[1][0] = z
    F[1][1] = w

if __name__ == &amp;#39;__main__&amp;#39;:
    n = 9
    print(matrix_opt(n))
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sun, 18 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-18:blog/fibonacci/</guid><category>algorithm</category><category>mathematical</category></item><item><title>Sıralı olarak verilmiş üç diziden ortak elemanları bulma - Arama Algoritması</title><link>http://localhost:8000/blog/search-common-element-three/</link><description>&lt;p&gt;Artan sırada verilmiş üç dizi içerisinde bulunan ortak elemanı bulmamıza yarayan algoritmaya bakacağız.&lt;/p&gt;
&lt;p&gt;Örneğin&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ar1[] = {1, 5, 10, 20, 40, 80}
ar2[] = {6, 7, 20, 80, 100}
ar3[] = {3, 4, 15, 20, 30, 70, 80, 120}
Output: 20, 80

ar1[] = {1, 5, 5}
ar2[] = {3, 4, 5, 5, 10}
ar3[] = {5, 5, 10, 20}
Output: 5, 5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Basit olarak ilk çözüm &lt;a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/"&gt;link!&lt;/a&gt; algoritmasını uygulamak ve elde edilen değerleri yedek bir dizi içerisinde tutmaktır. Bu çözüm ile karmaşıklık O(n1+n2+n3) olacaktır.&lt;/p&gt;
&lt;p&gt;Yukarıda ki çözüm ekstra olarak hafıza ve iki adet döngü içermektedir. Oysa bu soruyu tek bir döngüde ve ektra hafıza gerektirmeden çözebiliriz.&lt;/p&gt;
&lt;p&gt;Çözüm aşağıdaki gibidir.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def find_common(ar1, ar2, ar3):
    i, j, k = 0, 0, 0
    n1, n2, n3 = len(ar1), len(ar2), len(ar3)
    while i &amp;lt; n1 and j &amp;lt; n2 and k &amp;lt; n3:
        if ar1[i] == ar2[j] and ar2[j] == ar3[k]:
            print(ar1[i])
            i, j, k = i + 1, j + 1, k + 1
        elif ar1[i] &amp;lt; ar2[j]:
            i += 1
        elif ar2[j] &amp;lt; ar3[k]:
            j += 1
        else:
            k += 1

if __name__ == &amp;#39;__main__&amp;#39;:
    ar1 = [1, 5, 10, 20, 40, 80]
    ar2 = [6, 7, 20, 80, 100]
    ar3 = [3, 4, 15, 20, 30, 70, 80, 120]
    find_common(ar1, ar2, ar3)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Karmaşıklık O(n1+n2+n3) olacaktır.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sun, 18 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-18:blog/search-common-element-three/</guid><category>algorithm</category><category>searching</category></item><item><title>Suffix Array - String Algoritmaları</title><link>http://localhost:8000/blog/suffix-array/</link><description>&lt;p&gt;Suffix dizisi, verilmiş olarak verilen stringe ait tüm suffixlerin alfabetik olarak sıralanmış halidir. Suffix array eğer elinizde bir suffix tree varsa, bu ağaç üzerinde DFS algoritmasını işletilmesi ile elde edilebilir.&lt;/p&gt;
&lt;p&gt;Suffix array veri yapısının, suffix tree'den avantajları, geliştirilmiş bellek performansı ve keşleme özelliğidir.&lt;/p&gt;
&lt;p&gt;Önreğin;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;quot;banana&amp;quot; için.

0 banana                          5 a
1 anana     Suffixes sırala       3 ana
2 nana      ----------------&amp;gt;     1 anana  
3 ana        alfabetik olarak     0 banana  
4 na                              4 na   
5 a                               2 nana

&amp;quot;banana&amp;quot; için suffix dizisi {5, 3, 1, 0, 4, 2} olur.
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="suffix-array-olusturmak-icin-temel-metot"&gt;Suffix Array oluşturmak için temel metot&lt;/h3&gt;
&lt;p&gt;Açıkçası yukarıdaki örnek yeterince açık, basit bir kaç core fonksiyon sayesinde oluşturulabilecek bir algoritma. Ben biraz işin kolayına kaçarak Python'da basit şekilde oluşturacağım.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def build_suffix_array(text):
    return sorted(range(len(text)), key=lambda x: text[x:])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yukarıdaki algoritma &lt;code&gt;O(n^2logn)&lt;/code&gt; zaman karmaşıklığında çalışmaktadır. Suffix array oluşturmak içi çok daha verimli algoritmalar bulunmaktadır!&lt;/p&gt;
&lt;h3 id="arama-islemi"&gt;Arama işlemi&lt;/h3&gt;
&lt;p&gt;Elimizde aslında sıralanmış bir string dizisi var gibi düşünebiliriz ve sıralanmış bir dizi içerisinde arama yapma işleminde herkesin muhtemelen aklına gelen algoritma &lt;code&gt;Binary Search&lt;/code&gt; algoritmasıdır. Bu işlemdede bu algoritmayı kullanacağız.&lt;/p&gt;
&lt;p&gt;Çözüm aşağıdaki gibi olacaktır.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def search(text, pattern, suffs, l, r):
    if r &amp;lt; l:
        return -1

    mid = l + (r - l) // 2
    t = text[suffs[mid]:][:len(pattern)]

    if pattern == t:
        return suffs[mid]
    elif pattern &amp;gt; t:
        return search(text, pattern, suffs, mid + 1, r)
    else:
        return search(text, pattern, suffs, l, mid - 1)

if __name__ == &amp;#39;__main__&amp;#39;:
    text = &amp;quot;banana&amp;quot;
    pattern = &amp;quot;anan&amp;quot;
    suffix_array = build_suffix_array(text)
    print(search(text, pattern, suffix_array, 0, len(text) - 1))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yukarıdaki arama algoritması &lt;code&gt;O(mlogn)&lt;/code&gt;'dir. Gerçek şu ki suffix array veri yapısı için çok daha verimli tanımlamalar vardır. Bu gerçekten çok basit bir giriştir ve olayın genel mantığı için&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sun, 18 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-18:blog/suffix-array/</guid><category>algorithm</category><category>string</category><category>searching</category></item><item><title>Sıralı iki dizi içerisinde seçilen ikili toplamının hedef sayıya en yakın olması - Arama Algoritması</title><link>http://localhost:8000/blog/find-closest-pair-sorted/</link><description>&lt;p&gt;Hoşuma giden problem türlerinden olan yakın ikili sorularından biri. Bu problemde girdi olarak verilen iki tane sıralanmış dizi ve bir hedef numarası bulunuyor ve dizilerden seçilen hangi iki elemanın toplamının hedef elemana en yakın sayı olacağını bulmamız gerekiyor.&lt;/p&gt;
&lt;p&gt;Örnek olarak;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="n"&gt;ar1&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;};&lt;/span&gt;
        &lt;span class="n"&gt;ar2&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="o"&gt;};&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;      
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;

&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="n"&gt;ar1&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;};&lt;/span&gt;
        &lt;span class="n"&gt;ar2&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="o"&gt;};&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;      
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;gibi.&lt;/p&gt;
&lt;p&gt;Eğer dizilerin birinin &lt;code&gt;n&lt;/code&gt; elemanlı diğerinin &lt;code&gt;m&lt;/code&gt; elemanlı (n=m olabilir) olduğunu varsayarsak en ilkkel çözüm şu şekilde olacaktır. İki tane döngü kurarak karşılıklı olarak tüm ihtimalleri deneyerek cevaba ulaşmaya çalışırız. Tabi bu çözümde verilen dizilerin sıralı olup olmamasının bir değeri kalmamakla birlikte zaman karmaşıklığımız &lt;code&gt;O(n^2)&lt;/code&gt; olacaktır.&lt;/p&gt;
&lt;p&gt;Şimdi başka bir taraftan probleme bakalım.Verilen dizileri aynı merge sort işleminde olduğu gibi birleştirelim ve tek bir dizi üzerinden hedef elemana ulaşmaya çalışabiliriz(buda özel bir problem). Bunun sayesinde karmaşıklık &lt;code&gt;O(n)&lt;/code&gt; dolaylarına inecektir ve ekstra memory kullanmış olacağız.&lt;/p&gt;
&lt;p&gt;Peki çok daha iyi bir çözüm yok mu?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Karşılaştırma için &lt;code&gt;diff&lt;/code&gt; adında sonsuz değere sahip bir değişken ata&lt;/li&gt;
&lt;li&gt;Sıralı olarak verilen diziler üzerinde gezinmek için &lt;code&gt;l&lt;/code&gt; ve &lt;code&gt;r&lt;/code&gt; adında ki index değişkeni tutun&lt;/li&gt;
&lt;li&gt;l = 0 ve r = -1&lt;/li&gt;
&lt;li&gt;Döngü şartı l &amp;lt; m ve r &amp;gt;= 0 olmak üzere&lt;/li&gt;
&lt;li&gt;Eğer abs(ar1[l] + ar2[r] - sum) &amp;lt; diff ise diff ve result değişkenlerini güncelle&lt;/li&gt;
&lt;li&gt;Eğer ar1[l] + ar2[r] &amp;lt;  sum ise l++&lt;/li&gt;
&lt;li&gt;r--&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Çözüm aşağıdaki gibi olacaktır.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;math&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;inf&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_closest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ar1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ar2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;diff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inf&lt;/span&gt;
    &lt;span class="n"&gt;res_l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res_r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ar2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ar1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ar1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ar2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;resl_l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res_r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ar1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ar2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ar1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ar2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;({} - {})&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ar1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;res_l&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ar2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;res_r&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;ar1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;ar2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;38&lt;/span&gt;
    &lt;span class="n"&gt;print_closest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ar1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ar2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sat, 17 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-17:blog/find-closest-pair-sorted/</guid><category>algorithm</category><category>searching</category></item><item><title>Bit işlemleri yardımıyla 7 ile çarpma işlemi - Matematik Problemi</title><link>http://localhost:8000/blog/carp-yedi/</link><description>&lt;p&gt;Bir sayıyı yedi ile çarpmanın bitwise karşılığı.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if __name__ == &amp;#39;__main__&amp;#39;:
    num = 3
    print((num &amp;lt;&amp;lt; 3) - num)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Not: Sadece pozitif sayılar için.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Thu, 15 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-15:blog/carp-yedi/</guid><category>algorithm</category><category>mathematical</category><category>bit</category></item><item><title>Prim Algoritması - Greedy Yaklaşımı</title><link>http://localhost:8000/blog/prim-mst/</link><description>&lt;p&gt;Tıpkı Kruskal algoritmasında olduğu gibi Prim algoritmasında da amaç en kısa yol ağacını bulmaktır ve greedy yaklaşımı ile çözülür.&lt;/p&gt;
&lt;p&gt;Algoritma aşağıdaki şekilde çalışır.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ağaca eklenmiş tüm düğümleri tutacak bir küme oluştur(&lt;code&gt;mst_set&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Başlangıçta tüm düğümlere sonsuz değeri verin sadece içlerinden bir tanesini seçmek için 0 değeri verin.&lt;/li&gt;
&lt;li&gt;Eğer &lt;code&gt;1.&lt;/code&gt; adımda oluşturduğunuz küme tüm düğümleri kapsamıyorsa&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mst_set&lt;/code&gt; 'in içermediği ve minimum değere sahip düğümü seçin(&lt;code&gt;u&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; 'yu &lt;code&gt;mst_set&lt;/code&gt; içerisine atın&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; 'ya komşu olan tüm düğümlerin değerini güncelleyin.Tüm komşu düğümler(&lt;code&gt;v&lt;/code&gt;) üzerinde güncelleme amacıyla gezinirken eğer u-v önceki değerden küçükse değeri u-v şeklinde güncelleyin.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Şimdi algoritmayı uygulamaya geçelim.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;math&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;inf&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;min_key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mst_set&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;Geriye minimum değere sahip komşunun indeksini döndürür&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;mini&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;min_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;inf&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mst_set&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;mini&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;mini&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;min_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;min_index&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_prim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Düğüm sayısı&lt;/span&gt;
    &lt;span class="n"&gt;vertices_len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Oluşturulmuş ağac listesi&lt;/span&gt;
    &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;vertices_len&lt;/span&gt;

    &lt;span class="c1"&gt;# Minimum ağırlıklı komşuyu seçmek için kullanılan liste&lt;/span&gt;
    &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;inf&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;vertices_len&lt;/span&gt;

    &lt;span class="c1"&gt;# Ağaca eklenmemiş düğümleri içeren liste&lt;/span&gt;
    &lt;span class="n"&gt;mst_set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;vertices_len&lt;/span&gt;

    &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="c1"&gt;# İlk düğüm seçiliyor&lt;/span&gt;
    &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="c1"&gt;# İlk düğüm her zaman root&amp;#39;dur&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vertices_len&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# Minimum değere sahip komşu&lt;/span&gt;
        &lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;min_key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mst_set&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# Ağaca eklenmiş olduğu işaretleniyor&lt;/span&gt;
        &lt;span class="n"&gt;mst_set&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

        &lt;span class="c1"&gt;# Güncelleme işlemi&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vertices_len&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;mst_set&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
                &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Edge   Weight&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vertices_len&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; - &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;  &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;          2    3&lt;/span&gt;
&lt;span class="sd"&gt;       (0)--(1)--(2)&lt;/span&gt;
&lt;span class="sd"&gt;        |   / \   |&lt;/span&gt;
&lt;span class="sd"&gt;       6| 8/   \5 |7&lt;/span&gt;
&lt;span class="sd"&gt;        | /     \ |&lt;/span&gt;
&lt;span class="sd"&gt;       (3)-------(4)&lt;/span&gt;
&lt;span class="sd"&gt;              9&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;graph&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
             &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;print_prim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Algoritmanın zaman karmaşıklığı &lt;code&gt;O(n^2)&lt;/code&gt; 'dir. Eğer girdi olarak alınan graf komşuluk matrisi yerine binary heap hardımıyla liste şeklinde kullanılmış olsaydı karmaşıklık &lt;code&gt;O(ElogV)&lt;/code&gt; olacaktı.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Wed, 14 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-14:blog/prim-mst/</guid><category>algorithm</category><category>greedy</category><category>graph theory</category></item><item><title>Veri akışının aritmetik ortalaması - Matematik Problemi</title><link>http://localhost:8000/blog/stream-ortalama/</link><description>&lt;p&gt;Bu problemde elimize, bir kaynaktan gelen sürekli veriler var yani hep bir sayı akışı var. Bizden her gelen yeni sayı için o anki aritmetik ortalama istenmektedir.&lt;/p&gt;
&lt;p&gt;Örneğin;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Akış ... 10, 20, 30, 40, 50, 60, …
10 geldiğinde ortalama 10.00
20 geldiğinde ortalama 15.00
30 geldiğinde ortalama 20.00
40 geldiğinde ortalama 25.00
50 geldiğinde ortalama 30.00
60 geldiğinde ortalama 35.00
..................
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Çözüm şu şekilde olacaktır.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def get_avg(prev, num, count):
    return (prev * count + num) / (count + 1)


def calculate_stream(arr):
    avg = 0
    for i, num in enumerate(arr):
        avg = get_avg(avg, num, i)
        print(num, &amp;quot; geldiğinde ortalama = &amp;quot;, avg, sep=&amp;quot;&amp;quot;)

if __name__ == &amp;#39;__main__&amp;#39;:
    arr = [10, 20, 30, 40, 50, 60]
    calculate_stream(arr)
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Wed, 14 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-14:blog/stream-ortalama/</guid><category>algorithm</category><category>mathematical</category></item><item><title>Bozuk para problemi - Greedy Yaklaşımı</title><link>http://localhost:8000/blog/bozuk-para/</link><description>&lt;p&gt;Bize verilen bir miktar para var ve bu miktarı en az sayıda banknot ile karşılamak istiyoruz. Gerçek hayattada sıkça karşılaşılan bir problemi aslında greedy yaklaşımı ile çözüyoruz.&lt;/p&gt;
&lt;p&gt;Örneğin&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;70&lt;/span&gt; &lt;span class="n"&gt;TL&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="mi"&gt;50&lt;/span&gt; &lt;span class="n"&gt;TL&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="n"&gt;TL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;70&lt;/span&gt; &lt;span class="n"&gt;TL&lt;/span&gt;

&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;121&lt;/span&gt; &lt;span class="n"&gt;TL&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="n"&gt;TL&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="n"&gt;TL&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;TL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;121&lt;/span&gt; &lt;span class="n"&gt;TL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Mantık çok basit değil mi? Şimdi çözüme geçelim&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MONEY = (1, 2, 5, 10, 20, 50, 100, 200)


def find_min(target):
    result = []
    for m in sorted(MONEY, reverse=True):
        while target &amp;gt;= m:
            target -= m
            result.append(m)
    print(*result, sep=&amp;quot; Tl + &amp;quot;, end=&amp;quot; = {} TL&amp;quot;.format(sum(result)))

if __name__ == &amp;#39;__main__&amp;#39;:
    target = 1994
    find_min(target)
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Tue, 13 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-13:blog/bozuk-para/</guid><category>algorithm</category><category>greedy</category></item><item><title>Sayı fibonacci sayısı mı? - Matematik Problemi</title><link>http://localhost:8000/blog/fibo-kontrol/</link><description>&lt;p&gt;Verilen sayının fibonacci sayısı olup olmadığını anlamanın basit bir yolu var.&lt;/p&gt;
&lt;p&gt;İsterseniz sırayla kendi sayınıza kadar fibonacci sayılarını oluşturup kontrol ederek gidebilirsiniz. Tabi aşırı maliyetli bir çözüm olur, ya da matematikten faydalanırsınız.&lt;/p&gt;
&lt;p&gt;Bu çözüme tam kare çözümü denmektedir. Kontrol için aşağıdaki eşitliği kullancağız.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(5*n^2 + 4) veya (5*n^2 – 4)&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def is_perfect_square(x):
    s = x ** 0.5
    return s * s == x


def is_fibo(n):
    return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)

if __name__ == &amp;#39;__main__&amp;#39;:
    number = 34
    print(is_fibo(number))
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Mon, 12 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-12:blog/fibo-kontrol/</guid><category>algorithm</category><category>mathematical</category></item><item><title>Çarpma ve bölme işlemi kullanmadan üs alma - Matematik Problemi</title><link>http://localhost:8000/blog/pow-without/</link><description>&lt;p&gt;Üs alma işlemi problemlerine farklı bir yaklaşım sunan bu problemde, çarpma(&lt;code&gt;*&lt;/code&gt;) ve bölme(&lt;code&gt;/&lt;/code&gt;) işlemi kullanmadan üs alma işlemine bakacağız.&lt;/p&gt;
&lt;p&gt;Örneğin;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;5^6 işlemi için;
result = 0
1.) 5 kere 5 ekle (5^2) = 25
2.) 5 kere 25 ekle (5^3) = 125
3.) 5 kere 125 ekle (5^4) = 625
4.) 5 kere 625 ekle (5^5) = 3125
5.) 5 kere 3125 ekle (5^6) = 15625
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="ic-ice-dongu-kullanarak"&gt;İç içe döngü kullanarak&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def nested_pow(a, b):
    if b == 0:
        return 1
    result, increment = a, a
    for i in range(1, b):
        for j in range(1, a):
            result += increment
        increment = result
    return result
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="recursive-cozum"&gt;Recursive çözüm&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def recursion_pow(a, b):
    if b != 0:
        return multiply(a, recursion_pow(a, b - 1))
    else:
        return 1


def multiply(x, y):
    if y != 0:
        return x + multiply(x, y - 1)
    else:
        return 0
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if __name__ == &amp;#39;__main__&amp;#39;:
    print(nested_pow(5, 6))
    print(recursion_pow(5, 3))
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Mon, 12 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-12:blog/pow-without/</guid><category>algorithm</category><category>mathematical</category></item><item><title>Kruskal Algoritması - Greedy Yaklaşımı</title><link>http://localhost:8000/blog/kuruskal-mst/</link><description>&lt;p&gt;En küçük yol ağacı problemine(minimum spanning tree) üretilmiş bir çözümdür. En basit graf algoritmalarından biridir. Greedy yaklaşımı ile çözüme ulaşılır. Amaç bir graf içerisinde tüm düğümleri kapsayan minimum maliyete sahip ağacı elde etmektir.&lt;/p&gt;
&lt;p&gt;Aşağıda kabaca algoritmanın çalışmasını anlayabilirsiniz.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Tüm kenarları maliyetlerine göre küçükten büyüğe doğru sıralay&lt;/li&gt;
&lt;li&gt;En düşük maliyetli kenarı seçin ve oluşturduğunuz ağaçta çevrim oluşturup oluşturmadığını kontrol edin.Eğer içermiyorsa kenarı ağaca ekleyin.&lt;ol&gt;
&lt;li&gt;adımı işlem tamamlanana kadar devam ettirin.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Minimum spanning tree &lt;code&gt;(V-1)&lt;/code&gt; adet kenar içerecektir.&lt;/p&gt;
&lt;p&gt;Çevrim oluşturmak ne demektir? Eğer başladığınız bir noktadan dönüp dolaşıp ağaç üzerinde tekrar aynı noktaya gelebiliyorsanız çevrim oluşmuş demektir. Çevrim olup olmadığının anlanması özel bir konudur. Bununla ilgili yazılarımı ilerleyen zamanlarda yazacağım. &lt;code&gt;Union-Find&lt;/code&gt; algoritması kullanılır.Mantık olarak çok basittir.&lt;/p&gt;
&lt;p&gt;Çözüm aşağıdaki gibi olur&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;parent = dict()
rank = dict()


def make_set(vertice):
    parent[vertice] = vertice
    rank[vertice] = 0


def find(vertice):
    if parent[vertice] != vertice:
        parent[vertice] = find(parent[vertice])
    return parent[vertice]


def union(vertice1, vertice2):
    root1 = find(vertice1)
    root2 = find(vertice2)
    if root1 != root2:
        if rank[root1] &amp;gt; rank[root2]:
            parent[root2] = root1
        else:
            parent[root1] = root2
            if rank[root1] == rank[root2]:
                rank[root2] += 1


def get_sorted_edges(graph):
    &amp;#39;Kenarları elde edelim&amp;#39;
    edges = []
    for src in graph:
        for dest in graph[src]:
            edges.append(tuple(src) + dest)
    return sorted(edges, key=lambda x: x[2])


def print_kruskal(graph):
    for vertex in graph:
        make_set(vertex)
    sorted_edges = get_sorted_edges(graph)
    for edge in sorted_edges:
        v1, v2, w = edge
        if find(v1) != find(v2):
            union(v1, v2)
            print(edge)  # sonuc

if __name__ == &amp;#39;__main__&amp;#39;:
    &amp;quot;&amp;quot;&amp;quot;
            10
        0--------1
        |  \     |
       6|   5\   |15
        |      \ |
        2--------3
            4
    Vertices = 0,1,2,3
    &amp;quot;&amp;quot;&amp;quot;
    graph = {&amp;quot;0&amp;quot;: [(&amp;quot;1&amp;quot;, 10), (&amp;quot;2&amp;quot;, 6), (&amp;quot;3&amp;quot;, 5)],
             &amp;quot;1&amp;quot;: [(&amp;quot;3&amp;quot;, 15)],
             &amp;quot;2&amp;quot;: [(&amp;quot;3&amp;quot;, 4)],
             &amp;quot;3&amp;quot;: []}
    print_kruskal(graph)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Bu algoritmanın zaman karmaşası &lt;code&gt;O(ElogE)&lt;/code&gt; veya &lt;code&gt;O(ElogV)&lt;/code&gt; olur.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sun, 11 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-11:blog/kuruskal-mst/</guid><category>algorithm</category><category>greedy</category><category>graph theory</category></item><item><title>En basit hali ile text arama işlemi - String Algoritmaları</title><link>http://localhost:8000/blog/naive-search-string/</link><description>&lt;p&gt;Text işlemlerinde, bir dizgi içerisinde dizgi aramadaki en basit çözümü inceleyeceğiz.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;txt[] =  &amp;quot;THIS IS A TEST TEXT&amp;quot;
pat[] = &amp;quot;TEST&amp;quot;
Output: 10
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;txt[] =  &amp;quot;AABAACAADAABAAABAA&amp;quot;
pat[] = &amp;quot;AABA&amp;quot;
Output: 0,9,13
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Çözüm aşağıdaki gibi olacaktır.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def search(text, pattern):
    m, n = len(pattern), len(text)
    for i in range(n - m + 1):
        for j in range(m):
            if text[i + j] != pattern[j]:
                break
        if j + 1 == m:
            print(i)

if __name__ == &amp;#39;__main__&amp;#39;:
    txt = &amp;quot;AABAACAADAABAAABAA&amp;quot;
    pat = &amp;quot;AABA&amp;quot;
    search(txt, pat)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="en-iyi-durum-nedir"&gt;En iyi durum nedir?&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;txt[]  = &amp;quot;AABCCAADDEE&amp;quot;
pat[] = &amp;quot;FAA&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Desenin ilk karakteri arana text içerisinde bulunmadığı zamandır ve karmaşıklık &lt;code&gt;O(n)&lt;/code&gt; olur.&lt;/p&gt;
&lt;h3 id="en-kotu-durum-nedir"&gt;En kötü durum nedir?&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;txt[] = &amp;quot;AAAAAAAAAAAAAAAAAA&amp;quot;
pat[] = &amp;quot;AAAAA&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yani tüm karakterler aynı olduğunda ve&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;txt[] = &amp;quot;AAAAAAAAAAAAAAAAAB&amp;quot;
pat[] = &amp;quot;AAAAB&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;son karakterler aynı olursa. Bu durumda da karmaşıklık &lt;code&gt;O(m*(n-m+1))&lt;/code&gt; olur.&lt;/p&gt;
&lt;p&gt;String arama işlemlerinin önemli olduğunu söylemiştim. Bu gördüğünüz algoritma adı üstünde en kaba,basit çözümdür. Çok daha efektif algoritmalar bulunmaktadır.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sun, 11 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-11:blog/naive-search-string/</guid><category>algorithm</category><category>string</category><category>searching</category></item><item><title>İş planlama problemi - Greedy Yaklaşımı</title><link>http://localhost:8000/blog/is-planlama/</link><description>&lt;p&gt;İş planlanması ile ilgili olan bir problem. Girdi olarak son teslim tarihine ve kazanç bilgilerine sahip olan işler veriliyor. En büyük kazancı nasıl elde edebileceğimizi bulmamız gerekiyor.&lt;/p&gt;
&lt;p&gt;Örnek olarak ;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;JobID&lt;/span&gt;    &lt;span class="n"&gt;Son&lt;/span&gt; &lt;span class="n"&gt;Tarih&lt;/span&gt;     &lt;span class="n"&gt;Kazanç&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;        &lt;span class="mi"&gt;4&lt;/span&gt;            &lt;span class="mi"&gt;20&lt;/span&gt;   
    &lt;span class="n"&gt;b&lt;/span&gt;        &lt;span class="mi"&gt;1&lt;/span&gt;            &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt;        &lt;span class="mi"&gt;1&lt;/span&gt;            &lt;span class="mi"&gt;40&lt;/span&gt;  
    &lt;span class="n"&gt;d&lt;/span&gt;        &lt;span class="mi"&gt;1&lt;/span&gt;            &lt;span class="mi"&gt;30&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;   


&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
   &lt;span class="n"&gt;JobID&lt;/span&gt;     &lt;span class="n"&gt;Son&lt;/span&gt; &lt;span class="n"&gt;Tarih&lt;/span&gt;     &lt;span class="n"&gt;Kazanç&lt;/span&gt;
     &lt;span class="n"&gt;a&lt;/span&gt;         &lt;span class="mi"&gt;2&lt;/span&gt;           &lt;span class="mi"&gt;100&lt;/span&gt;
     &lt;span class="n"&gt;b&lt;/span&gt;         &lt;span class="mi"&gt;1&lt;/span&gt;           &lt;span class="mi"&gt;19&lt;/span&gt;
     &lt;span class="n"&gt;c&lt;/span&gt;         &lt;span class="mi"&gt;2&lt;/span&gt;           &lt;span class="mi"&gt;27&lt;/span&gt;
     &lt;span class="n"&gt;d&lt;/span&gt;         &lt;span class="mi"&gt;1&lt;/span&gt;           &lt;span class="mi"&gt;25&lt;/span&gt;
     &lt;span class="n"&gt;e&lt;/span&gt;         &lt;span class="mi"&gt;3&lt;/span&gt;           &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Greedy yaklaşımı ile şu şekilde çözebiliriz.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Tüm işleri azalan kazanç oranlarına göre sırala&lt;/li&gt;
&lt;li&gt;İlk iş başlangıcın olsun&lt;/li&gt;
&lt;li&gt;Geriye kalan n-1 iş için&lt;ol&gt;
&lt;li&gt;Eğer şuanki iş zaman aşımına uğramadan sonuç listesine sığabiliyorsa elindeki işi sonuç dizisine ekle, aksi halde şuanki işi es geç.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Çözüm aşağıdaki gibi olacaktır.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def print_job_scheduling(jobs):
    jobs.sort(key=lambda x: x[2], reverse=True)
    result, slot = [None] * len(jobs), [False] * len(jobs)
    for job in jobs:
        j = min(len(jobs), job[1]) - 1
        while j &amp;gt;= 0:
            if not slot[j]:
                result[j] = job[0]
                slot[j] = True
                break
            j -= 1

    print(result, sep=&amp;#39;\n&amp;#39;)

if __name__ == &amp;#39;__main__&amp;#39;:
    # (id,zaman aşımı,kazanç)
    jobs = [(&amp;#39;a&amp;#39;, 2, 100), (&amp;#39;b&amp;#39;, 1, 19),
            (&amp;#39;c&amp;#39;, 2, 27), (&amp;#39;d&amp;#39;, 1, 25), (&amp;#39;e&amp;#39;, 3, 15)]
    print_job_scheduling(jobs)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Bu algoritmanın zaman karmaşıklığı &lt;code&gt;O(n^2)&lt;/code&gt; olacaktır.Union-find veri yapısı kullanılarak &lt;code&gt;O(n)&lt;/code&gt; gibi bir karmaşıklıkta çözülebilir.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sun, 11 Oct 2015 12:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-11:blog/is-planlama/</guid><category>algorithm</category><category>greedy</category></item><item><title>Etkinlik paylaşım problemi - Greedy Yaklaşımı</title><link>http://localhost:8000/blog/etkinlik-secim-problemi/</link><description>&lt;p&gt;Etkinlik paylaşım problemi klasik bir açgözlü(greedy) yaklaşımı ile çözülen bir problemdir.Greedy kısaca parça parça çözüme ulaşılan ve her bir aşamada o anki en optimum seçeneği seçemedir.&lt;/p&gt;
&lt;p&gt;Eğer bir problemi Greedy yaklaşımı ile çözebiliyorsak muhtemelen o problemin çözümü diğer çözüm yöntemlerine göre en optimum çözüm olacaktır fakat her durumda uygulanamaz.&lt;/p&gt;
&lt;p&gt;Şimdi probleme gelelim, size n adet aktivite ve her aktivitenin başlangıç ve bitiş süreleri veriliyor.Sizden tek bir kişinin yapabileceği en fazla sayıda aktivite gerçekleştirmesi isteniyor.&lt;/p&gt;
&lt;p&gt;Örneğin;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;etkinlikler  =  0   1  2  3  4  5
             - - - - - - - - - - - -
başlangıç[]  =  {1, 3, 0, 5, 8, 5};
bitiş[]      =  {2, 4, 6, 7, 9, 9};
Cevap = {0,1,3,4}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;İlk bitecek aktiviteleri aradan çıkarırsak sonuca ulaşabiliriz.Bunun için yapılması gerekenler;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Aktiviteleri bitiş zamanlarına göre sıralamalıyız&lt;/li&gt;
&lt;li&gt;Sıralanmış aktivitelerden ilkini almalıyız.&lt;/li&gt;
&lt;li&gt;Geriye kalan aktivitelerin başlangıç zamanı ile seçilen aktivitenin bitiş zamanı karşılaştırılmalı&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Çözüme ait kod aşağıdaki gibi olur.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def print_max_activities(activities):
    choise,activities = activities[0],activities[1:]
    print(choise)
    for i in activities:
        if i[0] &amp;gt;= choise[1]:
            choise = i
            print(choise)

if __name__ == &amp;#39;__main__&amp;#39;:
    #[(start,finish)]
    activities = [(1,2),(3,4),(0,6),(5,7),(8,9),(5,9)]
    activities.sort(key=lambda x : x[1]) #Bitişe göre sıralama
    print_max_activities(activities)
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sun, 11 Oct 2015 10:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-11:blog/etkinlik-secim-problemi/</guid><category>algorithm</category><category>greedy</category></item><item><title>Üs alma işlemi (a^x) - Divide and Conquer</title><link>http://localhost:8000/blog/pow-daq/</link><description>&lt;p&gt;Üs alma işlemi kullanılan programlama dilinin standart olarak verdiği işlemler ile gayet kolay olarak yapılabilen bir işlemdir.En basit hali ile çözüm şu şekildedir.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def brute(num, x):
    result = 1
    for i in range(x):
        result *= num
    return result
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Bu çözüm iteratif olarak yazılmış ve &lt;code&gt;O(n)&lt;/code&gt; karmaşıklığına sahip hoş olmayan bir çözümdür. Şimdi bu çözümü &lt;code&gt;Divide and Conquer&lt;/code&gt; mantığına uygun bir çözüm ile yazalım.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def div_conq(num, x):
    if x == 0:
        return 1
    elif x % 2 == 0:
        return div_conq(num, x / 2) * div_conq(num, x / 2)
    else
        return num * div_conq(num, x / 2) * div_conq(num, x / 2)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Çözümü divide and conquer mantığına göre çözsekte karmaşıklıkta hala değişiklik olmadı ve zaman karmaşıklığımız &lt;code&gt;O(n)&lt;/code&gt;. Biraz dikkat ederseniz gereksiz tekrarlar olduğunu fark edebilirsiniz. Bunları önlemek için aşağıdaki gibi bir yol izleyebiliriz.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def div_conq(num, x):
    if x == 0:
        return 1
    temp = div_conq(num, x / 2)
    if x % 2 == 0:
        return temp * temp
    else:
        return num * temp * temp
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Artık karmaşıklığımız &lt;code&gt;O(logn)&lt;/code&gt; olmuştur. Fakat yazdığımız kod negatif sayısal için çalışmayacaktır. Ufak bir ekleme ile şu hale getirebilriz.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def div_conq(num, x):
    if x == 0:
        return 1
    temp = div_conq(num, x / 2)
    if x % 2 == 0:
        return temp * temp
    else:
        if(x &amp;gt; 0):
            return num*temp*temp;
        else:
            return (temp*temp)/num;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sun, 11 Oct 2015 08:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-11:blog/pow-daq/</guid><category>algorithm</category><category>divide and conquer</category></item><item><title>Neredeyse sıralı dizi içerisinde arama - Arama Algoritması</title><link>http://localhost:8000/blog/almost-sorted-search/</link><description>&lt;p&gt;Ufak bir işlem sonrası sıralanmış dizinin bazı elemanlarının yerleri karıştırılıyor. Örneğin &lt;code&gt;i.&lt;/code&gt; pozisyonda olması gereken eleman &lt;code&gt;i-1&lt;/code&gt; ya da &lt;code&gt;i+1&lt;/code&gt; pozisyonunda bulunuyor. Hedef olarak verilen sayının dizi içerisindeki pozisyonunun bulunması amaçlanıyor.&lt;/p&gt;
&lt;p&gt;Örneğin;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;70&lt;/span&gt;&lt;span class="o"&gt;},&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;

&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;70&lt;/span&gt;&lt;span class="o"&gt;},&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;90&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Klasik olarak en ilkel çözüm, tüm diziyi boydan boya aramaktır. &lt;code&gt;O(n)&lt;/code&gt; karmaşıklığa sahiptir.&lt;/p&gt;
&lt;p&gt;Bu çözümde ise sıralı diziler üzerinde uygulanan algoritmalardan olan &lt;code&gt;binary search&lt;/code&gt; algoritmasının biraz daha modifiye edilmiş halini kullanacağız.&lt;/p&gt;
&lt;p&gt;Fikir olarak şuna dayanmaktadır; elimizdeki değeri ortandaki üç eleman ile karşılaştıracağız. Geri mantık &lt;code&gt;binary search&lt;/code&gt; algoritması gibidir.&lt;/p&gt;
&lt;p&gt;Çözüm aşağıdadır.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def mod_binary_search(arr, l, r, x):
    &amp;#39;&amp;#39;&amp;#39;Modifiye edilmiş binary search&amp;#39;&amp;#39;&amp;#39;
    if r &amp;gt;= l:
        mid = l + (r - l) // 2

        # orta 3 eleman ile karşılaştırma
        if arr[mid] == x:
            return mid
        if mid &amp;gt; l and arr[mid - 1] == x:
            return mid - 1
        if mid &amp;lt; r and arr[mid + 1]:
            return mid + 1

        # Eğer eleman ortancadan küçükse, sola doğru kaydır
        if arr[mid] &amp;gt; x:
            return mod_binary_search(arr, l, mid - 2, x)
        # Aksi halde sağa doğru kaydır
        return mod_binary_search(arr, mid + 2, r, x)
    # Bulunamadı
    return -1

if __name__ == &amp;#39;__main__&amp;#39;:
    arr = [3, 2, 10, 4, 40]
    target = 4
    result = mod_binary_search(arr, 0, len(arr) - 1, target)
    if result != -1:
        print(result)
    else:
        print(&amp;quot;bulunamadi&amp;quot;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Algoritmanın karmaşıklığı &lt;code&gt;O(logn)&lt;/code&gt; olur.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sat, 10 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-10:blog/almost-sorted-search/</guid><category>algorithm</category><category>searching</category></item><item><title>Girilen sayıdan bir sonraki büyük sayıyı bulma - Matematik Problemi</title><link>http://localhost:8000/blog/next-num/</link><description>&lt;p&gt;String olarak verilen sayının bir sonraki büyük saıyı ekrana bastıran, eğer şartlar uygun değilse imkansız yazan problemi inceleyeceğiz.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;218765&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;251678&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;1234&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;1243&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;4321&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Imkansız&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;534976&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;536479&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Çözüm için;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Eğer tüm sayılar azalan sırada ise 'Imkansız' basılır.&lt;/li&gt;
&lt;li&gt;Eğer tüm sayılar artan sırada ise son iki sayı ver değiştirecektir.&lt;/li&gt;
&lt;li&gt;Diğer sayılar için&lt;ol&gt;
&lt;li&gt;Sayının birler basamağından başlanarak diğer haneleri incelenir. Birber basamağından daha değerli basamaklara doğru artışı bozacak hane aranır. Örneğin “534976” sayısı için &lt;code&gt;4&lt;/code&gt; olan basamak bu durumu sağlar.(6&amp;lt;7&amp;lt;9)&lt;/li&gt;
&lt;li&gt;Sayı 53,4,976 şeklinde bölünür ve 4'ün sağ tarafında kalan sayılardan 4'den büyük olan en küçük sayı bulunur(6'dır).&lt;/li&gt;
&lt;li&gt;4 ve 6 yer değişir("53,6,974" olur).&lt;/li&gt;
&lt;li&gt;"974" olan kısım sıralanır ve son olarak cevap "536479" olur.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Çözüm aşağıdaki gibi olacaktır.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def find_next(num):
    for i in range(len(num) - 1, 0, -1):
        if num[i] &amp;gt; num[i - 1]:
            break

    if i - 1 == 0:
        print(&amp;quot;Imkansiz&amp;quot;)
        return

    x, smallest = num[i - 1], i
    for j in range(i + 1, len(num)):
        if num[j] &amp;gt; x and num[j] &amp;lt; num[smallest]:
            smallest = j

    num = list(num)
    num[smallest], num[i - 1] = num[i - 1], num[smallest]

    num[i:] = sorted(num[i:])
    print(&amp;#39;&amp;#39;.join(num))

if __name__ == &amp;#39;__main__&amp;#39;:
    find_next(&amp;quot;534976&amp;quot;)
    find_next(&amp;quot;4321&amp;quot;)
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Thu, 08 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-08:blog/next-num/</guid><category>algorithm</category><category>mathematical</category></item><item><title>KMP Algoritmasi - String Algoritmaları</title><link>http://localhost:8000/blog/kmp/</link><description>&lt;p&gt;Bir diğer string arama algoritmalarından olan &lt;code&gt;KMP&lt;/code&gt; algoritmasına bakacağız.&lt;/p&gt;
&lt;p&gt;Örnek olarak;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;txt =  &amp;quot;THIS IS A TEST TEXT&amp;quot;
pat = &amp;quot;TEST&amp;quot;
Output : 10
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ve&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;txt =  &amp;quot;AABAACAADAABAAABAA&amp;quot;
pat = &amp;quot;AABA&amp;quot;
Output : 0, 9, 13
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Bir önceki &lt;a href="http://localhost:8000/blog/naive-search-string/"&gt;yazıda&lt;/a&gt; en kaba hali ile bir text içerisinde nasıl başka bir text aramasının yapılacağını incelemiştik. O algoritma &lt;code&gt;O(m*(n-m+1))&lt;/code&gt; karmaşıklığa sahipti. Bu algoritmanın en kötü durumda karmaşıklığı &lt;code&gt;O(n)&lt;/code&gt;'dir.&lt;/p&gt;
&lt;h3 id="kmp-knuth-morris-pratt"&gt;KMP (Knuth Morris Pratt)&lt;/h3&gt;
&lt;p&gt;Kısaca yapılan iş şu şekilde yürümektedir. Ne zaman bir eşleşmeme duruöu olursa, elimizde daha önce elde ettiğimiz bilgileri kullanarak, deseni kaydırma ve benzetme işlemi yaparız. Dolayısı ile gereksiz karşılaştırmadan kaçtığımız için zaman karmaşıklığından kazanmış oluruz.&lt;/p&gt;
&lt;p&gt;LPS için aşağıdaki örnelere bakın.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; “AABAACAABAA”, lps = [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]
 “ABCDE”, lps = [0, 0, 0, 0, 0]
 “AAAAA”, lps = [0, 1, 2, 3, 4]
 “AAABAAA”, lps = [0, 1, 2, 0, 1, 2, 3]
 “AAACAAAAAC”, lps = [0, 1, 2, 0, 1, 2, 3, 3, 3, 4]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;İşleyiş aşağıdaki kod ile daha iyi anlaşılacaktır.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; def KMP_search(text, pattern):
     lps = compute_lps_array(pattern)
     m, n, j = len(pattern), len(text), 0
     i = 0  # text indeksi
     while i &amp;lt; n:
         if pattern[j] == text[i]:
             i, j = i + 1, j + 1
         if j == m:
             print(i - j)
             j = lps[j - 1]
         elif i &amp;lt; n and pattern[j] != text[i]:
             # j eşleşme sonrası eşleşmeme
             if j != 0:
                 j = lps[j - 1]
             else:
                 i += 1


 def compute_lps_array(pattern):
     lps = [0] * len(pattern)
     # len_sp = son en uzun prefix suffix uzunluğu
     len_sp, i, len_pattern = 0, 1, len(pattern)

     while i &amp;lt; len_pattern:
         if pattern[i] == pattern[len_sp]:
             len_sp += 1
             lps[i] = len_sp
             i += 1
         elif len_sp != 0:
             len_sp = lps[len_sp - 1]
         else:  # len_sp == 0
             lps[i] = 0
             i += 1

     return lps

 if __name__ == &amp;#39;__main__&amp;#39;:
     text = &amp;quot;ABABDABACDABABCABAB&amp;quot;
     pattern = &amp;quot;ABABCABAB&amp;quot;
     KMP_search(text, pattern)
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Wed, 07 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-07:blog/kmp/</guid><category>algorithm</category><category>string</category><category>searching</category></item><item><title>Sıralı dizi içerisinde hedef sayıya en yakın k sayı - Arama Algoritması</title><link>http://localhost:8000/blog/search-k-closest/</link><description>&lt;p&gt;Sıralı olarak verilen bir dizi içerisinde, hedef olarak belirtilen sayıya en yakın(eşit değil) k tane elemanı elde etmeye yarayan problemdir.&lt;/p&gt;
&lt;p&gt;Problemin basit olarak çözümü, k tane elemanın bulunması için diziyi lineer olarak aramaktan geçer.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;İlk elemandan başlayarak geçit alanına kadar gel(Geçit alanı: Sonraki elemanın büyük, üzerinde bulunan elemanın küçük veya eşit olduğu nokta). Karmaşıklık O(n)'dir.&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;adımda bulunan noktanın her iki tarafını karşılaştırarak ekrana k tane eleman ver. Bu adım da O(k) zaman alır.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Genel olarak bu çözüm O(n) zaman alır.&lt;/p&gt;
&lt;p&gt;Şimdi daha optimize ve O(logn + k) zaman alan bir çözümü inceleyelim. Bu çözüm aslında yukarıdaki çözüme benziyor fakat geçit bölgesini binary search algoritması ile buluyoruz(Dizi sıralı çünkü).&lt;/p&gt;
&lt;p&gt;Çözüm aşağıdaki gibidir.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def find_cross_point(arr, low, high, x):
    # x tüm elemanlardan büyükse
    if arr[high] &amp;lt;= x:
        return high
    # x tüm elemanlardan küçükse
    if arr[low] &amp;gt; x:
        return low

    # Orta noktayı bulma
    mid = (low + high) // 2

    # X ortanca elemansa
    if arr[mid] &amp;lt;= x and arr[mid + 1] &amp;gt; x:
        return mid

    # x &amp;lt; arr[mid] ve x &amp;lt; arr[mid+1] ise
    if arr[mid] &amp;lt; x:
        return find_cross_point(arr, mid + 1, high, x)

    return find_cross_point(arr, low, mid - 1, x)


def print_closest(arr, x, k):
    l = find_cross_point(arr, 0, len(arr) - 1, x)
    r, count = l + 1, 0

    # Eşit elemanları dikkate alma
    if arr[l] == x:
        l -= 1

    # Geçiş noktasından itibare sağ ve sol kontrolu
    while l &amp;gt;= 0 and r &amp;lt; len(arr) and count &amp;lt; k:
        if x - arr[l] &amp;lt; arr[r] - x:
            print(arr[l])
            l -= 1
        else:
            print(arr[r])
            r += 1
        count += 1

    # Sağ tarafta hiç eleman yoksa sol tarafı yazdır
    while count &amp;lt; k and l &amp;gt;= 0:
        print(arr[l])
        l, count = l - 1, count + 1

    # Sol tarafta hiç eleman yoksa sağ tarafı yazdır
    while count &amp;lt; k and r &amp;lt; len(arr):
        print(arr[r])
        r, count = r + 1, count + 1

if __name__ == &amp;#39;__main__&amp;#39;:
    arr = [12, 16, 22, 30, 35, 39, 42,
           45, 48, 50, 53, 55, 56]
    target, k = 35, 4
    print_closest(arr, target, k)
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Tue, 06 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-06:blog/search-k-closest/</guid><category>algorithm</category><category>searching</category></item><item><title>Hangi sıralama algoritması belleğe en az sayıda yazma yapar?</title><link>http://localhost:8000/blog/which-sorting-min-memory/</link><description>&lt;p&gt;Hafızaya yazma işlemini azaltmak, büyük veri kümeeleri üzerinde uğraşmanın maliyetli olduğu EEPROMs ve ya flash gibi platformlar için kazançlıdır.&lt;/p&gt;
&lt;p&gt;Sıralama algoritmaları arasında &lt;code&gt;Selection Sort&lt;/code&gt; agoritmasının en az sayıda yazma işlemi yaptığını(&lt;code&gt;O(n)&lt;/code&gt;) biliyoruz. Fakat &lt;code&gt;Cycle Sort&lt;/code&gt; neredeyse her zaman &lt;code&gt;Selection Sort&lt;/code&gt; algoritmasına göre daha az sayıda yazma işlemi yapar. Eğer değer doğru noktada ise, o değer için hiç yazma işlemi yapılmaz ve eğer değer doğru noktada değilse bir kez yazma işlemi yapılarak doğru noktaya getirilir.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Mon, 05 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-05:blog/which-sorting-min-memory/</guid><category>algorithm</category><category>sorting</category></item><item><title>K. küçük veya büyük sayısı bulmak - Part 1 - Arama Algoritması</title><link>http://localhost:8000/blog/search-k-largest-or-smalest/</link><description>&lt;p&gt;Bir dizi ve &lt;code&gt;k&lt;/code&gt; sayısı veriliyor(k &amp;lt; len(dizi)). Cevap olarak dizi içerisinde ki k. küçük veya büyük elemanın bulunması hedefleniyor.&lt;/p&gt;
&lt;p&gt;Örneğin;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
       &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;

&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
       &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="cozum-1-basit-cozum"&gt;Çözüm 1 (Basit Çözüm)&lt;/h3&gt;
&lt;p&gt;Akla gelen en basit çözm elimizdeki veri kümesini ihtiyaca göre sıralamak ve k. indeksi çağırmak. Sıralama için kullanılacak en verimli algoritma ortalama &lt;code&gt;O(nlogn)&lt;/code&gt; zaman alacağı için karmaşıklık &lt;code&gt;O(nlogn)&lt;/code&gt; olacaktır.&lt;/p&gt;
&lt;h3 id="cozum-2-min-heap-heapselect"&gt;Çözüm 2 (Min Heap – HeapSelect)&lt;/h3&gt;
&lt;p&gt;Bu problemi &lt;code&gt;O(nlogn)&lt;/code&gt; zaman karma1şıklığından daha iyi bir şekilde çözebiliriz. Kullanacağımız algoritma, heap veri yapısı yardımı ile sonuca ulaşacaktır.&lt;/p&gt;
&lt;p&gt;Çözüm aşağıdaki gibidir.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;MinHeap:&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;__init__&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;arr&lt;/span&gt;):
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt; = &lt;span class="n"&gt;arr&lt;/span&gt;
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; = &lt;span class="n"&gt;len&lt;/span&gt;(&lt;span class="n"&gt;arr&lt;/span&gt;)
        &lt;span class="n"&gt;i&lt;/span&gt; = (&lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;) // &lt;span class="mi"&gt;2&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &amp;gt;= &lt;span class="mi"&gt;0&lt;/span&gt;:
            &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;min_heapify&lt;/span&gt;(&lt;span class="n"&gt;i&lt;/span&gt;)
            &lt;span class="n"&gt;i&lt;/span&gt; -= &lt;span class="mi"&gt;1&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;min_heapify&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;i&lt;/span&gt;):
        &lt;span class="n"&gt;l&lt;/span&gt;, &lt;span class="n"&gt;r&lt;/span&gt;, &lt;span class="n"&gt;smallest&lt;/span&gt; = &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;left&lt;/span&gt;(&lt;span class="n"&gt;i&lt;/span&gt;), &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;right&lt;/span&gt;(&lt;span class="n"&gt;i&lt;/span&gt;), &lt;span class="n"&gt;i&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &amp;lt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;and&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;l&lt;/span&gt;] &amp;lt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;]:
            &lt;span class="n"&gt;smallest&lt;/span&gt; = &lt;span class="n"&gt;l&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &amp;lt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;and&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;r&lt;/span&gt;] &amp;lt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;smallest&lt;/span&gt;]:
            &lt;span class="n"&gt;smallest&lt;/span&gt; = &lt;span class="n"&gt;r&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;smallest&lt;/span&gt; != &lt;span class="n"&gt;i:&lt;/span&gt;
            &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;], &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;smallest&lt;/span&gt;] = &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[
                &lt;span class="n"&gt;smallest&lt;/span&gt;], &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;]
            &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;min_heapify&lt;/span&gt;(&lt;span class="n"&gt;smallest&lt;/span&gt;)

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;extract_min&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;):
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;not&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; -&lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;root&lt;/span&gt; = &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;]
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; &amp;gt; &lt;span class="mi"&gt;1&lt;/span&gt;:
            &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;] = &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;]
            &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;min_heapify&lt;/span&gt;(&lt;span class="mi"&gt;0&lt;/span&gt;)
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; -= &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;i&lt;/span&gt;):
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; * &lt;span class="n"&gt;i&lt;/span&gt; + &lt;span class="mi"&gt;1&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;i&lt;/span&gt;):
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; * &lt;span class="n"&gt;i&lt;/span&gt; + &lt;span class="mi"&gt;2&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;paremt&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;i&lt;/span&gt;):
        &lt;span class="k"&gt;return&lt;/span&gt; (&lt;span class="n"&gt;i&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;) // &lt;span class="mi"&gt;2&lt;/span&gt;


&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;kth_smallest&lt;/span&gt;(&lt;span class="n"&gt;arr&lt;/span&gt;, &lt;span class="n"&gt;k&lt;/span&gt;):
    &lt;span class="n"&gt;heap&lt;/span&gt; = &lt;span class="n"&gt;MinHeap&lt;/span&gt;(&lt;span class="n"&gt;arr&lt;/span&gt;)
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;range&lt;/span&gt;(&lt;span class="n"&gt;k&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;):
        &lt;span class="n"&gt;heap&lt;/span&gt;.&lt;span class="n"&gt;extract_min&lt;/span&gt;()
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;]

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; == &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
    &lt;span class="n"&gt;arr&lt;/span&gt; = [&lt;span class="mi"&gt;12&lt;/span&gt;, &lt;span class="mi"&gt;3&lt;/span&gt;, &lt;span class="mi"&gt;5&lt;/span&gt;, &lt;span class="mi"&gt;7&lt;/span&gt;, &lt;span class="mi"&gt;19&lt;/span&gt;]
    &lt;span class="nb"&gt;print&lt;/span&gt;(&lt;span class="n"&gt;kth_smallest&lt;/span&gt;(&lt;span class="n"&gt;arr&lt;/span&gt;, &lt;span class="mi"&gt;2&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Bu algoritmanın karmaşıklığı &lt;code&gt;O(n+klogn)&lt;/code&gt; olacakır.&lt;/p&gt;
&lt;h3 id="cozum-3-max-heap"&gt;Çözüm 3 (Max-Heap)&lt;/h3&gt;
&lt;p&gt;Çözüm 2'deki gibi, bu sefer max-heap ile problemi çözebiliriz.Karmaşıklık &lt;code&gt;O(k + (n-k)*logk)&lt;/code&gt; olacaktır.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;MaxHeap:&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;__init__&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;arr&lt;/span&gt;):
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt; = &lt;span class="n"&gt;arr&lt;/span&gt;
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; = &lt;span class="n"&gt;len&lt;/span&gt;(&lt;span class="n"&gt;arr&lt;/span&gt;)
        &lt;span class="n"&gt;i&lt;/span&gt; = (&lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;) // &lt;span class="mi"&gt;2&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &amp;gt;= &lt;span class="mi"&gt;0&lt;/span&gt;:
            &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;max_heapify&lt;/span&gt;(&lt;span class="n"&gt;i&lt;/span&gt;)
            &lt;span class="n"&gt;i&lt;/span&gt; -= &lt;span class="mi"&gt;1&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;max_heapify&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;i&lt;/span&gt;):
        &lt;span class="n"&gt;l&lt;/span&gt;, &lt;span class="n"&gt;r&lt;/span&gt;, &lt;span class="n"&gt;largest&lt;/span&gt; = &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;left&lt;/span&gt;(&lt;span class="n"&gt;i&lt;/span&gt;), &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;right&lt;/span&gt;(&lt;span class="n"&gt;i&lt;/span&gt;), &lt;span class="n"&gt;i&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &amp;lt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;and&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;l&lt;/span&gt;] &amp;gt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;]:
            &lt;span class="n"&gt;largest&lt;/span&gt; = &lt;span class="n"&gt;l&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &amp;lt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;and&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;r&lt;/span&gt;] &amp;gt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;largest&lt;/span&gt;]:
            &lt;span class="n"&gt;largest&lt;/span&gt; = &lt;span class="n"&gt;r&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;largest&lt;/span&gt; != &lt;span class="n"&gt;i:&lt;/span&gt;
            &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;], &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;largest&lt;/span&gt;] = &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[
                &lt;span class="n"&gt;largest&lt;/span&gt;], &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;]
            &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;max_heapify&lt;/span&gt;(&lt;span class="n"&gt;largest&lt;/span&gt;)

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;extract_max&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;):
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;not&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; -&lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;root&lt;/span&gt; = &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;]
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; &amp;gt; &lt;span class="mi"&gt;1&lt;/span&gt;:
            &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;] = &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;]
            &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;max_heapify&lt;/span&gt;(&lt;span class="mi"&gt;0&lt;/span&gt;)
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;heap_size&lt;/span&gt; -= &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;i&lt;/span&gt;):
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; * &lt;span class="n"&gt;i&lt;/span&gt; + &lt;span class="mi"&gt;1&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;i&lt;/span&gt;):
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; * &lt;span class="n"&gt;i&lt;/span&gt; + &lt;span class="mi"&gt;2&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;paremt&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;i&lt;/span&gt;):
        &lt;span class="k"&gt;return&lt;/span&gt; (&lt;span class="n"&gt;i&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;) // &lt;span class="mi"&gt;2&lt;/span&gt;


&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;kth_smallest&lt;/span&gt;(&lt;span class="n"&gt;arr&lt;/span&gt;, &lt;span class="n"&gt;k&lt;/span&gt;):
    &lt;span class="n"&gt;heap&lt;/span&gt; = &lt;span class="n"&gt;MaxHeap&lt;/span&gt;(&lt;span class="n"&gt;arr&lt;/span&gt;)
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;range&lt;/span&gt;(&lt;span class="n"&gt;len&lt;/span&gt;(&lt;span class="n"&gt;arr&lt;/span&gt;) - &lt;span class="n"&gt;k&lt;/span&gt;):
        &lt;span class="n"&gt;heap&lt;/span&gt;.&lt;span class="n"&gt;extract_max&lt;/span&gt;()
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;.&lt;span class="n"&gt;harr&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;]

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; == &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
    &lt;span class="n"&gt;arr&lt;/span&gt; = [&lt;span class="mi"&gt;12&lt;/span&gt;, &lt;span class="mi"&gt;3&lt;/span&gt;, &lt;span class="mi"&gt;5&lt;/span&gt;, &lt;span class="mi"&gt;7&lt;/span&gt;, &lt;span class="mi"&gt;19&lt;/span&gt;]
    &lt;span class="nb"&gt;print&lt;/span&gt;(&lt;span class="n"&gt;kth_smallest&lt;/span&gt;(&lt;span class="n"&gt;arr&lt;/span&gt;, &lt;span class="mi"&gt;2&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="cozum-4-quickselect"&gt;Çözüm 4 (QuickSelect)&lt;/h3&gt;
&lt;p&gt;Bu çözüm, çözüm 1 de bahsedilen yöntemin optimize edilmiş halini yansıtmaktadır.Quick sort algoritmasının modifiye edilmesi ile elde edilmiştir. Pivot eleman seçeceğiz, bunu doğru pozisyona yerleştireceğiz ve etrafını parçalayacaız. En kötü durumda karmaşıklık &lt;code&gt;O(n^2)&lt;/code&gt;, fakat ortalama durumda &lt;code&gt;O(n)&lt;/code&gt; olacaktır.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;math&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;inf&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;kth_smallest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;kth_smallest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;kth_smallest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;inf&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;arr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kth_smallest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sun, 04 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-04:blog/search-k-largest-or-smalest/</guid><category>algorithm</category><category>searching</category></item><item><title>Sıralama algoritmalarında kararlılık nedir?</title><link>http://localhost:8000/blog/stability-sorting/</link><description>&lt;p&gt;Sıralama algoritmalarında bazen kararlılık ile ilgili bir takım bilgiler görürüz.Kısaca açıklamak gerekirse, sırarısz bir dizide aynı değerlere sahip elemanların dizilişi, dizi sıralandığında da korunuyorsa algoritma kararlıdır.&lt;/p&gt;
&lt;p&gt;Kararlı özelliğine sahip algoritmalar; Insertion sort, Merge sort, Bubble sort. Kararsız olanlar; Heap sort, Quick sort.&lt;/p&gt;
&lt;p&gt;Ancak verilen kararlı olmayan aloritmalar kolayca kararlı hale getirelebilirler.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sat, 03 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-03:blog/stability-sorting/</guid><category>algorithm</category><category>sorting</category></item><item><title>Quick sort için en kötü durum nedir?</title><link>http://localhost:8000/blog/worstcase-quicksort/</link><description>&lt;p&gt;Quick sort ortalama zamanda çalıştığında en verimli çalışan ve en çok kullanılan algoritmalardan biridir. Pivot seçiminin ne kadar önemli olduğunu algoritmayı incelediğinizde göreceksiniz.&lt;/p&gt;
&lt;p&gt;En kötü duruma sebebiyet veren şartlar aşağıdadır.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dizi zaten aynı yönde sıralıysa.&lt;/li&gt;
&lt;li&gt;Dizi ters yönde sıralıysa.&lt;/li&gt;
&lt;li&gt;Tüm elemanlar aynıysa&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sat, 03 Oct 2015 18:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-10-03:blog/worstcase-quicksort/</guid><category>algorithm</category><category>sorting</category></item><item><title>Apache Spark - Part 1 : Tanıtım</title><link>http://localhost:8000/blog/apache-spark-part1/</link><description>&lt;p&gt;Apache Spark,büyük veri işleme amacı ile oluşturulmuş bir Apache projesidir.Scala dili ile yazılmış JVM üzerinde çalışan ve Python, Java, Scala kullanımına olanak sağlayan, "in-memory" yani veriyi bellek içerisinde işleme özelliği ile ön plana çıkan bir projedir.&lt;/p&gt;
&lt;p&gt;Eğer isterseniz kaynak kodları görüntülemek için aşağıdaki adrese göz atabilirsiniz.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/apache/spark"&gt;https://github.com/apache/spark&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="kurulum"&gt;&lt;em&gt;Kurulum&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://spark.apache.org/downloads.html"&gt;http://spark.apache.org/downloads.html&lt;/a&gt; adresinden “Pre-built for Hadoop 2.6 and later” seçeneği seçilerek son sürümünü indirebilirsiniz.İndirme tamamlandıktan sonra indirilen yere geçirelerek,&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tar -xzvf spark-1.4.0-bin-hadoop2.6.tgz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd spark-1.4.0-bin-hadoop2.6&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ls&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;komutları yürütülür.Son komuttan sonra sergilenen dosyaları kısaca şu şekilde açıklayabiliriz.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;README.md&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Spark ile ilgili kısa açıklamalar ve hızlı başlangıç&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bin&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Çalıştırılabilir dosyalar(shell gibi)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;core,streaming,Python..&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Spark projesinin kaynak kodları&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;examples&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Örnekler&lt;/code&gt;&lt;/p&gt;
&lt;h1 id="tantm"&gt;&lt;em&gt;Tanıtım&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;Yazının devamında Spark'ı yerel modda çalıştırarak kısa bir kaç örnek yapalım.Ben Python kullanıyor olacağım eğer siz tercih ederseniz Scala veya Java kullanabilirsiniz fakat Java hakkında bahsetmek istediğim bir nokta var eğer Java 8 ile birlikte gelen özellikleri kullanmazsanız nispeten biraz okuması zor bir kod çıkabilir ortaya fakat performanstan bir kaybınız olmaz.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;İnteraktif Python Shell&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;./bin/pyspark&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;İnteraktif Scala Shell&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;./bin/spark-shell&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Python shell için yukarıdaki komutu çalıştırdıktan sonra şu şekilde bir görüntü elde ediyorum.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src="/images/apache_spark/1/1.png" height = 240px width = 400px&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Eğer konsola düşen "INFO" loglarını gizlemek isterseniz.Şunu yapabilirsiniz.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"conf/log4j.properties.template"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;dosyasının bir kopyasını alın ve&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"conf/log4j.properties"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ismini verin.Daha sonra bu kopya dosya içerisindeki "log4j.rootCategory=INFO, console" satırını "log4j.rootCategory=WARN, console" ile değiştirin.Artık INFO loglarını görmeyeceksiniz.&lt;/p&gt;
&lt;p&gt;Devam edelim,interaktif Python Shell açtıktan sonra&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; lines = sc.textFile(&amp;quot;README.md&amp;quot;)
&amp;gt;&amp;gt;&amp;gt; type(lines)
&amp;lt;class &amp;#39;pyspark.rdd.RDD&amp;#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; lines.count()
98
&amp;gt;&amp;gt;&amp;gt; lines.first()
&amp;#39;# Apache Spark&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;gibi bir örnek ile test edelim.Yukarıdada göreceğiniz gibi &lt;em&gt;lines&lt;/em&gt; adı ile kullandığımız değişkten bir RDD objesidir ve yerel makinemizde bulunan bir text dosyasından oluşturulmuştur.RDD hakkında ileriki yazılarımda daha fazla detay vereceğim.&lt;/p&gt;
&lt;p&gt;Yukarıdaki örnekte birde &lt;em&gt;sc&lt;/em&gt; objesi kullandık.Bu obje sayesinde Spark ile iletişim kurulur.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; sc
&amp;lt;pyspark.context.SparkContext object at 0x7f9b3e856e48&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Spark aşağıdaki görseldeki gibi çalışır.
&lt;center&gt;
&lt;img alt="workflow" src="/images/apache_spark/1/2.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Şimdi de bu uygulamamızda &lt;em&gt;filter&lt;/em&gt; kullanarak içerisinde "Python" geçen satırları veren bir örnek yapalım.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; lines = sc.textFile(&amp;quot;README.md&amp;quot;)
&amp;gt;&amp;gt;&amp;gt; pythonLines = lines.filter(lambda line : &amp;#39;Python&amp;#39; in line)
&amp;gt;&amp;gt;&amp;gt; type(pythonLines)
&amp;lt;class &amp;#39;pyspark.rdd.PipelinedRDD&amp;#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; pythonLines.count()
3
&amp;gt;&amp;gt;&amp;gt; pythonLines.first()
&amp;#39;high-level APIs in Scala, Java, and Python, and an optimized engine that&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Gibi bir çıktı alırız.Eğer Python'da lambda fonksiyonlara alışık değilseniz ya da kullanmak istemezseniz yukarıda kullandığımız &lt;em&gt;filter()&lt;/em&gt; methoduna kendi oluşturduğunuz methodu da aktarabilirsiniz.Örnek;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; def hasPython(line):
...     return &amp;#39;Python&amp;#39; in line
...
&amp;gt;&amp;gt;&amp;gt; pythonLines = lines.filter(hasPython)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;gibi bir kullanım geçerleyebilirsiniz.&lt;/p&gt;
&lt;p&gt;İnteraktif shell kullanışlı olsa da her zaman kullanamayız.Bazen bağımsız uygulamalar yazmamız gerekmektedir.Yazılan kodları yürütmek için indirdiğimiz Spark klasöründeyken &lt;code&gt;./bin/pyspark benim_script.py&lt;/code&gt; komutunu yürütmek zorundayız.Bunun yerine aşağıdaki yolları izleyerek işimizi biraz daha kolaylaştıralım.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd ~
nano .bashrc
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ve aşağıdaki satırları düzenleyip dosyamıza ekleyelim.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;export SPARK_HOME= 'Spark dosyası uzantısı'&lt;/p&gt;
&lt;p&gt;export PYTHONPATH=$SPARK_HOME/python/:$PYTHONPATH&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;. .bashrc
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;PySpark'ın &lt;code&gt;py4j&lt;/code&gt; adlı pakete bağımlılığı vardır.Bu paket Python yorumlayıcısının dinamik bir şekilde Spark ile haberleşmesini sağlar.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install py4j&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Yazdığımız kodları artık
&lt;code&gt;./bin/spark-submit &amp;lt;python_file.py&amp;gt;&lt;/code&gt;
yerine direk olarak
&lt;code&gt;python &amp;lt;python_file.py&amp;gt;&lt;/code&gt; şeklinde çalıştırabileceğiz.&lt;/p&gt;
&lt;p&gt;Bundan sonra kod yazarken yapmamız gereken tek şey &lt;em&gt;SparkContext&lt;/em&gt; objemizi oluşturmaktır,geri kalan kısımlar aynıdır.&lt;/p&gt;
&lt;p&gt;Yazımın başında Python kullandığımı söylemiştim fakat siz Scala veya Java kullanıyorsanuz bağımsız uygulamalar yazarken Maven kullanmanızı öneririm.Maven kullanımı ile ilgili resmi dökümanlara bakarak yardım alabilirsiniz.&lt;/p&gt;
&lt;p&gt;Yazılan uygulamanın Spark ile iletişim kurabilmesi için Spark paketlerini dahil etmeli ve &lt;em&gt;SparkContext&lt;/em&gt; nesnesini yaratmalıyız.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyspark&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;SparkConf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;
&lt;span class="n"&gt;conf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SparkConf&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setMaster&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;local&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setAppName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;My App&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;conf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;conf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yazdığımız script'i
&lt;code&gt;python benim_script.py&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;şeklinde çalıştırabilirsiniz.&lt;/p&gt;
&lt;p&gt;Bu örnek ile basit olarak &lt;em&gt;SparkContext&lt;/em&gt; oluşturmayı gördük.Aktarılan iki parametre sırası ile;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cluster URL , bu örnekte "local" olmasının sebebi Spark'ı tek bir makinede ve tek bir thread üzerinde çalıştırdığımız içindir.&lt;/li&gt;
&lt;li&gt;Uygulama ismi&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Bu parametreler dışında parametreler bulunmaktadır,ileride daha ayrıntılı inceliyor olacağız.&lt;/p&gt;
&lt;p&gt;Eğer uygulamayı sonlandırmak isterseniz SparkContext objesi üzerinden
&lt;strong&gt;stop()&lt;/strong&gt; methodunu çağırabilir veya alışık olduğumuz &lt;strong&gt;sys.exit()&lt;/strong&gt; kullanabilirsiniz.&lt;/p&gt;
&lt;p&gt;Bu kadar kargaşadan sonra sıra "Hello World" uygulamamıza geldi.Bu alanın "Hello World" uygulaması "Word Count" olarak geçer.Basit bir word count uygulaması yazalım.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;operator&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyspark&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;sc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;appName&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;WordCount&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;lines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;textFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;README.md&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;counts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flatMap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; \
                  &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; \
                  &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduceByKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;counts&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;collect&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;: &lt;/span&gt;&lt;span class="si"&gt;%i&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Kod içerisinde yabancı gelen terimleri bir sonraki yazılarda daha ayrıntılı bir biçimde inceliyor olacağız.&lt;/p&gt;
&lt;p&gt;BURAK KÖSE&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sun, 21 Jun 2015 22:00:00 +0300</pubDate><guid isPermaLink="false">tag:localhost:8000,2015-06-21:blog/apache-spark-part1/</guid><category>bigdata</category><category>datasciece</category><category>spark</category><category>python</category></item><item><title>Rastgele Sayı Üretmek</title><link>http://localhost:8000/blog/rastgele-sayi/</link><description>&lt;p&gt;Rastgele yani tesadüfen , tesadüfi olarak , ayırmadan , seçmeden
anlamındadır.Çoğumuz yazdığımız kodu test ederken , oyun programlarken
ve çişitli hesaplamarda kullanırız rastgele sayıları.Günlük hayatta
rastgele kavramı insalar için keyfi olarak kullanılır.Aklınızdan bir
sayı tutup söylersiniz bu bir rastgele işlemidir.Peki gerçekten
böylemidir,bilgisayarlar için de durum bu mudur?&lt;/p&gt;
&lt;p&gt;Hep verilen bir örnek vardır , zar.Zar atma olayı rastgele midir ? Bize
göre evet fakat matematikte durum böyle değildir.Zarın hangi sayı
gelmesi bir çok etkene bağlıdır.Bunlar sürtünme,ağırlık,yerçekimi,hız vs
gibi.Dolayısı ile gelecek sayının ne olduğu kestirilemediği için
rastgele denilir.&lt;/p&gt;
&lt;p&gt;Biraz daha zorlayalım , mesela aklınzdan bir sayı tutup söyleme
gerçekten de rastgele midir ? Değildir. Çok hızlı karar verdiğimiz için
nasıl seçtiğimizi pek anlayamayız.Aslında bizim söyleyeceğimiz sayınında
etkenleri vardır.Örneğin favori sayımız , söylenecek sayının
sınırlandırılması gibi.&lt;/p&gt;
&lt;p&gt;Uygulamamızda rastgele sayı elde etmek için çeşitli kütüphaneler ,
metodlar bulunur.Peki bunlar nasıl rastgele sayı üretiyorlar.Şimdi bir
kaç rastgele sayı üretme algoritmasına bakalım.&lt;/p&gt;
&lt;p&gt;&lt;span style="color: #ff6600;"&gt;&lt;strong&gt;1# Orta kare yöntemi ( 4r )&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Bu algoritma &lt;a href="https://tr.wikipedia.org/wiki/John_von_Neumann"&gt;John von
Neumann&lt;/a&gt; ve ekip
arkadaşları tarafından ortaya atılmıştır.Kabaca şu şekilde gerçekleşir.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1- 4r basamaklı bir sayı seçilir.'r' bir tamsayıdır.&lt;br /&gt;
 2- Sayının sağdan ve soldan 'r' adet basamağı silinir.&lt;br /&gt;
 3- Geriye kalan '2r' basamaklı sayının karesi bulunur fakat 'r'
sayısının tamsayı olması gerektiğini unutmayın.Kare alma işleminden
sonra elimizde tekrar 4r basamaklı bir sayı bulunur.&lt;br /&gt;
 4- Tekrar yeni bir sayı üretilmek istenirse 2. adıma geri dönülür.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bir örnek verelim.Sayımız 81.599.441 olsun.Tamamen salladığım bir sayı.8
basamaklıdır dolayısı ile r = 2 olur.Soldan ve sağdan r = 2 adet sayı
silelim.Yeni sayı 5994 olacaktır.Peki devam edelim 5994\^2 = 35.928.036
olur ve takrar r adet sayı soldan ve sağdan silelim.Yeni sayı 9280
olur.Devam etmek istersek bu böyle devam edecektir.Sayılar soldan
parçalanarak 2 basamaklı rastgele sayılar elde edilir.Örneğin 2
basamaklı rastgele sayılar için kümemiz {81,35} olurken üç basamaklı
sayılar için {815,359} olur.&lt;/p&gt;
&lt;p&gt;Görüldüğü gibi çok pratik olmayan bir yöntemdim ve bazı soruları
vardır.Örneğin başlangıçta alınan 2500 sayısı için 50\^2 = 2500 elde
edilir ve bir çıkmaza girilir&lt;strong&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style="color: #ff6600;"&gt; &lt;/strong&gt;2&lt;strong&gt;#&lt;/span&gt;&lt;/strong&gt; &lt;span
style="color: #ff6600;"&gt;&lt;strong&gt;Lineer Benzerlik Algoritması&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Daha önce C kullanmış olanlar bu algoritma onlara tanıdık gelecektir ve
ilk kez rastgele sayı oluşturan kişilerin genelde bunlar aynı sayılar
şeklinde devam ediyor , bu problem nedir dedikleri olmuştur(En azından
ben bu soruyu sormuştum).&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Derrick_Henry_Lehmer"&gt;D.H Lehmer&lt;/a&gt;
tarafından geliştirilmiş rastgele sayı üretme algoritmasıdır.İlk olarak
s,c,b değişkenleri belirlenir.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;'s' başlangıç noktası&lt;br /&gt;
 'c' çarpım için&lt;br /&gt;
 'b' artış için&lt;br /&gt;
 'm' ise mod işlemi için belirlenen bir değerdir&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Algoritma şu şekilde işler.İlk olarak başlangıç noktası(s) çarpım için
belirlenmiş olan(c) ile çarpılır ve 'b' ile toplanır ve sonuç mod
işlemine alınır(m),ilk rastgele sayı üretilir.Bu işlem üretilen rastgele
sayının tekrar 'c' ile çarpılıp 'b' ile toplanıp 'm' ile modunu alınması
şeklinde devam eder.Örnek;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;s = 10&lt;br /&gt;
 c = 2&lt;br /&gt;
 b = 1&lt;br /&gt;
 m = 5 (Dikkat maksimum sayı 4 olabilir anlamına gelir)&lt;/p&gt;
&lt;p&gt;1.Adım:&lt;br /&gt;
 (s*c + b ) % m yani (10 * 2 + 1) % 5 = 1 olacaktır ve yeni s = 1&lt;br /&gt;
 2.Adım:&lt;br /&gt;
 (1 * 2 + 1) % 5 = 3 olacaktır ve yeni s = 3&lt;br /&gt;
 3.Adım:&lt;br /&gt;
 (3 * 2 + 1) % 5 = 2 olacaktır ve yeni s = 2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;gibi işlemler devam edecektir.3 adımda 3 adet sayı ürettik bunlar
{1,3,2}'dir.Gerçek sayı üretme işlemlerinde bu değerler bu kadar küçük
seçilmezler.&lt;a href="https://tr.wikipedia.org/wiki/Donald_Knuth"&gt;D.E Knuth&lt;/a&gt; ve
&lt;a href="https://en.wikipedia.org/wiki/Harold_Lewis"&gt;H.W. Lewis&lt;/a&gt;tarafından
önerilen değerler ise;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;c = 1664525&lt;br /&gt;
 b = 1013904226&lt;br /&gt;
 m = 2 \^ 32&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Detaylı bilgi için
&lt;a href="http://portals.omg.org/hpec/files/specs/vsipl/random.xhtml"&gt;bakın.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Şimdi gelelim şu C'de yaşanılan probleme.Bilindiği gibi
&lt;a href="http://www.cplusplus.com/reference/cstdlib/rand/"&gt;rand()&lt;/a&gt; fonksiyonu
geriye bir rastgele sayı döndürür fakat geri döndürdüğü sayılar belli
bir süre sonra tekrar ettiği görülür , hatırlarsınız orta karaler
yönteminde de benzer bir çıkmaza giriliyordu.Yani başlangıç için
belirlenen değer zamanla değiştirilmez.Bunun için
&lt;a href="http://www.cplusplus.com/reference/cstdlib/srand/"&gt;srand()&lt;/a&gt; fonksiyonu
kullanılır.Bu ise başlangıç değerini değiştirir.&lt;/p&gt;
&lt;p&gt;&lt;span style="color: #ff6600;"&gt;&lt;strong&gt;3# 147 Algoritması&lt;br /&gt;
&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
İsimden anlaşılacağı gibi 147 sayısı kullanılarak sayı üretilir.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Adım : 0 \&amp;lt; n \&amp;lt; 1 aralığında bir '0,abcdefg' sayısı seçilir.Burada
g = {1,3,7,9} olmak zorundadır.&lt;br /&gt;
 2.Adım : s = n * 147 elde edilir.&lt;br /&gt;
 3.Adım : s sayısından tam sayı kısmı çıkartılır.&lt;br /&gt;
 4.Adım : 2. adıma geri dönülür.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bir örnek verelim.Örneğin n = 0,1234567 olsun. s = 0,1234567 * 147 =
18,1481349 olarak bulunur ve 3. adıma göre s = 18,1481349 - 18 =
0,1481349 olarak güncellendikten sonra işlemler tekrar edilir.&lt;/p&gt;
&lt;p&gt;&lt;span style="color: #ff6600;"&gt;&lt;strong&gt;4# Engel Algoritması&lt;br /&gt;
&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
Bazen yeni bir formul ile karşılaştığımda genelde ilk tepkim bu
insanlar bu hesaplamarı bulurken bu absurd sabitler nereden geliyor diye
kendime soruyorum.Mesela 147 algoritmasında görüldüğü gibi neden 147 ?
Bu algoritmada da bir basit kullanılıyor.Bu seferki sabitimiz 'π'(pi)
ama işin ilginç yanı bu sabiti kullanmak zorunda değiliz.Sadece 1'e
yakın bir sayı olmasın yeter.&lt;/p&gt;
&lt;p&gt;Rastgele sayı üretiminde tahmin edilebilirliğin çok düşük olması
gerektiğinden bahsetmiştik.Bu algoritmada sayılarda ki değişiklikler
belirsizdir.&lt;/p&gt;
&lt;p&gt;Algoritma için tanımlama&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Adım : 0 \&amp;lt;= n \&amp;lt;= 1 koşulunu sağlayan bir sayı seçilir.&lt;br /&gt;
 2.Adım : u = (n + π ) \^ 8 elde edilir ve u'nun tam sayı kısmı atılır
ve n = geriye kalan sayı olur.&lt;br /&gt;
 3.Adım : 2.Adıma geri dönülür.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bir örnek verelim.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;n = 0 alalım.&lt;br /&gt;
 1.Sayı için : u = (0 + π)\^8 = 9450,116981 elde edilir ve n =
9450,116981 - 9450 = 0,116981 olur.&lt;br /&gt;
 2.Sayı için : u = (0,116981 + π)\^8 = 12662,5682884 elde edilir ve n
= 0,5682884 olur.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BURAK KÖSE&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Fri, 05 Dec 2014 05:57:00 +0200</pubDate><guid isPermaLink="false">tag:localhost:8000,2014-12-05:blog/rastgele-sayi/</guid><category>algorithm</category><category>random</category><category>number theory</category></item><item><title>Suffix Tree - String Algoritmaları</title><link>http://localhost:8000/blog/suffix-tree/</link><description>&lt;p&gt;Biyoinformatik'de adı sıkça geçen algoritmalardan olan suffix tree veri
yapısı bir dizgi model(pattern) eşleştirme algoritmasıdır.Örneğin
elinizde uzun bir dizgi olsun ve siz bu dizgi içinde alt dizgiler aramak
ve hatta bu dizgilerden kaç adet bulunduğunu öğrenmek istiyorsunuz.İşte
bu veri yapısı bu işlemleri kolaylaştırmak ile birlikte gayet hızlı
işlem yapmamıza olanak sağlıyor.&lt;/p&gt;
&lt;p&gt;Bu tip bir yöntem kullanmadan ilkel olarak çözüm olarak şunu
yapabilirdik.Ana dizgi içerisinde lineer olarak sırayla karşılaştırma
yapa yapa devam ederek sonuca ulaşabilirdik.Bu bir yöntemdir fakat dizgi
boyutları arttıkça bu işlem çok maliyetli olmaktadır.&lt;/p&gt;
&lt;p&gt;Suffix tree incelemesi yapmadan önce suffix nedir bundan
bahsedelim.Suffix Türkçe'de son ek olarak geçer ve bir dizginin son
ekleri şu şekilde bulunur.Örnek:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;String = burak&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sonekler&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;burak,urak,rak,ak,k&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;olacaktır.Görüldüğü gibi n uzunluğunda bir dizgi n adet suffix
sahibidir.&lt;/p&gt;
&lt;p&gt;Suffix tree oluşturmak için önce ihtiyacımız olan suffixleri bulmamız
gerekmektedir.Yukarıdaki örnekteki gibi suffixler elde edildikten sonra
bunlar uzunluklarına göre sıralanmalıdır.Örneğin&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;String = xabxac&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;için sonekler&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xabxac,abxac,bxac,xac,ac,c&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;olarak elde edilikten sonra sırası ile 1,2,3,4,5,6 numaraları
verilir.Ağaç şu şekilde oluşturulur.Bir başlangıç noktası vardır ve
buradan dallanmalar yapılmaktadır.Önce 1 numara dallanır daha sonra
gelen 2 numaraya ait dizgi ile ortak başlangıç noktaları varsa bu
noktadan itibaren dallanma yapılır eğer yoksa yeni bir dallanma
yapılır.Şimdi adım adım ağacımızı oluşturalım.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style="color: #ff9900;"&gt;#1.Adım&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;
İlk dallanmamızı 1 numaralı suffix ile yapıyoruz.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="1" src="/images/suffix_tree/1.png" /&gt;&lt;br /&gt;
&lt;span style="color: #ff9900;"&gt;&lt;strong&gt;#2.Adım&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
2 numaralı suffix olan "abxac"' için inceleme yapıldığında şuana kadar
başlangıç noktasından itibaren "a" ile başlayan bir dallanma
olmadığından yeni bir dallanma yapılır.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="2" src="/images/suffix_tree/2.png" /&gt;&lt;br /&gt;
&lt;span style="color: #ff9900;"&gt; &lt;strong&gt;#3.Adım&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
3 numaralı suffix "bxac"' için inceleme yapıldığında "b" ile başlayan
bir dallanma olmadığından tekrar başlangıç noktamızdan yeni bir dallanma
yapılır.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="3" src="/images/suffix_tree/3.png" /&gt;&lt;br /&gt;
&lt;span style="color: #ff9900;"&gt; &lt;strong&gt;#4.Adım&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
4 numaralı suffix "xac"' için inceleme yapıldığında bu noktada işin
şekli değişmektedir.Ağaca baktığımızda başlangıç noktasından itibaren
bir "x" ile başlangıç vardır.Hatta bir adım daha arama yaptığımızda
sadece "x" ile değil devam edildiğinde "xa" ile bir başlangıç olan
dallanma vardır(1 numaralı suffix).Dolayısı ile kesişme noktasından bir
dallanma yapılır.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="4" src="/images/suffix_tree/4.png" /&gt;&lt;br /&gt;
&lt;span style="color: #ff9900;"&gt; &lt;strong&gt;#5.Adım&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
5 numaralı suffix "ac" için inceleme yapabilmek için tekrar root
noktasından taramaya başlıyoruz ve ilk olarak "a" başlangıcı
arıyoruz.Görüldüğü gibi en iyi kesişim 2 numaralı suffixtedir.Dolayısı
ile bir kesişim noktası yapıp yeni bir dallanma yaratıyoruz.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="5" src="/images/suffix_tree/5.png" /&gt;&lt;br /&gt;
&lt;span style="color: #ff9900;"&gt; &lt;strong&gt;#6.Adım&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
Ve son olarak sırada 6 numaralı suffix olan "c" için incelemede.Tek
başına bir dallanma yapması gerektiği görülüyor.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="6" src="/images/suffix_tree/6.png" /&gt;&lt;/p&gt;
&lt;p&gt;Ağaç oluşturulmuştur.Şimdi bir arama yapalım,örneğin "xa"  , bu dizgi
içinde geçiyor mu ve geçiyorsa kaç kere geçiyor sorusuna cevap arayalım.&lt;/p&gt;
&lt;p&gt;Ağaca bakmaya root noktasından başlayalım ve "xa" arayalım.Hemen root
noktasının altında "xa" başlangıcı ile karşılaşıldı.Dolayısı ile "xa"
eşlemesi sağlandı ama kaç tane "xa" olduğunu nereden anlayacağız?Kaç
tane "xa" olduğunu bulunan noktanın altında kaç tane dallanma varsa o
kadar "xa" vardır diyeceğiz.Baktığımızda iki adet dallanma olduğu
görülmektedir.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="new6" src="/images/suffix_tree/new6.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Peki "bxa" var mıdır ?&lt;/strong&gt;&lt;br /&gt;
Ağaçta aramaya tekrar root noktasından başlanır ve sırayla "bxa"
aranır.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="new6.1png" src="/images/suffix_tree/new6.1png.png" /&gt;&lt;br /&gt;
evet "bxa" vardır ve 1 kere bulunur.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Peki "xb" var mı?&lt;/strong&gt;&lt;br /&gt;
Hayır "xb" yoktur.Sebebi ise root noktasından aramaya başlandığında
"xb" eşlemesi ile başlayan bir dallanma bulunamamıştır.&lt;/p&gt;
&lt;p&gt;&lt;span style="color: #ff9900;"&gt;&lt;strong&gt;Her dizgi bir suffix tree sahibi
midir?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Her dizgi bir suffix tree sahibi değildir.Eğer bir dizginin suffixleri
prefixlerine eşitse bir suffix ağacı yoktur.Mesela "cdbcd" için inceleme
yapalım.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Suffixlerin : cdbcd,dbcd,bcd,&lt;strong&gt;cd&lt;/strong&gt;,d olduğunu biliyoruz.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ve&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Prefixleri : c,&lt;strong&gt;cd&lt;/strong&gt;,cdb,cdbc,cdbcd şeklindedir.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Dizginin kendisi dikkate alınmadan incelendiğinde "cd" değerlerinin
ortak olduğu görülmektedir.Dolayısı ile "cdbcd" için bir suffix tree
çizilemez.Peki bu sorunu nasıl çözebiliriz ? Çok basit sadece "cdbcd"
stringinin sonuda bir "\$" ekleyerek.Eğer "cdbcd\$" için inceleme
yaparsanız bir sorun olmadığını göreceksiniz.&lt;/p&gt;
&lt;p&gt;BURAK KÖSE&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Thu, 04 Dec 2014 00:08:00 +0200</pubDate><guid isPermaLink="false">tag:localhost:8000,2014-12-04:blog/suffix-tree/</guid><category>algorithm</category><category>string</category><category>searching</category><category>bioinformatic</category></item><item><title>Radix Sort - Sıralama Algoritmaları</title><link>http://localhost:8000/blog/radix-sort/</link><description>&lt;p&gt;Türkçe'de taban sıralaması , basamaklı sıralama , kök sıralaması veya
hane sıralaması olarak geçen bu algoritmada sıralanacak olan veriler
hanelerine göre sıralanır.En değersiz olan haneden en değerli haneye
doğru sıralama işlemi yapılır.&lt;/p&gt;
&lt;p&gt;Sıralanacak verilerin tamsayı olduğu durumlarda kullanılan bu algoritma
işlenirken ilk olarak sıralanacak olan veri kümesindeki elemanların en
büyük elemanının kaç basamaklı olduğu tespit edildikten sonra sayıların
en değersiz olan basamağından itibaren incelenmeye başlanır ve yeni bir
diziye yerleştirilir.Bu işlem dizinin en büyük elemanının basamak sayısı
kadar tekrar edilir.&lt;/p&gt;
&lt;p&gt;Bu algoritmanın çalışma zamanı O(nk) ve yer karmaşıklığı O(n+k)
olacaktır.Gayet iyi bir çalışma zamanına sahip olmasının nedeni bu
algoritmanın karşılaştırmalı bir sıralama algoritması olmamasıdır.En
büyük dezavantajı ise her basamak işlemi için yeni bir bellek alanı
gerektirmesidir.&lt;/p&gt;
&lt;p&gt;&lt;span style="color: #ff9900;"&gt;&lt;strong&gt;Direkt Basamaklı SIralama ( Straight
Radix Sort)&lt;/strong&gt;&lt;/span&gt; algoritmasına bir örnek verelim.&lt;/p&gt;
&lt;p&gt;Sayılarımız : 32 , 224 , 16 , 15 , 31 , 169 , 123 , 252 olsun ve
çözümümüz için aşağıdaki gibi bir tablo ile daha rahat işlemlerimiz
anlaşılır.&lt;/p&gt;
&lt;p&gt;İlk olarak sayılar aşağıdaki gibi tabloya yerleştirildi.&lt;br /&gt;

&lt;div class="justtable"&gt;
    &lt;table&gt;
        
        
        &lt;thead&gt;
        &lt;tr&gt;
            
            
            &lt;th&gt;&lt;br /&gt;&lt;/th&gt;
            
        &lt;/tr&gt;
        &lt;/thead&gt;
        
        &lt;tbody&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;Hane3,Hane2,Hane1&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,3,2&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;2,2,4&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,1,6&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,1,5&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,3,1&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;1,6,9&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;1,2,3&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;2,5,2&lt;/td&gt;
                
            &lt;/tr&gt;
            
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/div&gt;&lt;br /&gt;
Hane1'e göre sıralama gerçekleştirildi.&lt;br /&gt;

&lt;div class="justtable"&gt;
    &lt;table&gt;
        
        
        &lt;thead&gt;
        &lt;tr&gt;
            
            
            &lt;th&gt;&lt;br /&gt;&lt;/th&gt;
            
        &lt;/tr&gt;
        &lt;/thead&gt;
        
        &lt;tbody&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;Hane3,Hane2,Hane1&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,3,1&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,3,2&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;2,5,2&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;1,2,3&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;2,2,4&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,1,5&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,1,6&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;1,6,9&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/div&gt;&lt;br /&gt;
Hane1 sıralaması bittikten sonra Hane2 sıralaması gerçekleştirildi.&lt;br /&gt;

&lt;div class="justtable"&gt;
    &lt;table&gt;
        
        
        &lt;thead&gt;
        &lt;tr&gt;
            
            
            &lt;th&gt;&lt;br /&gt;&lt;/th&gt;
            
        &lt;/tr&gt;
        &lt;/thead&gt;
        
        &lt;tbody&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;Hane3,Hane2,Hane1&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,1,5&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,1,6&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;1,2,3&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;2,2,4&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,3,1&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,3,2&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;2,5,2&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;1,6,9&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/div&gt;&lt;br /&gt;
ve son olarak maksimum sayımızın hane sayısına ulaşıldı ve Hane3'e göre
sıralama gerçekleştirildi.&lt;br /&gt;

&lt;div class="justtable"&gt;
    &lt;table&gt;
        
        
        &lt;thead&gt;
        &lt;tr&gt;
            
            
            &lt;th&gt;&lt;br /&gt;&lt;/th&gt;
            
        &lt;/tr&gt;
        &lt;/thead&gt;
        
        &lt;tbody&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;Hane3,Hane2,Hane1&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,1,5&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,1,6&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,3,1&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;0,3,2&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;1,2,3&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;1,6,9&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;2,2,4&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
            &lt;tr&gt;
                
                
                &lt;td&gt;2,5,2&lt;br /&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
            
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Her şey güzel peki sayının kaç basamaklı olduğunu nereden anlayacağız
diyorsanız.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;basamak sayısı = int(log(taban,max) + 1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Örneğin üstteki örneğimizde en büyük eleman 252 sayısı ve bu sayılar 10
tabanındadır.Dolayısı ile&lt;br /&gt;
log(10,252) + 1 = 3,401 olur ve bunu int çevirirsek = 3 çıkar.Şimdi bu
algoritmamızın örnek kodlarına gelelim.  &lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/7160796469da0dc175b0.js'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;from math import log

def getEmptyList(size): 
    # Boş bir liste döndürür
    return [ [] for i in range(size) ]
    
def getDigit(num, base, digit_num):
    # Hanelere göre değeri seçer
    # Örnek 123 sayısının ilk hanesi = 3
    return (num // base ** digit_num) % base
    
def maxWithAbs(p_list):
    # Maksimum sayıyı işaret farkı olmadan döndürür
    return max(abs(dig) for dig in p_list)  
    
def mergeList(p_list):
    # Parametre olarak aldığı listeyi birlştirir
    new_list = []
    for sub in p_list:
        new_list.extend(sub)
    return new_list
    
def split(s_list , base , digitNum):
    temp_list = getEmptyList(base)
    for number in s_list:
        temp_list[getDigit(number, base, digitNum)].append(number)
    return temp_list

def splitBySign(p_list):
    # işaretli sayıları gruplar
    buffer = [[], []]
    for num in p_list:
        if num &lt; 0:
            buffer[0].append(num)
        else:
            buffer[1].append(num)
    return buffer

def radixSort(_list,base):
    digitNum = int(log(maxWithAbs(_list),base) + 1)
    for dig in range(digitNum):#İşaretlere bakmaksızın sıralıyor
        _list = mergeList(split(_list, base, dig))
    return mergeList(splitBySign(_list))#işaretleri dikkate alıyor ve düzenliyor

liste = [123,113,55,11,56,7,1,-1,2]
print(radixSort(liste, 10))&lt;/code&gt;&lt;/pre&gt;
    &lt;/noscript&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span style="color: #ff9900;"&gt;&lt;strong&gt;Basamaklı Yer Değiştirme
Sıralaması(Radix Exchange Sort)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Şimdi direkt yerleştirmeli sıralamanın düzenlemiş hali olan Basamaklı
Yer Değiştirme Sıralaması'nı inceleyelim.Kısaca farkları şudur.Direkt
basamaklı sıralama algoritmasında sağdan-sola doğru yol alınırken bu
yaklaşımda soldan-sağa doğru yol alınır ve en önemli avantajı bu
algoritmada her basamak için özel bir bellek alanına ihtiyaç
duyulmayacaktır.Bu algoritma içerisinde&lt;a href="http://blog.koseburak.net/quick-sort/"&gt;Quick Sort(Hızlı
Sıralama)&lt;/a&gt; algoritması
kullanılmıştır.&lt;/p&gt;
&lt;p&gt;Sayılar ikili(binary) olarak tutulduğundan taban değişimi için ek bir
işlem yapılmasına gerek yoktur.Algoritmanın kodunu verirken biraz
modifiye ettiğimden söz etmeliyim.Ufak değişiklikler ile negatif sayılar
içinde işleyebilmesi için düzenledim.&lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/4f95b6ad2890d02759e7.js'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;from math import log

def swap(n1,n2):
    return n2 , n1

def getDigit(num, digit_num):
    return (num &gt;&gt; digit_num) &amp; 0x01

def splitBySign(p_list):
    # işaretli sayıları gruplar
    buffer = [[], []]
    for num in p_list:
        if num &lt; 0:
            buffer[0].append(num)
        else:
            buffer[1].append(num)
    return buffer 

def exchange(liste,down,up,digit):
    if up &gt; down and digit &gt;= 0:
        _down , _up = down , up
        while(_up &gt; _down):
            while(getDigit(liste[_down], digit) == 0 and _down &lt; _up):
                _down += 1
            while(getDigit(liste[_up], digit) == 1 and _down &lt; _up):
                _up -= 1
            liste[_down] , liste[_up] = swap(liste[_down], liste[_up])
        if(getDigit(liste[up], digit) == 0):
            _up += 1
        exchange(liste,down,_up -1,digit -1)
        exchange(liste,_down,up,digit-1)     
        
def RadixExchangeSort(p_list):
    temp_buffer = splitBySign(p_list) #sayıları işaretine göre gruplandırdık
    negative_list , possitive_list = temp_buffer[0] , temp_buffer[1]
    if len(negative_list) &gt; 0:#Eğer negatif sayı varsa
        exchange(negative_list,0,len(negative_list)-1,int(log(abs(min(negative_list)),2) + 1))
    if len(possitive_list) &gt; 0:#Eğer pozitif sayı varsa
        exchange(possitive_list,0,len(possitive_list)-1,int(log(max(possitive_list),2) + 1))
    return negative_list + possitive_list

#Deneme
liste = [31,30,29,-10,3,1,6,8,-123,-1233,-999]   
print(RadixExchangeSort(liste))
            &lt;/code&gt;&lt;/pre&gt;
    &lt;/noscript&gt;
&lt;/div&gt;
&lt;p&gt;BURAK KÖSE&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Wed, 03 Dec 2014 01:53:00 +0200</pubDate><guid isPermaLink="false">tag:localhost:8000,2014-12-03:blog/radix-sort/</guid><category>algorithm</category><category>sorting</category></item><item><title>Quick Sort - Sıralama Algoritmaları</title><link>http://localhost:8000/blog/quick-sort/</link><description>&lt;p&gt;Quick sort, Türkçe hızlı arama olan bu algoritma günümüzde en çok
tercih edilen sıralama algoritmasıdır.1960 yılında C. A. R. Hoare
tarafından ortaya atılmıştır.Bu algoritma yaklaşım bakımından "parçala
ve çözümle" ilkesine göre çalışmaktadır.&lt;/p&gt;
&lt;p&gt;Bu yaklaşım şu şekilde açıklanabilir.Eldeki problem çok daha ufak
problemciklere ayrılır ve bütün bu problemcikler tek tek çözülerek
birleştirilir ve sonuç elde edilir.Örneğin çarpılacak iki matrisin daha
küçük matrislere ayrılarak işlem yapılıp sonucun birleştirilerek elde
edilmesi.&lt;/p&gt;
&lt;p&gt;Şimdi gelelim algoritmanın çalışma şekline.İlk olarak sıralanacak veri
kümesini parçalayacak bir pivot seçilir.Geriye kalan elemanlar pivotun
sağına ve soluna yerleştirilir.Bu yerleştirme seçilen pivotun solunda
kalan elemanlar pivottan küçükler , sağında kalanlar ise pivottan büyük
elemanlar olacaktır , eşit olanların ise ne tarafa yerleştiklerinin bir
önemi yoktur.Bu işlem ardından yukarıdaki işlemler tüm parçalanmış
diziler içinde tekrarlanır ve sonuç olarak sıralanmış dizi elde edilir.&lt;/p&gt;
&lt;p&gt;Bu algoritmanın ortalama çalışma zamanının karmaşıklığı O(nlogn)
'dir.Sebebi veri kümesi her seferinde ikiye bölünerek devam eder(logn)
ve n adet eleman için sıralama yapılır.Algoritma en kötü durumda O(n\^2)
ile çalışır.En kötü durum oluşması için seçilen pivot , veri kümesinin
en küçük ya da en büyük büyük elemanı olması ile oluşur.&lt;/p&gt;
&lt;p&gt;Aşağıdaki animasyon&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="Quick Sort" src="https://upload.wikimedia.org/wikipedia/commons/9/9c/Quicksort-example.gif" /&gt;&lt;br /&gt;
&lt;em&gt;(Alıntı : wikipedia)&lt;/em&gt;
    ve video sonrası anlamak daha kolay olacaktır.
    &lt;iframe src="//www.youtube.com/embed/ywWBy6J5gz8" width="560" height="315" frameborder="0" allowfullscreen="allowfullscreen"&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/b53e632cedeb46078f7d.js'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;public static void quickSort(int[] arr, int left, int right) {
		int pivot = arr[(left + right) / 2];
		int _left = left;
		int _right = right;
		do {
			while (pivot &lt; arr[_right]) {
				_right--;
			}
			while (pivot &gt; arr[_left]) {
				_left++;
			}
			if (_left &lt;= _right) {
				if (_left != _right) {
					int temp = arr[_left];
					arr[_left] = arr[_right];
					arr[_right] = temp;
				}
				_right--;
				_left++;
			}
		} while (_right &gt;= _left);
		if (left &lt; _right){
			quickSort(arr, left, _right);
		}
		if (right &gt; _left){
			quickSort(arr, _left, right);
		}
	}&lt;/code&gt;&lt;/pre&gt;
    &lt;/noscript&gt;
&lt;/div&gt;
&lt;h4 id="35gelistirilmis-hzl-sralamaenhanced-quick-sort" style="text-align: justify;"&gt;&lt;span style="color: #ff9900;"&gt;&lt;strong&gt;#Geliştirilmiş Hızlı Sıralama(Enhanced Quick Sort)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;Quick sort algoritmasında en kötü durum sonucunun ürettiği performans
düşüklüğünü göz önüne alınarak algoritmada değişikliğe
gidilmiştir.Bununla birlikte veri kümesinin 10'dan az elemana sahip
olduğu zamanlarda hızlı sıralama algoritmasının yerine &lt;a href="http://blog.koseburak.net/insertion-sort/"&gt;direkt
yerleştirme sıralama&lt;/a&gt;sının
uygulanması daha efektif olacaktır.&lt;/p&gt;
&lt;p&gt;En kötü durumun oluşmasının nedeni pivot seçimidir.Pivot seçimi normal
şartlar altında dizinin orta noktası seçilerek gerçekleşiyordu.Bunun
yerine bu yaklaşımda pivot elemanı dizinin ortasındaki,başındaki ve
sonundaki elemanlar karşılaştırılarak seçilmesi şeklinde
düzenlenmiştir(bknz : median of three).Bu değişiklik hızlı sıralama
algoritmasının karmaşıklığını değiştirmeyecek fakat gerçekleştirilen
karşılaştırma sayısında azalma olacaktır.&lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/6db3ad4e3893dc530408.js'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;public static void quickSort(int[] arr, int left, int right) {
	if (right - left &lt; 10) {
		insertionSort(arr,left,right);
	}
			
	int pivot;
		
	if (arr[right] &gt; arr[left]) {
		if (arr[(left + right) / 2] &gt; arr[right]) {
			pivot = arr[right];
		} else if (arr[(left + right) / 2] &gt; arr[left]) {
			pivot = arr[(left + right) / 2];
		} else {
			pivot = arr[left];
		}
	} 
	
	else {
		if (arr[(left + right) / 2] &gt; arr[left]) {
			pivot = arr[left];
		} else if (arr[(left + right) / 2] &gt; arr[right]) {
			pivot = arr[(left + right) / 2];
		} else {
			pivot = arr[right];
		}
	}
		
	int _left = left;
	int _right = right;
		
	do {
		while (pivot &lt; arr[_right]) {
			_right--;
		}
		while (pivot &gt; arr[_left]) {
			_left++;
		}
		if (_left &lt;= _right) {
			if (_left != _right) {
				int temp = arr[_left];
				arr[_left] = arr[_right];
				arr[_right] = temp;
			}
			_right--;
			_left++;
		}
	} while (_right &gt;= _left);
	
	if (left &lt; _right) {
		quickSort(arr, left, _right);
	}
	if (right &gt; _left) {
		quickSort(arr, _left, right);
	}
		
}&lt;/code&gt;&lt;/pre&gt;
    &lt;/noscript&gt;
&lt;/div&gt;
&lt;h4 id="35yinelemeli-olmayan-hzl-sralamanon-recursive-quick-sort"&gt;&lt;span style="color: #ff9900;"&gt;**#Yinelemeli Olmayan Hızlı Sıralama(Non-Recursive Quick Sort)&lt;/h4&gt;
&lt;p&gt;**&lt;/span&gt; {style="text-align: justify;"}&lt;/p&gt;
&lt;p&gt;Özyinelemeli(recursion) yaklaşımdan zorunda kalmadığım müddetçe uzak
kalmaya çalışıyorum.Bazı zamanlar oldukça yorucu olabiliyor.Bu
algoritmayıda olumsuz yönde etkileyen bir etken özyinelemeli yaklaşım.&lt;/p&gt;
&lt;p&gt;Stack kullanarak bu soruna bir alternatif yaklaşım üretebiliriz.Hızlı
sıralama algoritmasında fark edildiği gibi aslında çok önemli iki
parametre alıyor.Bunlar alt veri kümenin başlangıç ve bitiş
indisleri.Bunları ayrı bir veri yapısında tutarak şöyle bir çözüm
üretebiliriz.&lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/7faa4e70c7c672ee2694.js'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;public static void quickSort(int[] arr) {
	int subArray = 0;
	Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
	stack.push(0); // left
	stack.push(arr.length - 1); // right
	do {
		int right = stack.pop();
		int left = stack.pop();
		--subArray;
		do {
			int _left = left;
			int _right = right;
			int pivot = arr[(left + right) / 2];
			do {
				while (pivot &lt; arr[_right]) {
					_right--;
				}
				while (pivot &gt; arr[_left]) {
					_left++;
				}
				if (_left &lt;= _right) {
					if (_left != _right) {
						int temp = arr[_left];
						arr[_left] = arr[_right];
						arr[_right] = temp;
					}
					_right--;
					_left++;
				}
			} while (_right &gt;= _left);
			if (_left &lt; right) {
				++subArray;
				stack.push(_left);
				stack.push(right);
			}
			right = _right;
		} while (left &lt; right);
	} while (subArray &gt; -1);
}&lt;/code&gt;&lt;/pre&gt;
    &lt;/noscript&gt;
&lt;/div&gt;
&lt;p&gt;Yapılan değişiklikler algoritmanın karmaşıklığını etkilemediği için
çalışma zamanı karmaşıklığı değişmemektedir.&lt;/p&gt;
&lt;p&gt;BURAK KÖSE&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Thu, 27 Nov 2014 12:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost:8000,2014-11-27:blog/quick-sort/</guid><category>algorithm</category><category>sorting</category></item><item><title>İlk iş kısa süreliler (Shortest Job First)</title><link>http://localhost:8000/blog/sjf/</link><description>&lt;p&gt;Bir önceki yazımda cpu zamanlama algoritmalarından olan fcfs
algoritmasından bahsetmiştim.Asıl ismi "shortest next CPU burst
algorithm" olarak geçen ve yine bir cpu zamanlama algoritması olan
Shortest Job First(SJF) yani en kısa iş ilk algoritmasını inceleyelim.&lt;/p&gt;
&lt;p&gt;Bu algoritmada belli bir sırada bekleyen işlerden önce kısa olanların
işlenmesi amaçlanmıştır.Eğer iki işten aynı çalışma süresi içeren işler
varsa geliş sıralarına göre işlem görürler.Bu algoritmanın duruma göre
hem nonpreemptive(kesintisiz) hemde preemptive(kesintili) olarak
düzenlenebilir.&lt;/p&gt;
&lt;p&gt;Temel olarak eldeki işlerin en kısasını yaparak zamandan kazanmaya
çalışan bir algoritma olsada en büyük dezavantajı bir çıkmaz
yaratmasıdır.Bu çıkmazı şöyle bir örnek ile açıklayabiliriz.&lt;/p&gt;
&lt;p&gt;Bir berbere gidiyorsunuz ve berberde sıra var.Dolayısı ile sıra almanız
gerekiyor ve sıraya giriyorsunuz .Bu berberde işi kısa sürecek olan
kişilere hep öncelik tanınıyor.Dolayısı ile siz,işi sizden uzun
süreceklerin önüne geçiyorsunuz ve sıra size geliyor .İşiniz
hallediliyor tam siz berberden çıkarken yine işi kısa sürecek biri
geliyor ve sizin önünüze geçtiğiniz kişinin sırasını tekrar alıyor ve
bunun çalışma saatleri bitene kadar böyle devam ettiğini
düşünün.Dolayısı ile işi uzun ama çok önce gelmiş kişiler gün sonunda
işini halledememiş bir şekilde beklemeye devam ediyorlar.&lt;/p&gt;
&lt;p&gt;Böyle bir kısır döngüye girme ihtimali bulunmaktadır.Şimdi
algoritmamızı nonpreemptive bir durum için şu örnek ile açıklamaya devam
edelim.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;Process&lt;/th&gt;
&lt;th align="center"&gt;Çalışma Zamanı&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;A&lt;/td&gt;
&lt;td align="center"&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;B&lt;/td&gt;
&lt;td align="center"&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;C&lt;/td&gt;
&lt;td align="center"&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;D&lt;/td&gt;
&lt;td align="center"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ve sonuç olarak aşağıdaki gibi bir çalışma zamanı tablosu göreceğiz.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;Başlangıç Zamanı&lt;/th&gt;
&lt;th align="center"&gt;Process&lt;/th&gt;
&lt;th align="center"&gt;Çalışma Zamanı&lt;/th&gt;
&lt;th align="center"&gt;Kalan Zaman&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;D&lt;/td&gt;
&lt;td align="center"&gt;5&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;5&lt;/td&gt;
&lt;td align="center"&gt;A&lt;/td&gt;
&lt;td align="center"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;13&lt;/td&gt;
&lt;td align="center"&gt;C&lt;/td&gt;
&lt;td align="center"&gt;9&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;22&lt;/td&gt;
&lt;td align="center"&gt;B&lt;/td&gt;
&lt;td align="center"&gt;10&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Bu işlemler sonunda işlemlerin bekleme süreleri&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;Process&lt;/th&gt;
&lt;th align="center"&gt;Çalışma Zamanı&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;A&lt;/td&gt;
&lt;td align="center"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;B&lt;/td&gt;
&lt;td align="center"&gt;22&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;C&lt;/td&gt;
&lt;td align="center"&gt;13&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;D&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Yukarıdaki örnekde giren işlem kesintisiz bir şekilde
gerçekleşmiştir.Şimdi bu örneğimizde ise algoritmamızı preemptive bir
durum için inceleyelim.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;Process&lt;/th&gt;
&lt;th align="center"&gt;Geliş Zamanı&lt;/th&gt;
&lt;th align="center"&gt;Çalışma Zamanı&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;A&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;B&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;C&lt;/td&gt;
&lt;td align="center"&gt;2&lt;/td&gt;
&lt;td align="center"&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;D&lt;/td&gt;
&lt;td align="center"&gt;3&lt;/td&gt;
&lt;td align="center"&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ve sonuç olarak aşağıdaki gibi bir çalışma zamanı tablosu göreceğiz.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;Başlangıç Zamanı&lt;/th&gt;
&lt;th align="center"&gt;Process&lt;/th&gt;
&lt;th align="center"&gt;Çalışma Zamanı&lt;/th&gt;
&lt;th align="center"&gt;Kalan Zaman&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;A&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;B&lt;/td&gt;
&lt;td align="center"&gt;6&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;7&lt;/td&gt;
&lt;td align="center"&gt;D&lt;/td&gt;
&lt;td align="center"&gt;7&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;14&lt;/td&gt;
&lt;td align="center"&gt;A&lt;/td&gt;
&lt;td align="center"&gt;9&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;23&lt;/td&gt;
&lt;td align="center"&gt;C&lt;/td&gt;
&lt;td align="center"&gt;11&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;BURAK KÖSE&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Wed, 26 Nov 2014 12:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost:8000,2014-11-26:blog/sjf/</guid><category>algorithm</category><category>operating systems</category><category>scheduling</category></item><item><title>Selection Sort - Sıralama Algoritmaları</title><link>http://localhost:8000/blog/selection-sort/</link><description>&lt;p&gt;Veri kümesinin sıralı olarak tutulması için geliştirilmiş en basit
sıralama algoritmalarındandır.Türkçe'de seçmeli sıralama , seçerek
sıralama şeklinde kullanılır.Geliştirilen uygulamalarda seçmeli sıralama
kullanmak için düzgün bir analiz yapılması gerekir.Yer değiştirme
sayısındaki sabitlik dolayısı ile büyük sayıda verinin bulunduğu uzun
dosyalarda lineer zamanda sıralama yapılabilir.&lt;/p&gt;
&lt;p&gt;Temel olarak işleyiş şu şekilde gerçekleşir.İlk olarak veri kümesinin
ilk elemanı seçilir ve geri kalan veriler ile karşılaştırılarak en küçük
eleman bulunur ve kümenin başına yazılır.Daha sonra bir sonraki
elemanlar içinde aynı işlem yapılarak dizi sıralanana kadar n. adımda
tamamlanır.Aşağıdaki animasyon ile daha iyi anlayabiliriz.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="Selection Sort" src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" /&gt;&lt;br /&gt;
&lt;em&gt;(Alıntı : wikipedia)&lt;/em&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Karmaşıklık analizi : O(n \^ 2)&lt;br /&gt;
 Karşılaştırma sayısı : n\^2 / 2&lt;br /&gt;
 Yer değiştirme sayısı : n (sabit)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;center&gt;
    &lt;iframe width="560" height="315" src="//www.youtube.com/embed/Ns4TPTC8whw" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/f90e31967b4d07aa8601.js'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;public void selectionSort(int[] arr){
  for(int i = 0 ; i &lt; arr.length - 1 ; i++){
    int minPos = i;
    for(int j = i+1 ; j &lt; arr.length ; j++){
      if(arr[j] &lt; arr[minPos]){
        min = j;  
      }
    }
    int temp = arr[i];
    arr[i] = arr[minPos];
    arr[minPos] = temp;
  }
} &lt;/code&gt;&lt;/pre&gt;
    &lt;/noscript&gt;
&lt;/div&gt;
&lt;p&gt;BURAK KÖSE&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Tue, 25 Nov 2014 12:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost:8000,2014-11-25:blog/selection-sort/</guid><category>algorithm</category><category>sorting</category></item><item><title>Insertion Sort - Sıralama Algoritmaları</title><link>http://localhost:8000/blog/insertion-sort/</link><description>&lt;p&gt;Uygulaması kolay olan bu algoritmayı büyük diziler yerine daha küçük
dizilerde kullanıldığında ve özellikle gelen veri kümesinin zaten
sıralanmış veya sıralanmış haline çok yakın olduğunda kullanılır.&lt;/p&gt;
&lt;p&gt;Kararlı bir algoritma olmasıyla birlikle çalışma anında ek bir bellek
ihtiyacı duymayan bu algoritma Türkçe'da yerleştirmeli sıralama ,
eklemeli sıralama ve sokma sıralaması olarak adlandırılabilir.&lt;/p&gt;
&lt;p&gt;Algoritma sıralanacak olam veri kümesinin ikinci elemanından itibaren
verileri sırayla kontrol eder ve bir önceki kayıt o anki kayıttan
büyükse(veya küçükse sıralama tipine bağlı olarak) bu iki elemanın
yerleri değiştirilir ve geriye doğru kontrollere devam edilir.Dizi
elemanı doğru yere yerleştirilene kadar bu işlemler tekrar edilir.&lt;/p&gt;
&lt;p&gt;Günlük hayatta aslında iskambil kağıtlarını sıralarken bu algoritmayı
kullanırız.Şimdi bu algoritmayı analiz edelim.&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;En iyi durumda (best case) : O(n)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dizi zaten sıralanmıştır&lt;br /&gt;
Karşılaştırma sayısı : n(n-1)/2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;En kötü durumda(worst case) : O(n\^2)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dizi tersten sıralı&lt;br /&gt;
Karşılaştırma sayısı : n(n-1)/2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;ve bu algoritmayı aşağıdaki şekilde tanımlayabiliriz.&lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/8ad4a6c60d2cc51fe8d4.js'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;public void insertionSort(int[] arr){
  fo(int i = 1 ; i &lt; arr.length ; i++){
    for(int j = i ; j &gt; 0 ; j--){
      if(arr[j] &lt; arr[j-1]){
        int temp = arr[j];
        arr[j] = arr[j-1];
        arr[j-1] = temp;
      }else{
        break;
      }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
    &lt;/noscript&gt;
&lt;/div&gt;
&lt;iframe src="//www.youtube.com/embed/ROalU379l3U" width="560" height="315" frameborder="0" allowfullscreen="allowfullscreen"&gt;&lt;/iframe&gt;

&lt;h4 id="35direkt-yerlestirmeli-sralama-straight-insertion-sort" style="text-align: justify;"&gt;&lt;span style="color: #ff9900;"&gt;&lt;strong&gt;#Direkt Yerleştirmeli Sıralama (Straight Insertion Sort)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;Yukarıda bu algoritmanın günlük hayatta iskambil kağıtlarını sıralamak
için kullanıldığını söylemiştik.Aslında bu çok da doğru değildir.Bir
araya ekleme işlemi vardır fakat bu ekleme işlemi hiç bir zaman tek tek
kontrol yaparak ve yer değiştirerek olmayacaktır.Bir örnek verelim.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2,4,1,5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ve algoritmayı ilk adım için işletelim ve 4'ü seçelim bir işlem
yapılamayacaktır çünkü bu aşamada sıralıdır.Bir sonraki adım olarak 1'i
seçelim ve geriye doğru kotrollere devam edelim.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1 \&amp;lt; 4 mü ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;evet o halde 1'i araya al.Yeni durum &lt;strong&gt;"2,1,4,5"&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1 \&amp;lt; 2 mi?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;evet o halde tekrar araya al.Yeni durum &lt;strong&gt;"1,2,4,5"&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;şeklinde algoritma işleyecektir.Oysa biz gerçekte 2 ve 4 sıralı olduğu
için direk olarak 1'i en başa ekleyeceğiz.Yani her seferinde yer
değiştirme yapmayacağız sadece kaydırma işlemi yapacağız ve direkt
olarak yerleştirme yapacağız.&lt;/p&gt;
&lt;p&gt;Şimdi bu yaklaşım ile insertion sort'un yeniden düzenlenmiş bir
algoritması olan &lt;strong&gt;Direkt Yerleştirmeli Sıralama ( Straight Insertion
Sort)&lt;/strong&gt; algoritmasının inceleyelim.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;En kötü durumda(worst case) : O(n\^2)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dizi tersten sıralı&lt;br /&gt;
Karşılaştırma sayısı : n\^2 / 2&lt;br /&gt;
Yer değiştirme sayısı : n\^2 / 4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;[gist:id=b9ee29a595a80d486622]&lt;br /&gt;
Algoritmayı aşağıdaki animasyon ile daha iyi anlayabiliriz.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Insertion Sort" src="https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif" /&gt;&lt;br /&gt;
&lt;em&gt;(Alıntı : wikipedia)&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="35ikili-yerlestirmeli-sralamabinary-insertion-sort"&gt;&lt;strong&gt;&lt;span style="color: #ff9900;"&gt;#İkili Yerleştirmeli Sıralama(Binary Insertion Sort)&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Şimdi biraz daha derine inerek bu algoritmanın daha optimize bir hale
getirilmiş hali olan ve daha büyük veri kümelerinde diğer yerleştirmeli
sıralama algoritmalarına göre daha başarılı olan bir algoritma olan
İkili Yerleştirmeli Sıralama algoritmasını inceleyelim.&lt;/p&gt;
&lt;p&gt;Bu algoritmada seçilen dizi verisinin kendinden önce gelen veriler
arasında nereye yerleştirileceğine karar verilirken geriye doğru ardaşık
olarak kontrol etmek yerine , elimizdeki veri kümesine bir bütün olarak
bakılarak ikili arama yapılması amaçlanmıştır.Hedef yer belirlendikten
sonra tekrar kaydırma işlemi yapılarak işlem tamamlanır.&lt;/p&gt;
&lt;p&gt;Karmaşıklık için.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;En kötü durumda(worst case) : O(nlogn)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dizi tersten sıralı&lt;br /&gt;
Karşılaştırma sayısı : n(logn - nloge) (yaklaşık olarak)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/6a568b504a36dedbc397.js'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;public void insertionSort(int[] arr){
  
    for(int i = 1 ; i &lt; arr.length ; i++){
      
      int control = arr[i];
      int down = 0;
      int up = i;
      
      while(down &lt; up){
        int mid = (down + up) / 2;
        if(control &lt; arr[mid]){
          up = mid;
        }else{
          down = mid + 1 ;
        }
      }
      
      for(int j = i ; j &gt; down ; --j){
        int temp = arr[j];
        arr[j] = arr[j-1];
        arr[j-1] = temp;
      }
      
   }
} &lt;/code&gt;&lt;/pre&gt;
    &lt;/noscript&gt;
&lt;/div&gt;
&lt;p&gt;BURAK KÖSE&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Mon, 24 Nov 2014 16:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost:8000,2014-11-24:blog/insertion-sort/</guid><category>algorithm</category><category>sorting</category></item><item><title>İlk gelen işi kapar (First Come First Serve)</title><link>http://localhost:8000/blog/first-come-first-serve/</link><description>&lt;p&gt;Kısaca FCFS algoritması.İsim benzerliği ve aslında çalışma mantığı
bakımında kuyruk(queue) veri yapısına çok benzer(FIFO).Bilgisayar
alanında özellikle işletim sistemlerinde bir çok alanda kullanılan bir
algoritmadır.Bu algoritmik yaklaşımda bir sıraya ilk girenin işi ilk
halledilmektedir.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;Bu şu şekilde açıklanabilir.Mahallenizde bir berber bulunmaktadır fakat
ne yazık ki berber doludur ve herkes sırasını beklemektedir.Sizde bir
sıra alırsınız ve aldığınız sırayı beklemek zorundasınızdır.Sizi önemli
kılan hiç bir (para,pul,şöhret,tanıdık...) sıranızı beklemekten
alıkoyamaz ve size sıra gelebilmesi için berberin sizden önce gelen tüm
müşteriler ile ilgilenmiş olması gerekmektedir .İşte bu algoritmada buna
benzer şekilde çalışır.&lt;/p&gt;
&lt;p&gt;Şimdi bu algoritmayı CPU Scheduling yani işlemci zamanlama tarafından
örnekleyerek açıklayalım.Bu yaklaşımda işlemciye gelen işlerin
işlenmesi, işlemlerin geliş sırasına göre belirlenmektedir.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;Process&lt;/th&gt;
&lt;th align="center"&gt;Çalışma Zamanı&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;A&lt;/td&gt;
&lt;td align="center"&gt;23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;B&lt;/td&gt;
&lt;td align="center"&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;C&lt;/td&gt;
&lt;td align="center"&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ve sonuç olarak aşağıdaki gibi bir tablo göreceğiz.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;Başlangıç Zamanı&lt;/th&gt;
&lt;th align="center"&gt;Process&lt;/th&gt;
&lt;th align="center"&gt;Çalışma Zamanı&lt;/th&gt;
&lt;th align="center"&gt;Kalan Zaman&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;A&lt;/td&gt;
&lt;td align="center"&gt;23&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;23&lt;/td&gt;
&lt;td align="center"&gt;B&lt;/td&gt;
&lt;td align="center"&gt;6&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;29&lt;/td&gt;
&lt;td align="center"&gt;C&lt;/td&gt;
&lt;td align="center"&gt;2&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Bu algoritma sonunda işlemlerin bekleme süreleri&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;Process&lt;/th&gt;
&lt;th align="center"&gt;Bekleme Süresi&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;A&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;B&lt;/td&gt;
&lt;td align="center"&gt;23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;C&lt;/td&gt;
&lt;td align="center"&gt;29&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Dolayısı ile ortalama bekleme süresi = (0+23+29) / 3 = 17.3&lt;/p&gt;
&lt;p&gt;First come first serve (FCFS) algoritması nonpreemptive(kesintisiz) bir
zamanlama algoritmasıdır.Yani sıraya giren işlemlerden biri bitirilmeden
diğer işleme geçilmemektedir.&lt;/p&gt;
&lt;p&gt;Not : Eğer yukarıdaki processleri geliş sürelerine göre değilde çalışma
zamanlarına göre sıralayarak işleme alsaydık ortalama bekleme süresinin
daha az olduğunu görürdük.(bknz :SJF algoritması)&lt;/p&gt;
&lt;p&gt;BURAK KÖSE&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Mon, 24 Nov 2014 01:05:00 +0200</pubDate><guid isPermaLink="false">tag:localhost:8000,2014-11-24:blog/first-come-first-serve/</guid><category>algorithm</category><category>operating systems</category><category>scheduling</category></item><item><title>Bubble Sort - Sıralama Algoritmaları</title><link>http://localhost:8000/blog/bubble-sort/</link><description>&lt;p&gt;Algoritma yazılarıma sıralama algoritmaları ile başlamak istedim.İlk
olarak bubble sort ile başlamayı düşünürken bundan bir süre önce
izlediğim bir video aklıma geldi.&lt;/p&gt;
&lt;p&gt;Bu videoda Barack Obama'nın başkan seçilmeden önce Google'da yaptığı bir
konuşma geçiyor. Google CEO'su Eric Schmidt ile yaptığı sohbette
Obama'ya bir milyon adet 32-bit integer sayıyı sıralamak için en efektif
yolun hangisi olduğu soruluyor.Obama biraz bocalayıp düşündükten sonra
Schmidt sorduğu soru için tam özür dileyerek yanıtlamayabilirsiniz
diyecekken Obama'dan kabarcık sıralamasının doğru olduğunu düşünmüyorum
cevabı gelince Schmidt şaşırarak Obama'nın bilgisayar bilimleriyle
ilgili bir geçmişinin olmadığını söylerek cevabı ona kimin söylediğini
soruyor.Tam bunun üzerine Obama&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"Bizim oradada casuslarımız var"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;diyerekten ince esipirisini yapıyor.Şimdi gelelim algoritmamıza.&lt;/p&gt;
&lt;p&gt;Kabarcık sıralaması olarak geçen bu algoritma ilk olarak yer değiştirme
algoritması olarak adlandırılmıştır.Şimdilerde kabarcık sıralaması
olarak adlandırılmasının nedeni ise dizi içerisindeki elemanların
algoritmanın her anında dizi sonuna doğru ilerlemesidir(sıralama türüne
bağlı olarak).&lt;/p&gt;
&lt;p&gt;Algoritmanın analizi :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;En iyi durum : O(n)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-Dizi zaten sıralanmış&lt;br /&gt;
-Yer değiştirme sayısı: 0&lt;br /&gt;
-Karşılaştırma sayısı: n-1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;En kötü durum : O(n\^2)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-Dizi tersten sıralı&lt;br /&gt;
-Yer değiştirme sayısı: O(n\^2)&lt;br /&gt;
-Karşılaştırma sayısı: O(n\^2 /2)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ortalama durum : 0(n\^2)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-Bütün olasılıklar kontrol edilir&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;Dolayısı ile bu algoritmanın en kötü durumdaki çalışma zamanı
O(n\^2)'dir,algoritmanın en kötü durumda yapacağı karşılaştırma sayısı
O(n\^2 / 2)'dir ve yer karmaşıklığı O(n)'dir.&lt;/p&gt;
&lt;p&gt;Örneğin küçükten büyüğe doğru sıralanacak bir işlem için algoritma şu
adımlarda gerçekleşir.Dizinin başından başlanılarak dizi elemanları
sırayle gezilir , gezilen dizi elemanları kendinden sonra gelecek eleman
ile sıralama türüne bağlı olarak(küçüten büyüğe gibi) kontrol edilir ve
yer değiştirilir.Bu işlem dizi sonuna kadar devam eder.&lt;/p&gt;
&lt;p&gt;Bir örnek verelim&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;7 , 9 , 4 , 11 , 8 , 3 , 5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bu algoritmanın adımları şu şekilde olacaktır.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1. adım: 7 , 4 , 9 , 8 , 3 , 5 , 11&lt;/p&gt;
&lt;p&gt;2. adım: 4 , 7 , 8 , 5 , 7 , 9 , 11&lt;/p&gt;
&lt;p&gt;3. adım: 4 , 7 , 3 , 5 , 8 , 9 , 11&lt;/p&gt;
&lt;p&gt;4. adım: 4 , 3 , 5 , 7 , 8 , 9 , 11&lt;/p&gt;
&lt;p&gt;5. adım: 3 , 4 , 5 , 7 , 8 , 9 , 11&lt;/p&gt;
&lt;p&gt;6. adım: 3 , 4 , 5 , 7 , 8 , 9 , 11&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;gibi bir sonuç elde edilir.Yani kısaca şöyle bir işlem yapılıyor , iki
sayı alıyor bu iki sayıyı küçükten büyüğe sıralanacak şekilde yer
değitiriliyor ve bu işlem dizi bitene kadar tekrarlanıyor.Alttaki
animasyon anlamaya yardımcı olacaktır.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Bubble-sort-example-300px" src="//upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" /&gt;
&lt;em&gt;(Alıntı : wikipedia)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Kabarcık sıralaması çok da verimli olmayan bir sıralama algoritmasıdır
fakat bazı basit müdahaleler ile biraz daha efektif hale
getirilebilir.Bu konuda yazılarımı sıralama algoritmalarını temel olarak
inceledikten sonra yayınlayacağım bir yazıdan ulaşabilirsiniz.&lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/e26eaa1f57a84afa5273.js'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;public void bubbleSort(int[] arr)
  {
    int temp;
    for(int i=1; i&lt;arr.length; i++)
    {
      for(int j=0; j&lt;arr.length-i; j++)
      {
        if(arr[j] &gt; arr[j+1])
        {
          temp=arr[j];
          arr[j]=arr[j+1];
          arr[j+1]=temp;
        }
      }
    }
  }&lt;/code&gt;&lt;/pre&gt;
    &lt;/noscript&gt;
&lt;/div&gt;
&lt;p&gt;Obama ve Eric Schdimit konuşması için :  &lt;/p&gt;
&lt;iframe src="//www.youtube.com/embed/k4RRi_ntQc8" width="420" height="315" frameborder="0" allowfullscreen="allowfullscreen"&gt;&lt;/iframe&gt;

&lt;p&gt;Bubble sort için eğlenceli bir anlatım:  &lt;/p&gt;
&lt;iframe src="//www.youtube.com/embed/lyZQPjUT5B4" width="560" height="315" frameborder="0" allowfullscreen="allowfullscreen"&gt;&lt;/iframe&gt;

&lt;p&gt;BURAK KÖSE&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Sun, 23 Nov 2014 14:19:00 +0200</pubDate><guid isPermaLink="false">tag:localhost:8000,2014-11-23:blog/bubble-sort/</guid><category>algorithm</category><category>sorting</category></item><item><title>Arch Linux Nasıl Kurulur</title><link>http://localhost:8000/blog/arch-linux-kurulumu/</link><description>&lt;p&gt;&lt;em&gt;Bu yazı Arch Linux 2014 Ağustos kalıbı dikkate alınarak
hazırlanmıştır.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Neden Arch , Nedir Bu ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arch Linux "sürekli güncel"(bkz: "rolling release") paket mantığı
üzerine kurulu, belirli bir düzeyde GNU/Linux bilgisi olan kullanıcıları
hedef alan(tamamen göreceli kimileri yeni başlayanlar için ideal olduğu
görüşünde) bağımsız bir dağıtımdır.Arch hızlı, hafif, esnek ve basittir.&lt;/p&gt;
&lt;p&gt;Arch Linux temel sistemi olabildiğince ufaktır.Çeşitli
işlemlerin yapılması kullanıcıya bırakılmıştır.Kullanıcı istediği
doğrultuda zengin depo yardımıyla istediği şekilde kendine uygun şekle
getirebilir.Kısacası kendi evinizi istediğiniz şekilde
biçimlendiriyorsunuz.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kurulum&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Kurulum aşaması metin tabanlı gerçekleşmektedir.Dolayısı ile komutlar
ile kurulum yapılmaktadır.Arch Linux'un dökümantasyonu çok
gelişmiştir.Sadece kurulum aşamasında değil çoğu zaman karşılaştığınız
sorunların çok büyük bir bölümüne buradan çözüm bulabilirsiniz.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://wiki.archlinux.org/"&gt;https://wiki.archlinux.org/&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://archtr.org/wiki/index.php/Ana_Sayfa"&gt;http://archtr.org/wiki/index.php/Ana_Sayfa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Donanımım&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CPU: 64 bit Intel&lt;br /&gt;
 Hard Drive: 500GB HDD&lt;br /&gt;
 RAM: 8GB&lt;br /&gt;
 Intel Graphic Card&lt;br /&gt;
 Nvidia GTX 660M&lt;br /&gt;
 BIOS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Kuruluma Hazırlık Aşaması&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arch Linux'un elde edilmesi için bu adres üzerinden kalıba
ulaşabilirsiniz.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.archlinux.org/download/"&gt;https://www.archlinux.org/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CD veya USB üzerinden kurulumu gerçekleştirebilirsiniz.İndirdiğiniz
kalıbı bu ortamlara yazarak bir sonraki aşamaya geçelim ve kurulum
yapacağınız birimi boot ettiğimizde karşılaşacağımız ekran aşağıdaki
gibi olacaktır.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Karşılaşılan Ekran" src="/images/arch_linux/arch-linux-install-001.jpg" /&gt;]&lt;/p&gt;
&lt;h3 id="asama351-arch-kurulumu" style="text-align: justify;"&gt;&lt;strong&gt;Aşama#1 &lt;a href="https://wiki.archlinux.org/index.php/Beginners%27_Guide#Establish_an_internet_connection"&gt;Arch Kurulumu&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Kurulum aşamsında internet bağlantımız olması gerekmektedir.Dolayısı ile
benim önerim ethernet bağlantısı sağlamanız yönünde.Eğer kurulum
sırasında kablosuz bağlantı kullanacaksanız tebrikler ilk kez arch
wiki'yi kullanacaksınız demektir.&lt;/p&gt;
&lt;p&gt;İlk olarak türkçe klavye kullanmak için&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# loadkeys trq&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;komutunu veriniz.Bağlantı kontrolunuz için&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# ping -c 3 www.google.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Komutunun ekran çıksını size yol gösterecektir.Eğer her şey yolunda ise
bir sonraki adıma geçebilirsiniz.&lt;/p&gt;
&lt;h3 id="asama352-disk-bolumleme" style="text-align: justify;"&gt;&lt;strong&gt;Aşama#2 &lt;a href="https://wiki.archlinux.org/index.php/Beginners%27_Guide#Prepare_the_storage_drive"&gt;Disk Bölümleme&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Bu aşamada çok dikkatli olmasılısınz.Yanlış bir adım sizi veri kaybına
ve belkide delirmenize yol açabilir.Bu aşamayı elle gerçekleyeceğiniz
için önceden kendinize göre plan yaparak bölümleme işlemine geçiniz.&lt;/p&gt;
&lt;p&gt;Bölümlendirme aşamasında temel olarak genellikle dört bölüm
yaratılır.Bunlar boot , / ( Kök dizini) , home ve swap alanlarıdır.Ben
şahsen tek bölüm yaratıp o şekilde kullanmayı tercih ediyorum sizde
yedekleme için kullandığınız ayrı bir disk bölümü varsa home dizini
oluşturmanıza gerek yoktur.Swap alanı ise RAM'e bağlıdır.Eğer 4GB ve
üstü RAM kullanıyorsanız bu alanada ihtiyacınız yoktur.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/boot için = 100 MB&lt;/li&gt;
&lt;li&gt;Swap ( Takas alanı) için = 2 GB&lt;/li&gt;
&lt;li&gt;/ kök için = 20-25 GB&lt;/li&gt;
&lt;li&gt;home için ise kişisel olarak oluşturmak istediğiniz miktarı
    verebilirsiniz&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;İlk olarak lsblk komutunu çalıştırarak daha önceden olan
bölümlemelerinizi kontrol edin ve bu aşamadan sonra tek bir disk
kullandığınızı varsayarak&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# cfdisk dev/sda&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;komutu sonrası görüntünüz şu şekilde olacaktır.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Disk Bölümleme" src="/images/arch_linux/Selection_024.png" /&gt;&lt;/p&gt;
&lt;p&gt;Temel olarak bölüm ayırırken boş alan seçiliyken "New - &gt; Alan
boyutu - &gt; Tamam" şeklinde bir yol izleyeceğiz.Şimdi alanları ayırmaya
başlayalım ve ilk olarak boot alanı ayıralım.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/boot için 100 MB bölüm oluşturmak için New seçin ve alan oluştuktan
    sonra alt tarafdaki özelliklerden Bootable özelliği verdikten sonra
    Type kısmına 83 yazarak bir sonraki alana geçin.&lt;/li&gt;
&lt;li&gt;Swap (takas) alanı için bölüm oluşturulmalıdır. Ben 2GB ayırdım.
    Sizde kendinize göre ayırabilirsiniz. Type kısmına 82 yazdıktan
    sonra bir sonraki alana geçin.&lt;/li&gt;
&lt;li&gt;Kök ( / ) için bölüm oluşturulacaktır.Kök dizini için 20-25 GB kadar
    alan ayırın. Type kısmına 83 yazın.&lt;/li&gt;
&lt;li&gt;Aynı yol ile isteğiniz doğrultusunda home için dilediğiniz kadar
    alan ayırdıktan sonra alt tarafdan Write kullanarak oluşturduğunuz
    bölümleri yazın ve bir sonraki aşama için Quit ile çıkın.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;# lsblk&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;komutu ile kontrol edelim.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sda1 – BIOS Boot&lt;br /&gt;
 sda2 – root&lt;br /&gt;
 sda3 – swap&lt;br /&gt;
 sda4 – home&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;tabiki sizde durum farklı olabilir.Bu aşamadan sonrada sizdeki duruma
göre şekil veriniz.&lt;/p&gt;
&lt;h3 id="asama353-dosya-sistemlerini-olusturma" style="text-align: justify;"&gt;&lt;strong&gt;Aşama#3 &lt;a href="https://wiki.archlinux.org/index.php/Beginners%27_Guide#Create_filesystems"&gt;Dosya Sistemlerini Oluşturma&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Şimdi sırada oluşturduğumuz parçalara şekil vermeye geldi.Linux dosya
sistemi olarak ext4 kullanır.İlk olarak aşağıdaki komutları root ve home
dizinleri için yürütün.Bendeki şekli ile şu şekilde olacaktır.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# mkfs.ext4 /dev/sda2&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;# mkfs.ext4 /dev/sda4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Şimdi swap bölümümüz için bendeki şekli ile&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# mkswap /dev/sda3&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;# swapon /dev/sda3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ve bu aşamanın son kısmı olarak son kez kontrol edelim bir sorun yoksa
diğer aşamaya geçebiliriz&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# lsblk /dev/sda&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://wiki.archlinux.org/index.php/Beginners%27_Guide#Install_the_base_system"&gt;Temel Sistem
Kurulumu&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Her şey yerli yerinde ise sırada temel sistem kurulumumuz
bulunmaktadır.Öncelikle kök dizinimizi bağlayalım.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# mount /dev/sda2 /mnt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ve "home" isimli bir klasör yaratalım.Evet home için oluşturduğumuz
parçayıda buraya bağlayacağız.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# mkdir /mnt/home&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;# mount /dev/sda4 /mnt/home&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="asama354-temel-paketlerin-kurulumu" style="text-align: justify;"&gt;&lt;strong&gt;Aşama#4 Temel paketlerin Kurulumu&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Sırada sistemimizin temelini kurma aşamamız var.Bu aşamada iskelet
oluşacaktır.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacstrap -i /mnt base base-devel&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="asama355-fstab-guncelleme" style="text-align: justify;"&gt;&lt;strong&gt;Aşama#5 &lt;a href="https://wiki.archlinux.org/index.php/Beginners%27_Guide#Generate_an_fstab"&gt;fstab Güncelleme&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Tüm temel paketlerin kurulumu başarı ile gerçekleştiyse fstab'a tüm
değişiklikleri bildirebiliriz.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# genfstab -U -p /mnt &amp;gt;&amp;gt; /mnt/etc/fstab&lt;/code&gt;&lt;br /&gt;
(Not:Kesinlikle bir problem ile karşılaşmamış olmamız gerekmektedir)&lt;/p&gt;
&lt;p&gt;Linux'da her zaman yap kontrol et mekanizması işlemektedir.Bizde
yaptığımız değişikliği kontrol edelim.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# nano /mnt/etc/fstab&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Bir problem gözükmüyorsa CTRL + X ile çıkış yapabiliriz.&lt;/p&gt;
&lt;p&gt;Bu aşamalarda bir problem ile karşılaşmadıysak root ve home dizinlerinin
başarı ile bağlanmış olduğunu görebiliriz.Kök dizinimizi değiştirerek
diskte kurduğumuz temel sisteme bürünelim.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# arch-chroot /mnt ve bin/bash&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="asama356-dil-ve-bolge-ayarlar" style="text-align: justify;"&gt;&lt;strong&gt;Aşama#6 &lt;a href="https://wiki.archlinux.org/index.php/Beginners%27_Guide#Chroot_and_configure_the_base_system"&gt;Dil ve Bölge ayarları&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Ayarlarımız için sırası ile&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#nano /etc/locale.conf&lt;/code&gt;&lt;br /&gt;
açılan dosyaya&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LANG=tr_TR.UTF-8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;yazıp CTRL + O ile kayıt edip CTRL + X ile çıkalım.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# nano /etc/vconsole.conf&lt;/code&gt;&lt;br /&gt;
açılan dosyaya&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;KEYMAP=trq&lt;br /&gt;
 FONT=iso09,16&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;yazarak aynı şekilde kaydedip çıkalım.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# nano /etc/timezone&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Europe/Istabul&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;yazıp aynı şekilde kayıt edip çıkalım ve yaptığımız dil değişikliğini
yazmak için&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# locale-gen&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Hostname değiştirmek için&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# echo ... &amp;gt; /etc/hostname&lt;/code&gt;&lt;br /&gt;
(Not : ... olan yere dilediğinizi yazınız)&lt;/p&gt;
&lt;h3 id="asama357-depo-ayarlar" style="text-align: justify;"&gt;&lt;strong&gt;Aşama#7 Depo Ayarları&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Sırada depomuzu ayarlamaya geldik."pacman.conf" dosyamızı açalım&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# nano /etc/pacman.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Eğer 64 bit sistem kullanıyorsak&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[multilib]&lt;br /&gt;
 Include = /etc/pacman.d/mirrorlist&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;bu kısmı aktif etmemiz gerkeiyor.Başındaki # işaretini kaldırmanız
yeterlidir.Daha sonra CTRL + O ile kayıt edip CTRL+X ile çıkalım.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -Sy&lt;/code&gt;&lt;br /&gt;
ile depoyu güncelleyelim.&lt;/p&gt;
&lt;h3 id="asama358-kullanc-islemleri" style="text-align: justify;"&gt;&lt;strong&gt;Aşama#8 &lt;a href="https://wiki.archlinux.org/index.php/Users_and_Groups#User_management"&gt;Kullanıcı işlemleri&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Kullanıcı işlemlerine geçmeden önce bir root şifresi atayalım.Bunu
kesinlikle yapmalısınız.Linux kullanırken root ile işlem yapmamaya
dikkat edin.Dolayısı ile root kullanıcısından başka bir sistemi
kullanacağınız bir kullanıcı oluşturacağız fakat ilk olarak root
şifresi...&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# passwd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;komutunu yürüttükten sonra root kullanıcısına şifre atayınız.Tamamdır
şimdi sırada kullanıcı oluşturma var.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# useradd -m -g users -G wheel,storage,power -s /bin/bash ...&lt;/code&gt;&lt;br /&gt;
(Not: ... yerine kullanıcı adınızı giriniz)&lt;/p&gt;
&lt;p&gt;ve daha sonra&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# passwd ...&lt;/code&gt;&lt;br /&gt;
(Not: ... yerinde yukarıda oluşturduğunuz kullanıcı adı olacak)&lt;/p&gt;
&lt;p&gt;ile bu kullanıcıya bir şifre atamalıyız.Sırada sudo kurulumu var.Bu bize
root olmadan sistem üzerinde işlemler yapmamıza olanak sağlayacak&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S sudo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;daha sonra kişisel önerim olarak&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S bash-completion&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;kurulumu yapınız.Adındanda anlaşılacağı gibi otomatik tamamlamalarda
yardımcı olur.&lt;/p&gt;
&lt;h3 id="asama359-linux-cekirdegini-derleme" style="text-align: justify;"&gt;&lt;strong&gt;Aşama#9 Linux çekirdeğini derleme&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Bu aşamada kernel konfigirasyonunu tamamlamak ve yazmak için aşağıdaki
komutu yürütün.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#mkinitcpio -p linux&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="asama3510-boot-yukleyicisi" style="text-align: justify;"&gt;&lt;strong&gt;Aşama#10 &lt;a href="https://wiki.archlinux.org/index.php/Boot_Loaders"&gt;Boot yükleyicisi&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Bu aşamada grub kurulumu yapmalıyız.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S grub # grub-install --recheck /dev/sda&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;grub kurulumumuz tamamdır eğer sistemde birden fazla işletim sistemi
yüklüyse diğerlerinin algılanması için&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#pacman -S os-prober&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;komutunu yürütelim.Şimdi grubu güncelleyelim.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# grub-mkconfig -o /boot/grub/grub.cfg&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ve sistem açılışında bağlantı alabilmemiz için&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# systemctl enable dhcpcd.service&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;# systemctl start dhcpcd.service&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;sonrasında&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# exit&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;# umount -R /mnt&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;# reboot&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;komutlarını yürüttükten sonra sistem yeniden başlayacaktır.(Not: Yükleme
yaptığınız birimi(CD,USB...) çıkartınız.&lt;/p&gt;
&lt;h3 id="asama3511-boot-sonras" style="text-align: justify;"&gt;&lt;strong&gt;Aşama#11 Boot sonrası&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Bir sorun yoksa karşınızda Arch Linux sizi selamlamalıdır.Basit kurulum
bitmiş olup kurulum sonrası yapılandırma aşamasına geçmiş
bulunmaktayız.Bundan sonraki yapılandırmalar size kalmış olsada basit
olarak temel bir yapılandırma olarak şunları yapabilirsiniz.Unutmayın
archwiki en yakın dostunuz.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;X server Kurulumu&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;# pacman -S xorg-server xorg-server-utils xorg-xinit&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mesa Kurulumu&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S mesa&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Şimdi sırada ekran kartı kurulumu bulunmaktadır.Bu aşama genelde
kullanıcıların başına bela açan bir aşamadır(Bende dahil).Eğer
sisteminizde optimus teklonojili bir ekran kartınız varsa yani çift
ekran kartlıysanız sizi burada hiç oyalamadan Arch Linux Wiki sayfasına
yönlendireceğim.Yapmanız gerekenler orada harika bir şekilde anlatılmış
olup tüm adımları dikkatlice adım adım izlemelisiniz.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://archtr.org/wiki/index.php?title=Bumblebee"&gt;http://archtr.org/wiki/index.php?title=Bumblebee&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://wiki.archlinux.org/index.php/NVIDIA_Optimus"&gt;https://wiki.archlinux.org/index.php/NVIDIA_Optimus&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://wiki.archlinux.org/index.php/bumblebee"&gt;https://wiki.archlinux.org/index.php/bumblebee&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Eğer normal ekran kartı kullanıcısıysanız bile bu aşamada Arch Wiki'den
yardım alabilirsiniz.Kendinize uygun seçeneği kurun.Ben şu şekilde devam
ediyorum.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S nvidia&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S xf86-video-intel&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S xf86-video-ati&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="graphicsdoc.jpg" src="/images/arch_linux/graphicsdoc.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Eğer laptop kullanıcısıysanız&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S xf86-input-synaptics&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;daha sonrasında temel x server bileşenleri için&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S xorg-twm xorg-xclock xterm&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ve test etmek için sistemi yeniden başlatıp&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#startx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Her şey yolunda ise devam edebilirsiniz lakin değilse muhtemelen ekran
kartı kısmında bir yanlışlık yaptınız demektir.Arch wiki'den destek
alabilirsiniz.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ses sürücüsü için&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S alsa-lib alsa-utils&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dbus Kurulumu&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S dbus&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gamin Kurulumu&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S gamin&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="asama3512-masaustu-kurulumu" style="text-align: justify;"&gt;&lt;strong&gt;Aşama#12 Masaüstü Kurulumu&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Kde Masaüstü Kurulumu:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Uçbirimden devam ediyoruz.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S kde kde-l10n-tr&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;komutunu uygulayın&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gnome Masaüstü Kurulumu:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S gnome&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Yükleme bittikten sonra tekrardan&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S gnome-extra&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;# pacman -S gnome-tweak-tool&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cinnamon Kurulumu&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S cinnamon&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;komutunu uygulayıp soruları (Y) ile onaylayın.Eğer yukarıdaki örnekler
dışında kurmak istediğiniz bir masaüstü varsa siz istediğinizi
kurabilirisiniz.&lt;/p&gt;
&lt;p&gt;Açılışta aktif etmek için aşağıdakilerden hangisi size uygunsa onu
yürütün.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# systemctl enable gdm.service # systemctl enable kdm.service # systemctl enable lxdm.service # systemctl enable slim.service # systemctl enable xdm.service&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Firefox&lt;/strong&gt; için&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#pacman -S firefox&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="asama3513-ag" style="text-align: justify;"&gt;&lt;strong&gt;Aşama#13 &lt;a href="https://wiki.archlinux.org/index.php/Beginners%27_Guide#Configure_the_network"&gt;Ağ&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;# pacman -S networkmanager&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;arayüz için&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# pacman -S kdeplasma-applets-plasma-nm&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ve&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# systemctl enable NetworkManager&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;# systemctl start NetworkManager&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Ben kablosuz ağ kullanmak için yaptığımız aşamalarda nedenini bilmediğim
bir sorun ile karşılaştım.Bu sorunun çözümü için&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# systemctl disable dhcpcd.service&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;komutu ile çözdüm.&lt;/p&gt;
&lt;p&gt;ve son , artık gönül rahatlığı ile Arch Linux kullanabilirsiniz ,
unutmayın baş ucu kaynağı olarak Arch Wiki vazgeçilmeziniz olsun.&lt;/p&gt;
&lt;p&gt;Umarım işinize yarayan bir yazı olmuştur.&lt;/p&gt;
&lt;p&gt;BURAK KÖSE&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Burak</dc:creator><pubDate>Wed, 12 Nov 2014 18:45:00 +0200</pubDate><guid isPermaLink="false">tag:localhost:8000,2014-11-12:blog/arch-linux-kurulumu/</guid><category>archlinux</category></item></channel></rss>